// Generated by jextract

package com.sernamar.jgit2.bindings;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class git2_2 {

    git2_2() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("/tmp/libgit2-1.9.0/build/libgit2.so", LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _TIME_H 1
     * }
     */
    public static int _TIME_H() {
        return _TIME_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)36L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 36
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int _BITS_TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME_H 1
     * }
     */
    public static int _BITS_TIME_H() {
        return _BITS_TIME_H;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int CLOCK_REALTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME 0
     * }
     */
    public static int CLOCK_REALTIME() {
        return CLOCK_REALTIME;
    }
    private static final int CLOCK_MONOTONIC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC 1
     * }
     */
    public static int CLOCK_MONOTONIC() {
        return CLOCK_MONOTONIC;
    }
    private static final int CLOCK_PROCESS_CPUTIME_ID = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_PROCESS_CPUTIME_ID 2
     * }
     */
    public static int CLOCK_PROCESS_CPUTIME_ID() {
        return CLOCK_PROCESS_CPUTIME_ID;
    }
    private static final int CLOCK_THREAD_CPUTIME_ID = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_THREAD_CPUTIME_ID 3
     * }
     */
    public static int CLOCK_THREAD_CPUTIME_ID() {
        return CLOCK_THREAD_CPUTIME_ID;
    }
    private static final int CLOCK_MONOTONIC_RAW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW 4
     * }
     */
    public static int CLOCK_MONOTONIC_RAW() {
        return CLOCK_MONOTONIC_RAW;
    }
    private static final int CLOCK_REALTIME_COARSE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME_COARSE 5
     * }
     */
    public static int CLOCK_REALTIME_COARSE() {
        return CLOCK_REALTIME_COARSE;
    }
    private static final int CLOCK_MONOTONIC_COARSE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_COARSE 6
     * }
     */
    public static int CLOCK_MONOTONIC_COARSE() {
        return CLOCK_MONOTONIC_COARSE;
    }
    private static final int CLOCK_BOOTTIME = (int)7L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_BOOTTIME 7
     * }
     */
    public static int CLOCK_BOOTTIME() {
        return CLOCK_BOOTTIME;
    }
    private static final int CLOCK_REALTIME_ALARM = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME_ALARM 8
     * }
     */
    public static int CLOCK_REALTIME_ALARM() {
        return CLOCK_REALTIME_ALARM;
    }
    private static final int CLOCK_BOOTTIME_ALARM = (int)9L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_BOOTTIME_ALARM 9
     * }
     */
    public static int CLOCK_BOOTTIME_ALARM() {
        return CLOCK_BOOTTIME_ALARM;
    }
    private static final int CLOCK_TAI = (int)11L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_TAI 11
     * }
     */
    public static int CLOCK_TAI() {
        return CLOCK_TAI;
    }
    private static final int TIMER_ABSTIME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIMER_ABSTIME 1
     * }
     */
    public static int TIMER_ABSTIME() {
        return TIMER_ABSTIME;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __struct_tm_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_tm_defined 1
     * }
     */
    public static int __struct_tm_defined() {
        return __struct_tm_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int __itimerspec_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __itimerspec_defined 1
     * }
     */
    public static int __itimerspec_defined() {
        return __itimerspec_defined;
    }
    private static final int _BITS_TYPES_LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES_LOCALE_T_H() {
        return _BITS_TYPES_LOCALE_T_H;
    }
    private static final int _BITS_TYPES___LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES___LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES___LOCALE_T_H() {
        return _BITS_TYPES___LOCALE_T_H;
    }
    private static final int TIME_UTC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_UTC 1
     * }
     */
    public static int TIME_UTC() {
        return TIME_UTC;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _STDLIB_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDLIB_H 1
     * }
     */
    public static int _STDLIB_H() {
        return _STDLIB_H;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WSTOPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 2
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WCONTINUED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 8
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 16777216
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int __WNOTHREAD = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define __WNOTHREAD 536870912
     * }
     */
    public static int __WNOTHREAD() {
        return __WNOTHREAD;
    }
    private static final int __WALL = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define __WALL 1073741824
     * }
     */
    public static int __WALL() {
        return __WALL;
    }
    private static final int __W_CONTINUED = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define __W_CONTINUED 65535
     * }
     */
    public static int __W_CONTINUED() {
        return __W_CONTINUED;
    }
    private static final int __WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __WCOREFLAG 128
     * }
     */
    public static int __WCOREFLAG() {
        return __WCOREFLAG;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int __ldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ldiv_t_defined 1
     * }
     */
    public static int __ldiv_t_defined() {
        return __ldiv_t_defined;
    }
    private static final int __lldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __lldiv_t_defined 1
     * }
     */
    public static int __lldiv_t_defined() {
        return __lldiv_t_defined;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _ALLOCA_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_H 1
     * }
     */
    public static int _ALLOCA_H() {
        return _ALLOCA_H;
    }
    private static final int _INTTYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _INTTYPES_H 1
     * }
     */
    public static int _INTTYPES_H() {
        return _INTTYPES_H;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int ____gwchar_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____gwchar_t_defined 1
     * }
     */
    public static int ____gwchar_t_defined() {
        return ____gwchar_t_defined;
    }
    private static final int GIT_PATH_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define GIT_PATH_MAX 4096
     * }
     */
    public static int GIT_PATH_MAX() {
        return GIT_PATH_MAX;
    }
    private static final int GIT_OID_SHA1_SIZE = (int)20L;
    /**
     * {@snippet lang=c :
     * #define GIT_OID_SHA1_SIZE 20
     * }
     */
    public static int GIT_OID_SHA1_SIZE() {
        return GIT_OID_SHA1_SIZE;
    }
    private static final int GIT_OID_MINPREFIXLEN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GIT_OID_MINPREFIXLEN 4
     * }
     */
    public static int GIT_OID_MINPREFIXLEN() {
        return GIT_OID_MINPREFIXLEN;
    }
    private static final int GIT_INDEXER_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_INDEXER_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_INDEXER_OPTIONS_VERSION() {
        return GIT_INDEXER_OPTIONS_VERSION;
    }
    private static final int GIT_ODB_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_ODB_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_ODB_OPTIONS_VERSION() {
        return GIT_ODB_OPTIONS_VERSION;
    }
    private static final int GIT_COMMIT_CREATE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_COMMIT_CREATE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_COMMIT_CREATE_OPTIONS_VERSION() {
        return GIT_COMMIT_CREATE_OPTIONS_VERSION;
    }
    private static final int GIT_REPOSITORY_INIT_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_REPOSITORY_INIT_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_REPOSITORY_INIT_OPTIONS_VERSION() {
        return GIT_REPOSITORY_INIT_OPTIONS_VERSION;
    }
    private static final int GIT_DIFF_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_DIFF_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_DIFF_OPTIONS_VERSION() {
        return GIT_DIFF_OPTIONS_VERSION;
    }
    private static final int GIT_DIFF_HUNK_HEADER_SIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define GIT_DIFF_HUNK_HEADER_SIZE 128
     * }
     */
    public static int GIT_DIFF_HUNK_HEADER_SIZE() {
        return GIT_DIFF_HUNK_HEADER_SIZE;
    }
    private static final int GIT_DIFF_FIND_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_DIFF_FIND_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_DIFF_FIND_OPTIONS_VERSION() {
        return GIT_DIFF_FIND_OPTIONS_VERSION;
    }
    private static final int GIT_DIFF_PARSE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_DIFF_PARSE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_DIFF_PARSE_OPTIONS_VERSION() {
        return GIT_DIFF_PARSE_OPTIONS_VERSION;
    }
    private static final int GIT_DIFF_PATCHID_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_DIFF_PATCHID_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_DIFF_PATCHID_OPTIONS_VERSION() {
        return GIT_DIFF_PATCHID_OPTIONS_VERSION;
    }
    private static final int GIT_APPLY_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_APPLY_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_APPLY_OPTIONS_VERSION() {
        return GIT_APPLY_OPTIONS_VERSION;
    }
    private static final int GIT_ATTR_CHECK_FILE_THEN_INDEX = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GIT_ATTR_CHECK_FILE_THEN_INDEX 0
     * }
     */
    public static int GIT_ATTR_CHECK_FILE_THEN_INDEX() {
        return GIT_ATTR_CHECK_FILE_THEN_INDEX;
    }
    private static final int GIT_ATTR_CHECK_INDEX_THEN_FILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_ATTR_CHECK_INDEX_THEN_FILE 1
     * }
     */
    public static int GIT_ATTR_CHECK_INDEX_THEN_FILE() {
        return GIT_ATTR_CHECK_INDEX_THEN_FILE;
    }
    private static final int GIT_ATTR_CHECK_INDEX_ONLY = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GIT_ATTR_CHECK_INDEX_ONLY 2
     * }
     */
    public static int GIT_ATTR_CHECK_INDEX_ONLY() {
        return GIT_ATTR_CHECK_INDEX_ONLY;
    }
    private static final int GIT_ATTR_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_ATTR_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_ATTR_OPTIONS_VERSION() {
        return GIT_ATTR_OPTIONS_VERSION;
    }
    private static final int GIT_BLOB_FILTER_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_BLOB_FILTER_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_BLOB_FILTER_OPTIONS_VERSION() {
        return GIT_BLOB_FILTER_OPTIONS_VERSION;
    }
    private static final int GIT_BLAME_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_BLAME_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_BLAME_OPTIONS_VERSION() {
        return GIT_BLAME_OPTIONS_VERSION;
    }
    private static final int GIT_CHECKOUT_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_CHECKOUT_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_CHECKOUT_OPTIONS_VERSION() {
        return GIT_CHECKOUT_OPTIONS_VERSION;
    }
    private static final int GIT_INDEX_ENTRY_STAGESHIFT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define GIT_INDEX_ENTRY_STAGESHIFT 12
     * }
     */
    public static int GIT_INDEX_ENTRY_STAGESHIFT() {
        return GIT_INDEX_ENTRY_STAGESHIFT;
    }
    private static final int GIT_MERGE_FILE_INPUT_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_MERGE_FILE_INPUT_VERSION 1
     * }
     */
    public static int GIT_MERGE_FILE_INPUT_VERSION() {
        return GIT_MERGE_FILE_INPUT_VERSION;
    }
    private static final int GIT_MERGE_CONFLICT_MARKER_SIZE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define GIT_MERGE_CONFLICT_MARKER_SIZE 7
     * }
     */
    public static int GIT_MERGE_CONFLICT_MARKER_SIZE() {
        return GIT_MERGE_CONFLICT_MARKER_SIZE;
    }
    private static final int GIT_MERGE_FILE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_MERGE_FILE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_MERGE_FILE_OPTIONS_VERSION() {
        return GIT_MERGE_FILE_OPTIONS_VERSION;
    }
    private static final int GIT_MERGE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_MERGE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_MERGE_OPTIONS_VERSION() {
        return GIT_MERGE_OPTIONS_VERSION;
    }
    private static final int GIT_CHERRYPICK_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_CHERRYPICK_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_CHERRYPICK_OPTIONS_VERSION() {
        return GIT_CHERRYPICK_OPTIONS_VERSION;
    }
    private static final int GIT_PROXY_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_PROXY_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_PROXY_OPTIONS_VERSION() {
        return GIT_PROXY_OPTIONS_VERSION;
    }
    private static final int GIT_REMOTE_CREATE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_REMOTE_CREATE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_REMOTE_CREATE_OPTIONS_VERSION() {
        return GIT_REMOTE_CREATE_OPTIONS_VERSION;
    }
    private static final int GIT_REMOTE_CALLBACKS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_REMOTE_CALLBACKS_VERSION 1
     * }
     */
    public static int GIT_REMOTE_CALLBACKS_VERSION() {
        return GIT_REMOTE_CALLBACKS_VERSION;
    }
    private static final int GIT_FETCH_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_FETCH_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_FETCH_OPTIONS_VERSION() {
        return GIT_FETCH_OPTIONS_VERSION;
    }
    private static final int GIT_PUSH_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_PUSH_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_PUSH_OPTIONS_VERSION() {
        return GIT_PUSH_OPTIONS_VERSION;
    }
    private static final int GIT_REMOTE_CONNECT_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_REMOTE_CONNECT_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_REMOTE_CONNECT_OPTIONS_VERSION() {
        return GIT_REMOTE_CONNECT_OPTIONS_VERSION;
    }
    private static final int GIT_CLONE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_CLONE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_CLONE_OPTIONS_VERSION() {
        return GIT_CLONE_OPTIONS_VERSION;
    }
    private static final int GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS 10
     * }
     */
    public static int GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS() {
        return GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS;
    }
    private static final int GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE 7
     * }
     */
    public static int GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE() {
        return GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE;
    }
    private static final int GIT_DESCRIBE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_DESCRIBE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_DESCRIBE_OPTIONS_VERSION() {
        return GIT_DESCRIBE_OPTIONS_VERSION;
    }
    private static final int GIT_DESCRIBE_FORMAT_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_DESCRIBE_FORMAT_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_DESCRIBE_FORMAT_OPTIONS_VERSION() {
        return GIT_DESCRIBE_FORMAT_OPTIONS_VERSION;
    }
    private static final int GIT_FILTER_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_FILTER_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_FILTER_OPTIONS_VERSION() {
        return GIT_FILTER_OPTIONS_VERSION;
    }
    private static final int GIT_REBASE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_REBASE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_REBASE_OPTIONS_VERSION() {
        return GIT_REBASE_OPTIONS_VERSION;
    }
    private static final int GIT_REVERT_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_REVERT_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_REVERT_OPTIONS_VERSION() {
        return GIT_REVERT_OPTIONS_VERSION;
    }
    private static final int GIT_STASH_SAVE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_STASH_SAVE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_STASH_SAVE_OPTIONS_VERSION() {
        return GIT_STASH_SAVE_OPTIONS_VERSION;
    }
    private static final int GIT_STASH_APPLY_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_STASH_APPLY_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_STASH_APPLY_OPTIONS_VERSION() {
        return GIT_STASH_APPLY_OPTIONS_VERSION;
    }
    private static final int GIT_STATUS_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_STATUS_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_STATUS_OPTIONS_VERSION() {
        return GIT_STATUS_OPTIONS_VERSION;
    }
    private static final int GIT_SUBMODULE_UPDATE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_SUBMODULE_UPDATE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_SUBMODULE_UPDATE_OPTIONS_VERSION() {
        return GIT_SUBMODULE_UPDATE_OPTIONS_VERSION;
    }
    private static final int GIT_WORKTREE_ADD_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_WORKTREE_ADD_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_WORKTREE_ADD_OPTIONS_VERSION() {
        return GIT_WORKTREE_ADD_OPTIONS_VERSION;
    }
    private static final int GIT_WORKTREE_PRUNE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_WORKTREE_PRUNE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_WORKTREE_PRUNE_OPTIONS_VERSION() {
        return GIT_WORKTREE_PRUNE_OPTIONS_VERSION;
    }
    private static final int GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION() {
        return GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION;
    }
    private static final int GIT_OBJ__EXT1 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GIT_OBJ__EXT1 0
     * }
     */
    public static int GIT_OBJ__EXT1() {
        return GIT_OBJ__EXT1;
    }
    private static final int GIT_OBJ__EXT2 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define GIT_OBJ__EXT2 5
     * }
     */
    public static int GIT_OBJ__EXT2() {
        return GIT_OBJ__EXT2;
    }
    private static final int GIT_EMAIL_CREATE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_EMAIL_CREATE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_EMAIL_CREATE_OPTIONS_VERSION() {
        return GIT_EMAIL_CREATE_OPTIONS_VERSION;
    }
    private static final int GIT_ODB_BACKEND_PACK_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_ODB_BACKEND_PACK_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_ODB_BACKEND_PACK_OPTIONS_VERSION() {
        return GIT_ODB_BACKEND_PACK_OPTIONS_VERSION;
    }
    private static final int GIT_ODB_BACKEND_LOOSE_OPTIONS_VERSION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GIT_ODB_BACKEND_LOOSE_OPTIONS_VERSION 1
     * }
     */
    public static int GIT_ODB_BACKEND_LOOSE_OPTIONS_VERSION() {
        return GIT_ODB_BACKEND_LOOSE_OPTIONS_VERSION;
    }
    private static final int LIBGIT2_VERSION_MAJOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LIBGIT2_VERSION_MAJOR 1
     * }
     */
    public static int LIBGIT2_VERSION_MAJOR() {
        return LIBGIT2_VERSION_MAJOR;
    }
    private static final int LIBGIT2_VERSION_MINOR = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LIBGIT2_VERSION_MINOR 9
     * }
     */
    public static int LIBGIT2_VERSION_MINOR() {
        return LIBGIT2_VERSION_MINOR;
    }
    private static final int LIBGIT2_VERSION_REVISION = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LIBGIT2_VERSION_REVISION 0
     * }
     */
    public static int LIBGIT2_VERSION_REVISION() {
        return LIBGIT2_VERSION_REVISION;
    }
    private static final int LIBGIT2_VERSION_PATCH = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LIBGIT2_VERSION_PATCH 0
     * }
     */
    public static int LIBGIT2_VERSION_PATCH() {
        return LIBGIT2_VERSION_PATCH;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = git2.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = git2.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = git2.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = git2.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = git2.C_POINTER;

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG    );

        public static final MemorySegment ADDR = git2.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static long time(MemorySegment __timer) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", __timer);
            }
            return (long)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_DOUBLE,
            git2.C_LONG,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static double difftime(long __time1, long __time0) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", __time1, __time0);
            }
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static long mktime(MemorySegment __tp) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static long strftime(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", __s, __maxsize, __format, __tp);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strftime_l$descriptor() {
        return strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MethodHandle strftime_l$handle() {
        return strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MemorySegment strftime_l$address() {
        return strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static long strftime_l(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp, MemorySegment __loc) {
        var mh$ = strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime_l", __s, __maxsize, __format, __tp, __loc);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime(MemorySegment __timer) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime(MemorySegment __timer) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime(MemorySegment __tp) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", __tp);
            }
            return (MemorySegment)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime(MemorySegment __timer) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment __tp, MemorySegment __buf) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", __tp, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__tp, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment __timer, MemorySegment __buf) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", __timer, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, git2.C_POINTER);
        public static final MemorySegment SEGMENT = git2.findOrThrow("__tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static SequenceLayout __tzname$layout() {
        return __tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static long[] __tzname$dimensions() {
        return __tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname() {
        return __tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, __tzname$constants.SEGMENT, 0L, __tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname(long index0) {
        return (MemorySegment)__tzname$constants.HANDLE.get(__tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(long index0, MemorySegment varValue) {
        __tzname$constants.HANDLE.set(__tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class __daylight$constants {
        public static final OfInt LAYOUT = git2.C_INT;
        public static final MemorySegment SEGMENT = git2.findOrThrow("__daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static OfInt __daylight$layout() {
        return __daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static MemorySegment __daylight$segment() {
        return __daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static int __daylight() {
        return __daylight$constants.SEGMENT.get(__daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static void __daylight(int varValue) {
        __daylight$constants.SEGMENT.set(__daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class __timezone$constants {
        public static final OfLong LAYOUT = git2.C_LONG;
        public static final MemorySegment SEGMENT = git2.findOrThrow("__timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static OfLong __timezone$layout() {
        return __timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static MemorySegment __timezone$segment() {
        return __timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static long __timezone() {
        return __timezone$constants.SEGMENT.get(__timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static void __timezone(long varValue) {
        __timezone$constants.SEGMENT.set(__timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, git2.C_POINTER);
        public static final MemorySegment SEGMENT = git2.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname(long index0) {
        return (MemorySegment)tzname$constants.HANDLE.get(tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(long index0, MemorySegment varValue) {
        tzname$constants.HANDLE.set(tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = git2.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = git2.C_INT;
        public static final MemorySegment SEGMENT = git2.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = git2.C_LONG;
        public static final MemorySegment SEGMENT = git2.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static long timegm(MemorySegment __tp) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static long timelocal(MemorySegment __tp) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dysize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("dysize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static FunctionDescriptor dysize$descriptor() {
        return dysize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MethodHandle dysize$handle() {
        return dysize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MemorySegment dysize$address() {
        return dysize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static int dysize(int __year) {
        var mh$ = dysize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dysize", __year);
            }
            return (int)mh$.invokeExact(__year);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static int nanosleep(MemorySegment __requested_time, MemorySegment __remaining) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __requested_time, __remaining);
            }
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("clock_nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static FunctionDescriptor clock_nanosleep$descriptor() {
        return clock_nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MethodHandle clock_nanosleep$handle() {
        return clock_nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MemorySegment clock_nanosleep$address() {
        return clock_nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static int clock_nanosleep(int __clock_id, int __flags, MemorySegment __req, MemorySegment __rem) {
        var mh$ = clock_nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_nanosleep", __clock_id, __flags, __req, __rem);
            }
            return (int)mh$.invokeExact(__clock_id, __flags, __req, __rem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("clock_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor clock_getcpuclockid$descriptor() {
        return clock_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MethodHandle clock_getcpuclockid$handle() {
        return clock_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MemorySegment clock_getcpuclockid$address() {
        return clock_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static int clock_getcpuclockid(int __pid, MemorySegment __clock_id) {
        var mh$ = clock_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getcpuclockid", __pid, __clock_id);
            }
            return (int)mh$.invokeExact(__pid, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static FunctionDescriptor timer_create$descriptor() {
        return timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MethodHandle timer_create$handle() {
        return timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MemorySegment timer_create$address() {
        return timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static int timer_create(int __clock_id, MemorySegment __evp, MemorySegment __timerid) {
        var mh$ = timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_create", __clock_id, __evp, __timerid);
            }
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("timer_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_delete$descriptor() {
        return timer_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_delete$handle() {
        return timer_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_delete$address() {
        return timer_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static int timer_delete(MemorySegment __timerid) {
        var mh$ = timer_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_delete", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("timer_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static FunctionDescriptor timer_settime$descriptor() {
        return timer_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MethodHandle timer_settime$handle() {
        return timer_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MemorySegment timer_settime$address() {
        return timer_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static int timer_settime(MemorySegment __timerid, int __flags, MemorySegment __value, MemorySegment __ovalue) {
        var mh$ = timer_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_settime", __timerid, __flags, __value, __ovalue);
            }
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("timer_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static FunctionDescriptor timer_gettime$descriptor() {
        return timer_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MethodHandle timer_gettime$handle() {
        return timer_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MemorySegment timer_gettime$address() {
        return timer_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static int timer_gettime(MemorySegment __timerid, MemorySegment __value) {
        var mh$ = timer_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_gettime", __timerid, __value);
            }
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_getoverrun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("timer_getoverrun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_getoverrun$descriptor() {
        return timer_getoverrun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_getoverrun$handle() {
        return timer_getoverrun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_getoverrun$address() {
        return timer_getoverrun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static int timer_getoverrun(MemorySegment __timerid) {
        var mh$ = timer_getoverrun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_getoverrun", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static int timespec_get(MemorySegment __ts, int __base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", __ts, __base);
            }
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = git2.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = git2.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = git2.C_DOUBLE;

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG    );

        public static final MemorySegment ADDR = git2.findOrThrow("__ctype_get_mb_cur_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MemorySegment __ctype_get_mb_cur_max$address() {
        return __ctype_get_mb_cur_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_DOUBLE,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_DOUBLE,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_FLOAT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = git2.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = git2.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = git2.C_INT;

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG    );

        public static final MemorySegment ADDR = git2.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("random_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MemorySegment random_r$address() {
        return random_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("srandom_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MemorySegment srandom_r$address() {
        return srandom_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("initstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment initstate_r$address() {
        return initstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("setstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment setstate_r$address() {
        return setstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT    );

        public static final MemorySegment ADDR = git2.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_DOUBLE    );

        public static final MemorySegment ADDR = git2.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_DOUBLE,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG    );

        public static final MemorySegment ADDR = git2.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG    );

        public static final MemorySegment ADDR = git2.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("drand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment drand48_r$address() {
        return drand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("erand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment erand48_r$address() {
        return erand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("lrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment lrand48_r$address() {
        return lrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("nrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment nrand48_r$address() {
        return nrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("mrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment mrand48_r$address() {
        return mrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("jrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment jrand48_r$address() {
        return jrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("srand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment srand48_r$address() {
        return srand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("seed48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment seed48_r$address() {
        return seed48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("lcong48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment lcong48_r$address() {
        return lcong48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT    );

        public static final MemorySegment ADDR = git2.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __size) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __size);
            }
            mh$.invokeExact(__buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("reallocarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray$address() {
        return reallocarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = git2.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("on_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MemorySegment on_exit$address() {
        return on_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT    );

        public static final MemorySegment ADDR = git2.findOrThrow("clearenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MemorySegment clearenv$address() {
        return clearenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("realpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG_LONG,
            git2.C_LONG_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            git2.C_INT,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            git2.C_LONG,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            git2.C_LONG_LONG,
            git2.C_LONG_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_DOUBLE,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_DOUBLE,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_DOUBLE,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_DOUBLE,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("ecvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment ecvt_r$address() {
        return ecvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_DOUBLE,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("fcvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment fcvt_r$address() {
        return fcvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = git2.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = git2.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = git2.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __gwchar_t
     * }
     */
    public static final OfInt __gwchar_t = git2.C_INT;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static long imaxabs(long __n) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", __n);
            }
            return (long)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            git2.C_LONG,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_libgit2_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_libgit2_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_libgit2_version(int *major, int *minor, int *rev)
     * }
     */
    public static FunctionDescriptor git_libgit2_version$descriptor() {
        return git_libgit2_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_libgit2_version(int *major, int *minor, int *rev)
     * }
     */
    public static MethodHandle git_libgit2_version$handle() {
        return git_libgit2_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_libgit2_version(int *major, int *minor, int *rev)
     * }
     */
    public static MemorySegment git_libgit2_version$address() {
        return git_libgit2_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_libgit2_version(int *major, int *minor, int *rev)
     * }
     */
    public static int git_libgit2_version(MemorySegment major, MemorySegment minor, MemorySegment rev) {
        var mh$ = git_libgit2_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_libgit2_version", major, minor, rev);
            }
            return (int)mh$.invokeExact(major, minor, rev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_libgit2_prerelease {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER    );

        public static final MemorySegment ADDR = git2.findOrThrow("git_libgit2_prerelease");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_libgit2_prerelease()
     * }
     */
    public static FunctionDescriptor git_libgit2_prerelease$descriptor() {
        return git_libgit2_prerelease.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_libgit2_prerelease()
     * }
     */
    public static MethodHandle git_libgit2_prerelease$handle() {
        return git_libgit2_prerelease.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_libgit2_prerelease()
     * }
     */
    public static MemorySegment git_libgit2_prerelease$address() {
        return git_libgit2_prerelease.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_libgit2_prerelease()
     * }
     */
    public static MemorySegment git_libgit2_prerelease() {
        var mh$ = git_libgit2_prerelease.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_libgit2_prerelease");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_FEATURE_THREADS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_THREADS = 1
     * }
     */
    public static int GIT_FEATURE_THREADS() {
        return GIT_FEATURE_THREADS;
    }
    private static final int GIT_FEATURE_HTTPS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_HTTPS = 2
     * }
     */
    public static int GIT_FEATURE_HTTPS() {
        return GIT_FEATURE_HTTPS;
    }
    private static final int GIT_FEATURE_SSH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_SSH = 4
     * }
     */
    public static int GIT_FEATURE_SSH() {
        return GIT_FEATURE_SSH;
    }
    private static final int GIT_FEATURE_NSEC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_NSEC = 8
     * }
     */
    public static int GIT_FEATURE_NSEC() {
        return GIT_FEATURE_NSEC;
    }
    private static final int GIT_FEATURE_HTTP_PARSER = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_HTTP_PARSER = 16
     * }
     */
    public static int GIT_FEATURE_HTTP_PARSER() {
        return GIT_FEATURE_HTTP_PARSER;
    }
    private static final int GIT_FEATURE_REGEX = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_REGEX = 32
     * }
     */
    public static int GIT_FEATURE_REGEX() {
        return GIT_FEATURE_REGEX;
    }
    private static final int GIT_FEATURE_I18N = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_I18N = 64
     * }
     */
    public static int GIT_FEATURE_I18N() {
        return GIT_FEATURE_I18N;
    }
    private static final int GIT_FEATURE_AUTH_NTLM = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_AUTH_NTLM = 128
     * }
     */
    public static int GIT_FEATURE_AUTH_NTLM() {
        return GIT_FEATURE_AUTH_NTLM;
    }
    private static final int GIT_FEATURE_AUTH_NEGOTIATE = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_AUTH_NEGOTIATE = 256
     * }
     */
    public static int GIT_FEATURE_AUTH_NEGOTIATE() {
        return GIT_FEATURE_AUTH_NEGOTIATE;
    }
    private static final int GIT_FEATURE_COMPRESSION = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_COMPRESSION = 512
     * }
     */
    public static int GIT_FEATURE_COMPRESSION() {
        return GIT_FEATURE_COMPRESSION;
    }
    private static final int GIT_FEATURE_SHA1 = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_SHA1 = 1024
     * }
     */
    public static int GIT_FEATURE_SHA1() {
        return GIT_FEATURE_SHA1;
    }
    private static final int GIT_FEATURE_SHA256 = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FEATURE_SHA256 = 2048
     * }
     */
    public static int GIT_FEATURE_SHA256() {
        return GIT_FEATURE_SHA256;
    }

    private static class git_libgit2_features {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT    );

        public static final MemorySegment ADDR = git2.findOrThrow("git_libgit2_features");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_libgit2_features()
     * }
     */
    public static FunctionDescriptor git_libgit2_features$descriptor() {
        return git_libgit2_features.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_libgit2_features()
     * }
     */
    public static MethodHandle git_libgit2_features$handle() {
        return git_libgit2_features.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_libgit2_features()
     * }
     */
    public static MemorySegment git_libgit2_features$address() {
        return git_libgit2_features.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_libgit2_features()
     * }
     */
    public static int git_libgit2_features() {
        var mh$ = git_libgit2_features.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_libgit2_features");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_libgit2_feature_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_libgit2_feature_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_libgit2_feature_backend(git_feature_t feature)
     * }
     */
    public static FunctionDescriptor git_libgit2_feature_backend$descriptor() {
        return git_libgit2_feature_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_libgit2_feature_backend(git_feature_t feature)
     * }
     */
    public static MethodHandle git_libgit2_feature_backend$handle() {
        return git_libgit2_feature_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_libgit2_feature_backend(git_feature_t feature)
     * }
     */
    public static MemorySegment git_libgit2_feature_backend$address() {
        return git_libgit2_feature_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_libgit2_feature_backend(git_feature_t feature)
     * }
     */
    public static MemorySegment git_libgit2_feature_backend(int feature) {
        var mh$ = git_libgit2_feature_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_libgit2_feature_backend", feature);
            }
            return (MemorySegment)mh$.invokeExact(feature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_OPT_GET_MWINDOW_SIZE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_MWINDOW_SIZE = 0
     * }
     */
    public static int GIT_OPT_GET_MWINDOW_SIZE() {
        return GIT_OPT_GET_MWINDOW_SIZE;
    }
    private static final int GIT_OPT_SET_MWINDOW_SIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_MWINDOW_SIZE = 1
     * }
     */
    public static int GIT_OPT_SET_MWINDOW_SIZE() {
        return GIT_OPT_SET_MWINDOW_SIZE;
    }
    private static final int GIT_OPT_GET_MWINDOW_MAPPED_LIMIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_MWINDOW_MAPPED_LIMIT = 2
     * }
     */
    public static int GIT_OPT_GET_MWINDOW_MAPPED_LIMIT() {
        return GIT_OPT_GET_MWINDOW_MAPPED_LIMIT;
    }
    private static final int GIT_OPT_SET_MWINDOW_MAPPED_LIMIT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_MWINDOW_MAPPED_LIMIT = 3
     * }
     */
    public static int GIT_OPT_SET_MWINDOW_MAPPED_LIMIT() {
        return GIT_OPT_SET_MWINDOW_MAPPED_LIMIT;
    }
    private static final int GIT_OPT_GET_SEARCH_PATH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_SEARCH_PATH = 4
     * }
     */
    public static int GIT_OPT_GET_SEARCH_PATH() {
        return GIT_OPT_GET_SEARCH_PATH;
    }
    private static final int GIT_OPT_SET_SEARCH_PATH = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_SEARCH_PATH = 5
     * }
     */
    public static int GIT_OPT_SET_SEARCH_PATH() {
        return GIT_OPT_SET_SEARCH_PATH;
    }
    private static final int GIT_OPT_SET_CACHE_OBJECT_LIMIT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_CACHE_OBJECT_LIMIT = 6
     * }
     */
    public static int GIT_OPT_SET_CACHE_OBJECT_LIMIT() {
        return GIT_OPT_SET_CACHE_OBJECT_LIMIT;
    }
    private static final int GIT_OPT_SET_CACHE_MAX_SIZE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_CACHE_MAX_SIZE = 7
     * }
     */
    public static int GIT_OPT_SET_CACHE_MAX_SIZE() {
        return GIT_OPT_SET_CACHE_MAX_SIZE;
    }
    private static final int GIT_OPT_ENABLE_CACHING = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_ENABLE_CACHING = 8
     * }
     */
    public static int GIT_OPT_ENABLE_CACHING() {
        return GIT_OPT_ENABLE_CACHING;
    }
    private static final int GIT_OPT_GET_CACHED_MEMORY = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_CACHED_MEMORY = 9
     * }
     */
    public static int GIT_OPT_GET_CACHED_MEMORY() {
        return GIT_OPT_GET_CACHED_MEMORY;
    }
    private static final int GIT_OPT_GET_TEMPLATE_PATH = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_TEMPLATE_PATH = 10
     * }
     */
    public static int GIT_OPT_GET_TEMPLATE_PATH() {
        return GIT_OPT_GET_TEMPLATE_PATH;
    }
    private static final int GIT_OPT_SET_TEMPLATE_PATH = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_TEMPLATE_PATH = 11
     * }
     */
    public static int GIT_OPT_SET_TEMPLATE_PATH() {
        return GIT_OPT_SET_TEMPLATE_PATH;
    }
    private static final int GIT_OPT_SET_SSL_CERT_LOCATIONS = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_SSL_CERT_LOCATIONS = 12
     * }
     */
    public static int GIT_OPT_SET_SSL_CERT_LOCATIONS() {
        return GIT_OPT_SET_SSL_CERT_LOCATIONS;
    }
    private static final int GIT_OPT_SET_USER_AGENT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_USER_AGENT = 13
     * }
     */
    public static int GIT_OPT_SET_USER_AGENT() {
        return GIT_OPT_SET_USER_AGENT;
    }
    private static final int GIT_OPT_ENABLE_STRICT_OBJECT_CREATION = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_ENABLE_STRICT_OBJECT_CREATION = 14
     * }
     */
    public static int GIT_OPT_ENABLE_STRICT_OBJECT_CREATION() {
        return GIT_OPT_ENABLE_STRICT_OBJECT_CREATION;
    }
    private static final int GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION = 15
     * }
     */
    public static int GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION() {
        return GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION;
    }
    private static final int GIT_OPT_SET_SSL_CIPHERS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_SSL_CIPHERS = 16
     * }
     */
    public static int GIT_OPT_SET_SSL_CIPHERS() {
        return GIT_OPT_SET_SSL_CIPHERS;
    }
    private static final int GIT_OPT_GET_USER_AGENT = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_USER_AGENT = 17
     * }
     */
    public static int GIT_OPT_GET_USER_AGENT() {
        return GIT_OPT_GET_USER_AGENT;
    }
    private static final int GIT_OPT_ENABLE_OFS_DELTA = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_ENABLE_OFS_DELTA = 18
     * }
     */
    public static int GIT_OPT_ENABLE_OFS_DELTA() {
        return GIT_OPT_ENABLE_OFS_DELTA;
    }
    private static final int GIT_OPT_ENABLE_FSYNC_GITDIR = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_ENABLE_FSYNC_GITDIR = 19
     * }
     */
    public static int GIT_OPT_ENABLE_FSYNC_GITDIR() {
        return GIT_OPT_ENABLE_FSYNC_GITDIR;
    }
    private static final int GIT_OPT_GET_WINDOWS_SHAREMODE = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_WINDOWS_SHAREMODE = 20
     * }
     */
    public static int GIT_OPT_GET_WINDOWS_SHAREMODE() {
        return GIT_OPT_GET_WINDOWS_SHAREMODE;
    }
    private static final int GIT_OPT_SET_WINDOWS_SHAREMODE = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_WINDOWS_SHAREMODE = 21
     * }
     */
    public static int GIT_OPT_SET_WINDOWS_SHAREMODE() {
        return GIT_OPT_SET_WINDOWS_SHAREMODE;
    }
    private static final int GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION = 22
     * }
     */
    public static int GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION() {
        return GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION;
    }
    private static final int GIT_OPT_SET_ALLOCATOR = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_ALLOCATOR = 23
     * }
     */
    public static int GIT_OPT_SET_ALLOCATOR() {
        return GIT_OPT_SET_ALLOCATOR;
    }
    private static final int GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY = 24
     * }
     */
    public static int GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY() {
        return GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY;
    }
    private static final int GIT_OPT_GET_PACK_MAX_OBJECTS = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_PACK_MAX_OBJECTS = 25
     * }
     */
    public static int GIT_OPT_GET_PACK_MAX_OBJECTS() {
        return GIT_OPT_GET_PACK_MAX_OBJECTS;
    }
    private static final int GIT_OPT_SET_PACK_MAX_OBJECTS = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_PACK_MAX_OBJECTS = 26
     * }
     */
    public static int GIT_OPT_SET_PACK_MAX_OBJECTS() {
        return GIT_OPT_SET_PACK_MAX_OBJECTS;
    }
    private static final int GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS = 27
     * }
     */
    public static int GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS() {
        return GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS;
    }
    private static final int GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE = 28
     * }
     */
    public static int GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE() {
        return GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE;
    }
    private static final int GIT_OPT_GET_MWINDOW_FILE_LIMIT = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_MWINDOW_FILE_LIMIT = 29
     * }
     */
    public static int GIT_OPT_GET_MWINDOW_FILE_LIMIT() {
        return GIT_OPT_GET_MWINDOW_FILE_LIMIT;
    }
    private static final int GIT_OPT_SET_MWINDOW_FILE_LIMIT = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_MWINDOW_FILE_LIMIT = 30
     * }
     */
    public static int GIT_OPT_SET_MWINDOW_FILE_LIMIT() {
        return GIT_OPT_SET_MWINDOW_FILE_LIMIT;
    }
    private static final int GIT_OPT_SET_ODB_PACKED_PRIORITY = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_ODB_PACKED_PRIORITY = 31
     * }
     */
    public static int GIT_OPT_SET_ODB_PACKED_PRIORITY() {
        return GIT_OPT_SET_ODB_PACKED_PRIORITY;
    }
    private static final int GIT_OPT_SET_ODB_LOOSE_PRIORITY = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_ODB_LOOSE_PRIORITY = 32
     * }
     */
    public static int GIT_OPT_SET_ODB_LOOSE_PRIORITY() {
        return GIT_OPT_SET_ODB_LOOSE_PRIORITY;
    }
    private static final int GIT_OPT_GET_EXTENSIONS = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_EXTENSIONS = 33
     * }
     */
    public static int GIT_OPT_GET_EXTENSIONS() {
        return GIT_OPT_GET_EXTENSIONS;
    }
    private static final int GIT_OPT_SET_EXTENSIONS = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_EXTENSIONS = 34
     * }
     */
    public static int GIT_OPT_SET_EXTENSIONS() {
        return GIT_OPT_SET_EXTENSIONS;
    }
    private static final int GIT_OPT_GET_OWNER_VALIDATION = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_OWNER_VALIDATION = 35
     * }
     */
    public static int GIT_OPT_GET_OWNER_VALIDATION() {
        return GIT_OPT_GET_OWNER_VALIDATION;
    }
    private static final int GIT_OPT_SET_OWNER_VALIDATION = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_OWNER_VALIDATION = 36
     * }
     */
    public static int GIT_OPT_SET_OWNER_VALIDATION() {
        return GIT_OPT_SET_OWNER_VALIDATION;
    }
    private static final int GIT_OPT_GET_HOMEDIR = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_HOMEDIR = 37
     * }
     */
    public static int GIT_OPT_GET_HOMEDIR() {
        return GIT_OPT_GET_HOMEDIR;
    }
    private static final int GIT_OPT_SET_HOMEDIR = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_HOMEDIR = 38
     * }
     */
    public static int GIT_OPT_SET_HOMEDIR() {
        return GIT_OPT_SET_HOMEDIR;
    }
    private static final int GIT_OPT_SET_SERVER_CONNECT_TIMEOUT = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_SERVER_CONNECT_TIMEOUT = 39
     * }
     */
    public static int GIT_OPT_SET_SERVER_CONNECT_TIMEOUT() {
        return GIT_OPT_SET_SERVER_CONNECT_TIMEOUT;
    }
    private static final int GIT_OPT_GET_SERVER_CONNECT_TIMEOUT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_SERVER_CONNECT_TIMEOUT = 40
     * }
     */
    public static int GIT_OPT_GET_SERVER_CONNECT_TIMEOUT() {
        return GIT_OPT_GET_SERVER_CONNECT_TIMEOUT;
    }
    private static final int GIT_OPT_SET_SERVER_TIMEOUT = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_SERVER_TIMEOUT = 41
     * }
     */
    public static int GIT_OPT_SET_SERVER_TIMEOUT() {
        return GIT_OPT_SET_SERVER_TIMEOUT;
    }
    private static final int GIT_OPT_GET_SERVER_TIMEOUT = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_SERVER_TIMEOUT = 42
     * }
     */
    public static int GIT_OPT_GET_SERVER_TIMEOUT() {
        return GIT_OPT_GET_SERVER_TIMEOUT;
    }
    private static final int GIT_OPT_SET_USER_AGENT_PRODUCT = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_SET_USER_AGENT_PRODUCT = 43
     * }
     */
    public static int GIT_OPT_SET_USER_AGENT_PRODUCT() {
        return GIT_OPT_SET_USER_AGENT_PRODUCT;
    }
    private static final int GIT_OPT_GET_USER_AGENT_PRODUCT = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_GET_USER_AGENT_PRODUCT = 44
     * }
     */
    public static int GIT_OPT_GET_USER_AGENT_PRODUCT() {
        return GIT_OPT_GET_USER_AGENT_PRODUCT;
    }
    private static final int GIT_OPT_ADD_SSL_X509_CERT = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OPT_ADD_SSL_X509_CERT = 45
     * }
     */
    public static int GIT_OPT_ADD_SSL_X509_CERT() {
        return GIT_OPT_ADD_SSL_X509_CERT;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int git_libgit2_opts(int option, ...)
     * }
     */
    public static class git_libgit2_opts {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                git2.C_INT,
                git2.C_INT
            );
        private static final MemorySegment ADDR = git2.findOrThrow("git_libgit2_opts");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private git_libgit2_opts(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int git_libgit2_opts(int option, ...)
         * }
         */
        public static git_libgit2_opts makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new git_libgit2_opts(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int option, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("git_libgit2_opts", option, x1);
                }
                return (int) spreader.invokeExact(option, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int64_t git_off_t
     * }
     */
    public static final OfLong git_off_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t git_time_t
     * }
     */
    public static final OfLong git_time_t = git2.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t git_object_size_t
     * }
     */
    public static final OfLong git_object_size_t = git2.C_LONG;

    private static class git_buf_dispose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_buf_dispose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_buf_dispose(git_buf *buffer)
     * }
     */
    public static FunctionDescriptor git_buf_dispose$descriptor() {
        return git_buf_dispose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_buf_dispose(git_buf *buffer)
     * }
     */
    public static MethodHandle git_buf_dispose$handle() {
        return git_buf_dispose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_buf_dispose(git_buf *buffer)
     * }
     */
    public static MemorySegment git_buf_dispose$address() {
        return git_buf_dispose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_buf_dispose(git_buf *buffer)
     * }
     */
    public static void git_buf_dispose(MemorySegment buffer) {
        var mh$ = git_buf_dispose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_buf_dispose", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_OID_SHA1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OID_SHA1 = 1
     * }
     */
    public static int GIT_OID_SHA1() {
        return GIT_OID_SHA1;
    }

    private static class git_oid_fromstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_fromstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_fromstr(git_oid *out, const char *str)
     * }
     */
    public static FunctionDescriptor git_oid_fromstr$descriptor() {
        return git_oid_fromstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_fromstr(git_oid *out, const char *str)
     * }
     */
    public static MethodHandle git_oid_fromstr$handle() {
        return git_oid_fromstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_fromstr(git_oid *out, const char *str)
     * }
     */
    public static MemorySegment git_oid_fromstr$address() {
        return git_oid_fromstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_fromstr(git_oid *out, const char *str)
     * }
     */
    public static int git_oid_fromstr(MemorySegment out, MemorySegment str) {
        var mh$ = git_oid_fromstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_fromstr", out, str);
            }
            return (int)mh$.invokeExact(out, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_fromstrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_fromstrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_fromstrp(git_oid *out, const char *str)
     * }
     */
    public static FunctionDescriptor git_oid_fromstrp$descriptor() {
        return git_oid_fromstrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_fromstrp(git_oid *out, const char *str)
     * }
     */
    public static MethodHandle git_oid_fromstrp$handle() {
        return git_oid_fromstrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_fromstrp(git_oid *out, const char *str)
     * }
     */
    public static MemorySegment git_oid_fromstrp$address() {
        return git_oid_fromstrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_fromstrp(git_oid *out, const char *str)
     * }
     */
    public static int git_oid_fromstrp(MemorySegment out, MemorySegment str) {
        var mh$ = git_oid_fromstrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_fromstrp", out, str);
            }
            return (int)mh$.invokeExact(out, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_fromstrn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_fromstrn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_fromstrn(git_oid *out, const char *str, size_t length)
     * }
     */
    public static FunctionDescriptor git_oid_fromstrn$descriptor() {
        return git_oid_fromstrn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_fromstrn(git_oid *out, const char *str, size_t length)
     * }
     */
    public static MethodHandle git_oid_fromstrn$handle() {
        return git_oid_fromstrn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_fromstrn(git_oid *out, const char *str, size_t length)
     * }
     */
    public static MemorySegment git_oid_fromstrn$address() {
        return git_oid_fromstrn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_fromstrn(git_oid *out, const char *str, size_t length)
     * }
     */
    public static int git_oid_fromstrn(MemorySegment out, MemorySegment str, long length) {
        var mh$ = git_oid_fromstrn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_fromstrn", out, str, length);
            }
            return (int)mh$.invokeExact(out, str, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_fromraw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_fromraw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_fromraw(git_oid *out, const unsigned char *raw)
     * }
     */
    public static FunctionDescriptor git_oid_fromraw$descriptor() {
        return git_oid_fromraw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_fromraw(git_oid *out, const unsigned char *raw)
     * }
     */
    public static MethodHandle git_oid_fromraw$handle() {
        return git_oid_fromraw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_fromraw(git_oid *out, const unsigned char *raw)
     * }
     */
    public static MemorySegment git_oid_fromraw$address() {
        return git_oid_fromraw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_fromraw(git_oid *out, const unsigned char *raw)
     * }
     */
    public static int git_oid_fromraw(MemorySegment out, MemorySegment raw) {
        var mh$ = git_oid_fromraw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_fromraw", out, raw);
            }
            return (int)mh$.invokeExact(out, raw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_fmt(char *out, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_oid_fmt$descriptor() {
        return git_oid_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_fmt(char *out, const git_oid *id)
     * }
     */
    public static MethodHandle git_oid_fmt$handle() {
        return git_oid_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_fmt(char *out, const git_oid *id)
     * }
     */
    public static MemorySegment git_oid_fmt$address() {
        return git_oid_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_fmt(char *out, const git_oid *id)
     * }
     */
    public static int git_oid_fmt(MemorySegment out, MemorySegment id) {
        var mh$ = git_oid_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_fmt", out, id);
            }
            return (int)mh$.invokeExact(out, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_nfmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_nfmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_nfmt(char *out, size_t n, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_oid_nfmt$descriptor() {
        return git_oid_nfmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_nfmt(char *out, size_t n, const git_oid *id)
     * }
     */
    public static MethodHandle git_oid_nfmt$handle() {
        return git_oid_nfmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_nfmt(char *out, size_t n, const git_oid *id)
     * }
     */
    public static MemorySegment git_oid_nfmt$address() {
        return git_oid_nfmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_nfmt(char *out, size_t n, const git_oid *id)
     * }
     */
    public static int git_oid_nfmt(MemorySegment out, long n, MemorySegment id) {
        var mh$ = git_oid_nfmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_nfmt", out, n, id);
            }
            return (int)mh$.invokeExact(out, n, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_pathfmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_pathfmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_pathfmt(char *out, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_oid_pathfmt$descriptor() {
        return git_oid_pathfmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_pathfmt(char *out, const git_oid *id)
     * }
     */
    public static MethodHandle git_oid_pathfmt$handle() {
        return git_oid_pathfmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_pathfmt(char *out, const git_oid *id)
     * }
     */
    public static MemorySegment git_oid_pathfmt$address() {
        return git_oid_pathfmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_pathfmt(char *out, const git_oid *id)
     * }
     */
    public static int git_oid_pathfmt(MemorySegment out, MemorySegment id) {
        var mh$ = git_oid_pathfmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_pathfmt", out, id);
            }
            return (int)mh$.invokeExact(out, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_tostr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_tostr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *git_oid_tostr_s(const git_oid *oid)
     * }
     */
    public static FunctionDescriptor git_oid_tostr_s$descriptor() {
        return git_oid_tostr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *git_oid_tostr_s(const git_oid *oid)
     * }
     */
    public static MethodHandle git_oid_tostr_s$handle() {
        return git_oid_tostr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *git_oid_tostr_s(const git_oid *oid)
     * }
     */
    public static MemorySegment git_oid_tostr_s$address() {
        return git_oid_tostr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *git_oid_tostr_s(const git_oid *oid)
     * }
     */
    public static MemorySegment git_oid_tostr_s(MemorySegment oid) {
        var mh$ = git_oid_tostr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_tostr_s", oid);
            }
            return (MemorySegment)mh$.invokeExact(oid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_tostr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_tostr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *git_oid_tostr(char *out, size_t n, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_oid_tostr$descriptor() {
        return git_oid_tostr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *git_oid_tostr(char *out, size_t n, const git_oid *id)
     * }
     */
    public static MethodHandle git_oid_tostr$handle() {
        return git_oid_tostr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *git_oid_tostr(char *out, size_t n, const git_oid *id)
     * }
     */
    public static MemorySegment git_oid_tostr$address() {
        return git_oid_tostr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *git_oid_tostr(char *out, size_t n, const git_oid *id)
     * }
     */
    public static MemorySegment git_oid_tostr(MemorySegment out, long n, MemorySegment id) {
        var mh$ = git_oid_tostr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_tostr", out, n, id);
            }
            return (MemorySegment)mh$.invokeExact(out, n, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_cpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_cpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_cpy(git_oid *out, const git_oid *src)
     * }
     */
    public static FunctionDescriptor git_oid_cpy$descriptor() {
        return git_oid_cpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_cpy(git_oid *out, const git_oid *src)
     * }
     */
    public static MethodHandle git_oid_cpy$handle() {
        return git_oid_cpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_cpy(git_oid *out, const git_oid *src)
     * }
     */
    public static MemorySegment git_oid_cpy$address() {
        return git_oid_cpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_cpy(git_oid *out, const git_oid *src)
     * }
     */
    public static int git_oid_cpy(MemorySegment out, MemorySegment src) {
        var mh$ = git_oid_cpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_cpy", out, src);
            }
            return (int)mh$.invokeExact(out, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_cmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_cmp(const git_oid *a, const git_oid *b)
     * }
     */
    public static FunctionDescriptor git_oid_cmp$descriptor() {
        return git_oid_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_cmp(const git_oid *a, const git_oid *b)
     * }
     */
    public static MethodHandle git_oid_cmp$handle() {
        return git_oid_cmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_cmp(const git_oid *a, const git_oid *b)
     * }
     */
    public static MemorySegment git_oid_cmp$address() {
        return git_oid_cmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_cmp(const git_oid *a, const git_oid *b)
     * }
     */
    public static int git_oid_cmp(MemorySegment a, MemorySegment b) {
        var mh$ = git_oid_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_cmp", a, b);
            }
            return (int)mh$.invokeExact(a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_equal(const git_oid *a, const git_oid *b)
     * }
     */
    public static FunctionDescriptor git_oid_equal$descriptor() {
        return git_oid_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_equal(const git_oid *a, const git_oid *b)
     * }
     */
    public static MethodHandle git_oid_equal$handle() {
        return git_oid_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_equal(const git_oid *a, const git_oid *b)
     * }
     */
    public static MemorySegment git_oid_equal$address() {
        return git_oid_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_equal(const git_oid *a, const git_oid *b)
     * }
     */
    public static int git_oid_equal(MemorySegment a, MemorySegment b) {
        var mh$ = git_oid_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_equal", a, b);
            }
            return (int)mh$.invokeExact(a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_ncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_ncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_ncmp(const git_oid *a, const git_oid *b, size_t len)
     * }
     */
    public static FunctionDescriptor git_oid_ncmp$descriptor() {
        return git_oid_ncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_ncmp(const git_oid *a, const git_oid *b, size_t len)
     * }
     */
    public static MethodHandle git_oid_ncmp$handle() {
        return git_oid_ncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_ncmp(const git_oid *a, const git_oid *b, size_t len)
     * }
     */
    public static MemorySegment git_oid_ncmp$address() {
        return git_oid_ncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_ncmp(const git_oid *a, const git_oid *b, size_t len)
     * }
     */
    public static int git_oid_ncmp(MemorySegment a, MemorySegment b, long len) {
        var mh$ = git_oid_ncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_ncmp", a, b, len);
            }
            return (int)mh$.invokeExact(a, b, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_streq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_streq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_streq(const git_oid *id, const char *str)
     * }
     */
    public static FunctionDescriptor git_oid_streq$descriptor() {
        return git_oid_streq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_streq(const git_oid *id, const char *str)
     * }
     */
    public static MethodHandle git_oid_streq$handle() {
        return git_oid_streq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_streq(const git_oid *id, const char *str)
     * }
     */
    public static MemorySegment git_oid_streq$address() {
        return git_oid_streq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_streq(const git_oid *id, const char *str)
     * }
     */
    public static int git_oid_streq(MemorySegment id, MemorySegment str) {
        var mh$ = git_oid_streq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_streq", id, str);
            }
            return (int)mh$.invokeExact(id, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_strcmp(const git_oid *id, const char *str)
     * }
     */
    public static FunctionDescriptor git_oid_strcmp$descriptor() {
        return git_oid_strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_strcmp(const git_oid *id, const char *str)
     * }
     */
    public static MethodHandle git_oid_strcmp$handle() {
        return git_oid_strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_strcmp(const git_oid *id, const char *str)
     * }
     */
    public static MemorySegment git_oid_strcmp$address() {
        return git_oid_strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_strcmp(const git_oid *id, const char *str)
     * }
     */
    public static int git_oid_strcmp(MemorySegment id, MemorySegment str) {
        var mh$ = git_oid_strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_strcmp", id, str);
            }
            return (int)mh$.invokeExact(id, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_is_zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_is_zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_is_zero(const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_oid_is_zero$descriptor() {
        return git_oid_is_zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_is_zero(const git_oid *id)
     * }
     */
    public static MethodHandle git_oid_is_zero$handle() {
        return git_oid_is_zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_is_zero(const git_oid *id)
     * }
     */
    public static MemorySegment git_oid_is_zero$address() {
        return git_oid_is_zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_is_zero(const git_oid *id)
     * }
     */
    public static int git_oid_is_zero(MemorySegment id) {
        var mh$ = git_oid_is_zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_is_zero", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_shorten_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_shorten_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_oid_shorten *git_oid_shorten_new(size_t min_length)
     * }
     */
    public static FunctionDescriptor git_oid_shorten_new$descriptor() {
        return git_oid_shorten_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_oid_shorten *git_oid_shorten_new(size_t min_length)
     * }
     */
    public static MethodHandle git_oid_shorten_new$handle() {
        return git_oid_shorten_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_oid_shorten *git_oid_shorten_new(size_t min_length)
     * }
     */
    public static MemorySegment git_oid_shorten_new$address() {
        return git_oid_shorten_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_oid_shorten *git_oid_shorten_new(size_t min_length)
     * }
     */
    public static MemorySegment git_oid_shorten_new(long min_length) {
        var mh$ = git_oid_shorten_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_shorten_new", min_length);
            }
            return (MemorySegment)mh$.invokeExact(min_length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_shorten_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_shorten_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_shorten_add(git_oid_shorten *os, const char *text_id)
     * }
     */
    public static FunctionDescriptor git_oid_shorten_add$descriptor() {
        return git_oid_shorten_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_shorten_add(git_oid_shorten *os, const char *text_id)
     * }
     */
    public static MethodHandle git_oid_shorten_add$handle() {
        return git_oid_shorten_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_shorten_add(git_oid_shorten *os, const char *text_id)
     * }
     */
    public static MemorySegment git_oid_shorten_add$address() {
        return git_oid_shorten_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_shorten_add(git_oid_shorten *os, const char *text_id)
     * }
     */
    public static int git_oid_shorten_add(MemorySegment os, MemorySegment text_id) {
        var mh$ = git_oid_shorten_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_shorten_add", os, text_id);
            }
            return (int)mh$.invokeExact(os, text_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_shorten_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_shorten_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_oid_shorten_free(git_oid_shorten *os)
     * }
     */
    public static FunctionDescriptor git_oid_shorten_free$descriptor() {
        return git_oid_shorten_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_oid_shorten_free(git_oid_shorten *os)
     * }
     */
    public static MethodHandle git_oid_shorten_free$handle() {
        return git_oid_shorten_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_oid_shorten_free(git_oid_shorten *os)
     * }
     */
    public static MemorySegment git_oid_shorten_free$address() {
        return git_oid_shorten_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_oid_shorten_free(git_oid_shorten *os)
     * }
     */
    public static void git_oid_shorten_free(MemorySegment os) {
        var mh$ = git_oid_shorten_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_shorten_free", os);
            }
            mh$.invokeExact(os);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_OBJECT_ANY = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OBJECT_ANY = -2
     * }
     */
    public static int GIT_OBJECT_ANY() {
        return GIT_OBJECT_ANY;
    }
    private static final int GIT_OBJECT_INVALID = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OBJECT_INVALID = -1
     * }
     */
    public static int GIT_OBJECT_INVALID() {
        return GIT_OBJECT_INVALID;
    }
    private static final int GIT_OBJECT_COMMIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OBJECT_COMMIT = 1
     * }
     */
    public static int GIT_OBJECT_COMMIT() {
        return GIT_OBJECT_COMMIT;
    }
    private static final int GIT_OBJECT_TREE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OBJECT_TREE = 2
     * }
     */
    public static int GIT_OBJECT_TREE() {
        return GIT_OBJECT_TREE;
    }
    private static final int GIT_OBJECT_BLOB = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OBJECT_BLOB = 3
     * }
     */
    public static int GIT_OBJECT_BLOB() {
        return GIT_OBJECT_BLOB;
    }
    private static final int GIT_OBJECT_TAG = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OBJECT_TAG = 4
     * }
     */
    public static int GIT_OBJECT_TAG() {
        return GIT_OBJECT_TAG;
    }
    private static final int GIT_OBJECT_OFS_DELTA = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OBJECT_OFS_DELTA = 6
     * }
     */
    public static int GIT_OBJECT_OFS_DELTA() {
        return GIT_OBJECT_OFS_DELTA;
    }
    private static final int GIT_OBJECT_REF_DELTA = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OBJECT_REF_DELTA = 7
     * }
     */
    public static int GIT_OBJECT_REF_DELTA() {
        return GIT_OBJECT_REF_DELTA;
    }
    private static final int GIT_REFERENCE_INVALID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REFERENCE_INVALID = 0
     * }
     */
    public static int GIT_REFERENCE_INVALID() {
        return GIT_REFERENCE_INVALID;
    }
    private static final int GIT_REFERENCE_DIRECT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REFERENCE_DIRECT = 1
     * }
     */
    public static int GIT_REFERENCE_DIRECT() {
        return GIT_REFERENCE_DIRECT;
    }
    private static final int GIT_REFERENCE_SYMBOLIC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REFERENCE_SYMBOLIC = 2
     * }
     */
    public static int GIT_REFERENCE_SYMBOLIC() {
        return GIT_REFERENCE_SYMBOLIC;
    }
    private static final int GIT_REFERENCE_ALL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REFERENCE_ALL = 3
     * }
     */
    public static int GIT_REFERENCE_ALL() {
        return GIT_REFERENCE_ALL;
    }
    private static final int GIT_BRANCH_LOCAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BRANCH_LOCAL = 1
     * }
     */
    public static int GIT_BRANCH_LOCAL() {
        return GIT_BRANCH_LOCAL;
    }
    private static final int GIT_BRANCH_REMOTE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BRANCH_REMOTE = 2
     * }
     */
    public static int GIT_BRANCH_REMOTE() {
        return GIT_BRANCH_REMOTE;
    }
    private static final int GIT_BRANCH_ALL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BRANCH_ALL = 3
     * }
     */
    public static int GIT_BRANCH_ALL() {
        return GIT_BRANCH_ALL;
    }
    private static final int GIT_FILEMODE_UNREADABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILEMODE_UNREADABLE = 0
     * }
     */
    public static int GIT_FILEMODE_UNREADABLE() {
        return GIT_FILEMODE_UNREADABLE;
    }
    private static final int GIT_FILEMODE_TREE = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILEMODE_TREE = 16384
     * }
     */
    public static int GIT_FILEMODE_TREE() {
        return GIT_FILEMODE_TREE;
    }
    private static final int GIT_FILEMODE_BLOB = (int)33188L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILEMODE_BLOB = 33188
     * }
     */
    public static int GIT_FILEMODE_BLOB() {
        return GIT_FILEMODE_BLOB;
    }
    private static final int GIT_FILEMODE_BLOB_EXECUTABLE = (int)33261L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILEMODE_BLOB_EXECUTABLE = 33261
     * }
     */
    public static int GIT_FILEMODE_BLOB_EXECUTABLE() {
        return GIT_FILEMODE_BLOB_EXECUTABLE;
    }
    private static final int GIT_FILEMODE_LINK = (int)40960L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILEMODE_LINK = 40960
     * }
     */
    public static int GIT_FILEMODE_LINK() {
        return GIT_FILEMODE_LINK;
    }
    private static final int GIT_FILEMODE_COMMIT = (int)57344L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILEMODE_COMMIT = 57344
     * }
     */
    public static int GIT_FILEMODE_COMMIT() {
        return GIT_FILEMODE_COMMIT;
    }
    private static final int GIT_SUBMODULE_UPDATE_CHECKOUT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_UPDATE_CHECKOUT = 1
     * }
     */
    public static int GIT_SUBMODULE_UPDATE_CHECKOUT() {
        return GIT_SUBMODULE_UPDATE_CHECKOUT;
    }
    private static final int GIT_SUBMODULE_UPDATE_REBASE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_UPDATE_REBASE = 2
     * }
     */
    public static int GIT_SUBMODULE_UPDATE_REBASE() {
        return GIT_SUBMODULE_UPDATE_REBASE;
    }
    private static final int GIT_SUBMODULE_UPDATE_MERGE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_UPDATE_MERGE = 3
     * }
     */
    public static int GIT_SUBMODULE_UPDATE_MERGE() {
        return GIT_SUBMODULE_UPDATE_MERGE;
    }
    private static final int GIT_SUBMODULE_UPDATE_NONE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_UPDATE_NONE = 4
     * }
     */
    public static int GIT_SUBMODULE_UPDATE_NONE() {
        return GIT_SUBMODULE_UPDATE_NONE;
    }
    private static final int GIT_SUBMODULE_UPDATE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_UPDATE_DEFAULT = 0
     * }
     */
    public static int GIT_SUBMODULE_UPDATE_DEFAULT() {
        return GIT_SUBMODULE_UPDATE_DEFAULT;
    }
    private static final int GIT_SUBMODULE_IGNORE_UNSPECIFIED = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_IGNORE_UNSPECIFIED = -1
     * }
     */
    public static int GIT_SUBMODULE_IGNORE_UNSPECIFIED() {
        return GIT_SUBMODULE_IGNORE_UNSPECIFIED;
    }
    private static final int GIT_SUBMODULE_IGNORE_NONE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_IGNORE_NONE = 1
     * }
     */
    public static int GIT_SUBMODULE_IGNORE_NONE() {
        return GIT_SUBMODULE_IGNORE_NONE;
    }
    private static final int GIT_SUBMODULE_IGNORE_UNTRACKED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_IGNORE_UNTRACKED = 2
     * }
     */
    public static int GIT_SUBMODULE_IGNORE_UNTRACKED() {
        return GIT_SUBMODULE_IGNORE_UNTRACKED;
    }
    private static final int GIT_SUBMODULE_IGNORE_DIRTY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_IGNORE_DIRTY = 3
     * }
     */
    public static int GIT_SUBMODULE_IGNORE_DIRTY() {
        return GIT_SUBMODULE_IGNORE_DIRTY;
    }
    private static final int GIT_SUBMODULE_IGNORE_ALL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_IGNORE_ALL = 4
     * }
     */
    public static int GIT_SUBMODULE_IGNORE_ALL() {
        return GIT_SUBMODULE_IGNORE_ALL;
    }
    private static final int GIT_SUBMODULE_RECURSE_NO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_RECURSE_NO = 0
     * }
     */
    public static int GIT_SUBMODULE_RECURSE_NO() {
        return GIT_SUBMODULE_RECURSE_NO;
    }
    private static final int GIT_SUBMODULE_RECURSE_YES = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_RECURSE_YES = 1
     * }
     */
    public static int GIT_SUBMODULE_RECURSE_YES() {
        return GIT_SUBMODULE_RECURSE_YES;
    }
    private static final int GIT_SUBMODULE_RECURSE_ONDEMAND = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_RECURSE_ONDEMAND = 2
     * }
     */
    public static int GIT_SUBMODULE_RECURSE_ONDEMAND() {
        return GIT_SUBMODULE_RECURSE_ONDEMAND;
    }

    private static class git_oidarray_dispose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oidarray_dispose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_oidarray_dispose(git_oidarray *array)
     * }
     */
    public static FunctionDescriptor git_oidarray_dispose$descriptor() {
        return git_oidarray_dispose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_oidarray_dispose(git_oidarray *array)
     * }
     */
    public static MethodHandle git_oidarray_dispose$handle() {
        return git_oidarray_dispose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_oidarray_dispose(git_oidarray *array)
     * }
     */
    public static MemorySegment git_oidarray_dispose$address() {
        return git_oidarray_dispose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_oidarray_dispose(git_oidarray *array)
     * }
     */
    public static void git_oidarray_dispose(MemorySegment array) {
        var mh$ = git_oidarray_dispose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oidarray_dispose", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_indexer_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_indexer_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_indexer_options_init(git_indexer_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_indexer_options_init$descriptor() {
        return git_indexer_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_indexer_options_init(git_indexer_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_indexer_options_init$handle() {
        return git_indexer_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_indexer_options_init(git_indexer_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_indexer_options_init$address() {
        return git_indexer_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_indexer_options_init(git_indexer_options *opts, unsigned int version)
     * }
     */
    public static int git_indexer_options_init(MemorySegment opts, int version) {
        var mh$ = git_indexer_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_indexer_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_indexer_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_indexer_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_indexer_new(git_indexer **out, const char *path, unsigned int mode, git_odb *odb, git_indexer_options *opts)
     * }
     */
    public static FunctionDescriptor git_indexer_new$descriptor() {
        return git_indexer_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_indexer_new(git_indexer **out, const char *path, unsigned int mode, git_odb *odb, git_indexer_options *opts)
     * }
     */
    public static MethodHandle git_indexer_new$handle() {
        return git_indexer_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_indexer_new(git_indexer **out, const char *path, unsigned int mode, git_odb *odb, git_indexer_options *opts)
     * }
     */
    public static MemorySegment git_indexer_new$address() {
        return git_indexer_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_indexer_new(git_indexer **out, const char *path, unsigned int mode, git_odb *odb, git_indexer_options *opts)
     * }
     */
    public static int git_indexer_new(MemorySegment out, MemorySegment path, int mode, MemorySegment odb, MemorySegment opts) {
        var mh$ = git_indexer_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_indexer_new", out, path, mode, odb, opts);
            }
            return (int)mh$.invokeExact(out, path, mode, odb, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_indexer_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_indexer_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_indexer_append(git_indexer *idx, const void *data, size_t size, git_indexer_progress *stats)
     * }
     */
    public static FunctionDescriptor git_indexer_append$descriptor() {
        return git_indexer_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_indexer_append(git_indexer *idx, const void *data, size_t size, git_indexer_progress *stats)
     * }
     */
    public static MethodHandle git_indexer_append$handle() {
        return git_indexer_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_indexer_append(git_indexer *idx, const void *data, size_t size, git_indexer_progress *stats)
     * }
     */
    public static MemorySegment git_indexer_append$address() {
        return git_indexer_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_indexer_append(git_indexer *idx, const void *data, size_t size, git_indexer_progress *stats)
     * }
     */
    public static int git_indexer_append(MemorySegment idx, MemorySegment data, long size, MemorySegment stats) {
        var mh$ = git_indexer_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_indexer_append", idx, data, size, stats);
            }
            return (int)mh$.invokeExact(idx, data, size, stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_indexer_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_indexer_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_indexer_commit(git_indexer *idx, git_indexer_progress *stats)
     * }
     */
    public static FunctionDescriptor git_indexer_commit$descriptor() {
        return git_indexer_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_indexer_commit(git_indexer *idx, git_indexer_progress *stats)
     * }
     */
    public static MethodHandle git_indexer_commit$handle() {
        return git_indexer_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_indexer_commit(git_indexer *idx, git_indexer_progress *stats)
     * }
     */
    public static MemorySegment git_indexer_commit$address() {
        return git_indexer_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_indexer_commit(git_indexer *idx, git_indexer_progress *stats)
     * }
     */
    public static int git_indexer_commit(MemorySegment idx, MemorySegment stats) {
        var mh$ = git_indexer_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_indexer_commit", idx, stats);
            }
            return (int)mh$.invokeExact(idx, stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_indexer_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_indexer_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_indexer_hash(const git_indexer *idx)
     * }
     */
    public static FunctionDescriptor git_indexer_hash$descriptor() {
        return git_indexer_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_indexer_hash(const git_indexer *idx)
     * }
     */
    public static MethodHandle git_indexer_hash$handle() {
        return git_indexer_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_indexer_hash(const git_indexer *idx)
     * }
     */
    public static MemorySegment git_indexer_hash$address() {
        return git_indexer_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_indexer_hash(const git_indexer *idx)
     * }
     */
    public static MemorySegment git_indexer_hash(MemorySegment idx) {
        var mh$ = git_indexer_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_indexer_hash", idx);
            }
            return (MemorySegment)mh$.invokeExact(idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_indexer_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_indexer_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_indexer_name(const git_indexer *idx)
     * }
     */
    public static FunctionDescriptor git_indexer_name$descriptor() {
        return git_indexer_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_indexer_name(const git_indexer *idx)
     * }
     */
    public static MethodHandle git_indexer_name$handle() {
        return git_indexer_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_indexer_name(const git_indexer *idx)
     * }
     */
    public static MemorySegment git_indexer_name$address() {
        return git_indexer_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_indexer_name(const git_indexer *idx)
     * }
     */
    public static MemorySegment git_indexer_name(MemorySegment idx) {
        var mh$ = git_indexer_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_indexer_name", idx);
            }
            return (MemorySegment)mh$.invokeExact(idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_indexer_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_indexer_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_indexer_free(git_indexer *idx)
     * }
     */
    public static FunctionDescriptor git_indexer_free$descriptor() {
        return git_indexer_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_indexer_free(git_indexer *idx)
     * }
     */
    public static MethodHandle git_indexer_free$handle() {
        return git_indexer_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_indexer_free(git_indexer *idx)
     * }
     */
    public static MemorySegment git_indexer_free$address() {
        return git_indexer_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_indexer_free(git_indexer *idx)
     * }
     */
    public static void git_indexer_free(MemorySegment idx) {
        var mh$ = git_indexer_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_indexer_free", idx);
            }
            mh$.invokeExact(idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_ODB_LOOKUP_NO_REFRESH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ODB_LOOKUP_NO_REFRESH = 1
     * }
     */
    public static int GIT_ODB_LOOKUP_NO_REFRESH() {
        return GIT_ODB_LOOKUP_NO_REFRESH;
    }

    private static class git_odb_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_new(git_odb **odb)
     * }
     */
    public static FunctionDescriptor git_odb_new$descriptor() {
        return git_odb_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_new(git_odb **odb)
     * }
     */
    public static MethodHandle git_odb_new$handle() {
        return git_odb_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_new(git_odb **odb)
     * }
     */
    public static MemorySegment git_odb_new$address() {
        return git_odb_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_new(git_odb **odb)
     * }
     */
    public static int git_odb_new(MemorySegment odb) {
        var mh$ = git_odb_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_new", odb);
            }
            return (int)mh$.invokeExact(odb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_open(git_odb **odb_out, const char *objects_dir)
     * }
     */
    public static FunctionDescriptor git_odb_open$descriptor() {
        return git_odb_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_open(git_odb **odb_out, const char *objects_dir)
     * }
     */
    public static MethodHandle git_odb_open$handle() {
        return git_odb_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_open(git_odb **odb_out, const char *objects_dir)
     * }
     */
    public static MemorySegment git_odb_open$address() {
        return git_odb_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_open(git_odb **odb_out, const char *objects_dir)
     * }
     */
    public static int git_odb_open(MemorySegment odb_out, MemorySegment objects_dir) {
        var mh$ = git_odb_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_open", odb_out, objects_dir);
            }
            return (int)mh$.invokeExact(odb_out, objects_dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_add_disk_alternate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_add_disk_alternate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_add_disk_alternate(git_odb *odb, const char *path)
     * }
     */
    public static FunctionDescriptor git_odb_add_disk_alternate$descriptor() {
        return git_odb_add_disk_alternate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_add_disk_alternate(git_odb *odb, const char *path)
     * }
     */
    public static MethodHandle git_odb_add_disk_alternate$handle() {
        return git_odb_add_disk_alternate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_add_disk_alternate(git_odb *odb, const char *path)
     * }
     */
    public static MemorySegment git_odb_add_disk_alternate$address() {
        return git_odb_add_disk_alternate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_add_disk_alternate(git_odb *odb, const char *path)
     * }
     */
    public static int git_odb_add_disk_alternate(MemorySegment odb, MemorySegment path) {
        var mh$ = git_odb_add_disk_alternate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_add_disk_alternate", odb, path);
            }
            return (int)mh$.invokeExact(odb, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_odb_free(git_odb *db)
     * }
     */
    public static FunctionDescriptor git_odb_free$descriptor() {
        return git_odb_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_odb_free(git_odb *db)
     * }
     */
    public static MethodHandle git_odb_free$handle() {
        return git_odb_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_odb_free(git_odb *db)
     * }
     */
    public static MemorySegment git_odb_free$address() {
        return git_odb_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_odb_free(git_odb *db)
     * }
     */
    public static void git_odb_free(MemorySegment db) {
        var mh$ = git_odb_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_free", db);
            }
            mh$.invokeExact(db);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_read(git_odb_object **obj, git_odb *db, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_odb_read$descriptor() {
        return git_odb_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_read(git_odb_object **obj, git_odb *db, const git_oid *id)
     * }
     */
    public static MethodHandle git_odb_read$handle() {
        return git_odb_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_read(git_odb_object **obj, git_odb *db, const git_oid *id)
     * }
     */
    public static MemorySegment git_odb_read$address() {
        return git_odb_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_read(git_odb_object **obj, git_odb *db, const git_oid *id)
     * }
     */
    public static int git_odb_read(MemorySegment obj, MemorySegment db, MemorySegment id) {
        var mh$ = git_odb_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_read", obj, db, id);
            }
            return (int)mh$.invokeExact(obj, db, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_read_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_read_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_read_prefix(git_odb_object **obj, git_odb *db, const git_oid *short_id, size_t len)
     * }
     */
    public static FunctionDescriptor git_odb_read_prefix$descriptor() {
        return git_odb_read_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_read_prefix(git_odb_object **obj, git_odb *db, const git_oid *short_id, size_t len)
     * }
     */
    public static MethodHandle git_odb_read_prefix$handle() {
        return git_odb_read_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_read_prefix(git_odb_object **obj, git_odb *db, const git_oid *short_id, size_t len)
     * }
     */
    public static MemorySegment git_odb_read_prefix$address() {
        return git_odb_read_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_read_prefix(git_odb_object **obj, git_odb *db, const git_oid *short_id, size_t len)
     * }
     */
    public static int git_odb_read_prefix(MemorySegment obj, MemorySegment db, MemorySegment short_id, long len) {
        var mh$ = git_odb_read_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_read_prefix", obj, db, short_id, len);
            }
            return (int)mh$.invokeExact(obj, db, short_id, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_read_header {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_read_header");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_read_header(size_t *len_out, git_object_t *type_out, git_odb *db, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_odb_read_header$descriptor() {
        return git_odb_read_header.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_read_header(size_t *len_out, git_object_t *type_out, git_odb *db, const git_oid *id)
     * }
     */
    public static MethodHandle git_odb_read_header$handle() {
        return git_odb_read_header.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_read_header(size_t *len_out, git_object_t *type_out, git_odb *db, const git_oid *id)
     * }
     */
    public static MemorySegment git_odb_read_header$address() {
        return git_odb_read_header.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_read_header(size_t *len_out, git_object_t *type_out, git_odb *db, const git_oid *id)
     * }
     */
    public static int git_odb_read_header(MemorySegment len_out, MemorySegment type_out, MemorySegment db, MemorySegment id) {
        var mh$ = git_odb_read_header.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_read_header", len_out, type_out, db, id);
            }
            return (int)mh$.invokeExact(len_out, type_out, db, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_exists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_exists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_exists(git_odb *db, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_odb_exists$descriptor() {
        return git_odb_exists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_exists(git_odb *db, const git_oid *id)
     * }
     */
    public static MethodHandle git_odb_exists$handle() {
        return git_odb_exists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_exists(git_odb *db, const git_oid *id)
     * }
     */
    public static MemorySegment git_odb_exists$address() {
        return git_odb_exists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_exists(git_odb *db, const git_oid *id)
     * }
     */
    public static int git_odb_exists(MemorySegment db, MemorySegment id) {
        var mh$ = git_odb_exists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_exists", db, id);
            }
            return (int)mh$.invokeExact(db, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_exists_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_exists_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_exists_ext(git_odb *db, const git_oid *id, unsigned int flags)
     * }
     */
    public static FunctionDescriptor git_odb_exists_ext$descriptor() {
        return git_odb_exists_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_exists_ext(git_odb *db, const git_oid *id, unsigned int flags)
     * }
     */
    public static MethodHandle git_odb_exists_ext$handle() {
        return git_odb_exists_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_exists_ext(git_odb *db, const git_oid *id, unsigned int flags)
     * }
     */
    public static MemorySegment git_odb_exists_ext$address() {
        return git_odb_exists_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_exists_ext(git_odb *db, const git_oid *id, unsigned int flags)
     * }
     */
    public static int git_odb_exists_ext(MemorySegment db, MemorySegment id, int flags) {
        var mh$ = git_odb_exists_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_exists_ext", db, id, flags);
            }
            return (int)mh$.invokeExact(db, id, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_exists_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_exists_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_exists_prefix(git_oid *out, git_odb *db, const git_oid *short_id, size_t len)
     * }
     */
    public static FunctionDescriptor git_odb_exists_prefix$descriptor() {
        return git_odb_exists_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_exists_prefix(git_oid *out, git_odb *db, const git_oid *short_id, size_t len)
     * }
     */
    public static MethodHandle git_odb_exists_prefix$handle() {
        return git_odb_exists_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_exists_prefix(git_oid *out, git_odb *db, const git_oid *short_id, size_t len)
     * }
     */
    public static MemorySegment git_odb_exists_prefix$address() {
        return git_odb_exists_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_exists_prefix(git_oid *out, git_odb *db, const git_oid *short_id, size_t len)
     * }
     */
    public static int git_odb_exists_prefix(MemorySegment out, MemorySegment db, MemorySegment short_id, long len) {
        var mh$ = git_odb_exists_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_exists_prefix", out, db, short_id, len);
            }
            return (int)mh$.invokeExact(out, db, short_id, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_expand_ids {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_expand_ids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_expand_ids(git_odb *db, git_odb_expand_id *ids, size_t count)
     * }
     */
    public static FunctionDescriptor git_odb_expand_ids$descriptor() {
        return git_odb_expand_ids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_expand_ids(git_odb *db, git_odb_expand_id *ids, size_t count)
     * }
     */
    public static MethodHandle git_odb_expand_ids$handle() {
        return git_odb_expand_ids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_expand_ids(git_odb *db, git_odb_expand_id *ids, size_t count)
     * }
     */
    public static MemorySegment git_odb_expand_ids$address() {
        return git_odb_expand_ids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_expand_ids(git_odb *db, git_odb_expand_id *ids, size_t count)
     * }
     */
    public static int git_odb_expand_ids(MemorySegment db, MemorySegment ids, long count) {
        var mh$ = git_odb_expand_ids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_expand_ids", db, ids, count);
            }
            return (int)mh$.invokeExact(db, ids, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_refresh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_refresh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_refresh(git_odb *db)
     * }
     */
    public static FunctionDescriptor git_odb_refresh$descriptor() {
        return git_odb_refresh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_refresh(git_odb *db)
     * }
     */
    public static MethodHandle git_odb_refresh$handle() {
        return git_odb_refresh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_refresh(git_odb *db)
     * }
     */
    public static MemorySegment git_odb_refresh$address() {
        return git_odb_refresh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_refresh(git_odb *db)
     * }
     */
    public static int git_odb_refresh(MemorySegment db) {
        var mh$ = git_odb_refresh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_refresh", db);
            }
            return (int)mh$.invokeExact(db);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_foreach(git_odb *db, git_odb_foreach_cb cb, void *payload)
     * }
     */
    public static FunctionDescriptor git_odb_foreach$descriptor() {
        return git_odb_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_foreach(git_odb *db, git_odb_foreach_cb cb, void *payload)
     * }
     */
    public static MethodHandle git_odb_foreach$handle() {
        return git_odb_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_foreach(git_odb *db, git_odb_foreach_cb cb, void *payload)
     * }
     */
    public static MemorySegment git_odb_foreach$address() {
        return git_odb_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_foreach(git_odb *db, git_odb_foreach_cb cb, void *payload)
     * }
     */
    public static int git_odb_foreach(MemorySegment db, MemorySegment cb, MemorySegment payload) {
        var mh$ = git_odb_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_foreach", db, cb, payload);
            }
            return (int)mh$.invokeExact(db, cb, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_write(git_oid *out, git_odb *odb, const void *data, size_t len, git_object_t type)
     * }
     */
    public static FunctionDescriptor git_odb_write$descriptor() {
        return git_odb_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_write(git_oid *out, git_odb *odb, const void *data, size_t len, git_object_t type)
     * }
     */
    public static MethodHandle git_odb_write$handle() {
        return git_odb_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_write(git_oid *out, git_odb *odb, const void *data, size_t len, git_object_t type)
     * }
     */
    public static MemorySegment git_odb_write$address() {
        return git_odb_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_write(git_oid *out, git_odb *odb, const void *data, size_t len, git_object_t type)
     * }
     */
    public static int git_odb_write(MemorySegment out, MemorySegment odb, MemorySegment data, long len, int type) {
        var mh$ = git_odb_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_write", out, odb, data, len, type);
            }
            return (int)mh$.invokeExact(out, odb, data, len, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_open_wstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_open_wstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_open_wstream(git_odb_stream **out, git_odb *db, git_object_size_t size, git_object_t type)
     * }
     */
    public static FunctionDescriptor git_odb_open_wstream$descriptor() {
        return git_odb_open_wstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_open_wstream(git_odb_stream **out, git_odb *db, git_object_size_t size, git_object_t type)
     * }
     */
    public static MethodHandle git_odb_open_wstream$handle() {
        return git_odb_open_wstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_open_wstream(git_odb_stream **out, git_odb *db, git_object_size_t size, git_object_t type)
     * }
     */
    public static MemorySegment git_odb_open_wstream$address() {
        return git_odb_open_wstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_open_wstream(git_odb_stream **out, git_odb *db, git_object_size_t size, git_object_t type)
     * }
     */
    public static int git_odb_open_wstream(MemorySegment out, MemorySegment db, long size, int type) {
        var mh$ = git_odb_open_wstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_open_wstream", out, db, size, type);
            }
            return (int)mh$.invokeExact(out, db, size, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_stream_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_stream_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_stream_write(git_odb_stream *stream, const char *buffer, size_t len)
     * }
     */
    public static FunctionDescriptor git_odb_stream_write$descriptor() {
        return git_odb_stream_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_stream_write(git_odb_stream *stream, const char *buffer, size_t len)
     * }
     */
    public static MethodHandle git_odb_stream_write$handle() {
        return git_odb_stream_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_stream_write(git_odb_stream *stream, const char *buffer, size_t len)
     * }
     */
    public static MemorySegment git_odb_stream_write$address() {
        return git_odb_stream_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_stream_write(git_odb_stream *stream, const char *buffer, size_t len)
     * }
     */
    public static int git_odb_stream_write(MemorySegment stream, MemorySegment buffer, long len) {
        var mh$ = git_odb_stream_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_stream_write", stream, buffer, len);
            }
            return (int)mh$.invokeExact(stream, buffer, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_stream_finalize_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_stream_finalize_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_stream_finalize_write(git_oid *out, git_odb_stream *stream)
     * }
     */
    public static FunctionDescriptor git_odb_stream_finalize_write$descriptor() {
        return git_odb_stream_finalize_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_stream_finalize_write(git_oid *out, git_odb_stream *stream)
     * }
     */
    public static MethodHandle git_odb_stream_finalize_write$handle() {
        return git_odb_stream_finalize_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_stream_finalize_write(git_oid *out, git_odb_stream *stream)
     * }
     */
    public static MemorySegment git_odb_stream_finalize_write$address() {
        return git_odb_stream_finalize_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_stream_finalize_write(git_oid *out, git_odb_stream *stream)
     * }
     */
    public static int git_odb_stream_finalize_write(MemorySegment out, MemorySegment stream) {
        var mh$ = git_odb_stream_finalize_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_stream_finalize_write", out, stream);
            }
            return (int)mh$.invokeExact(out, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_stream_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_stream_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_stream_read(git_odb_stream *stream, char *buffer, size_t len)
     * }
     */
    public static FunctionDescriptor git_odb_stream_read$descriptor() {
        return git_odb_stream_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_stream_read(git_odb_stream *stream, char *buffer, size_t len)
     * }
     */
    public static MethodHandle git_odb_stream_read$handle() {
        return git_odb_stream_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_stream_read(git_odb_stream *stream, char *buffer, size_t len)
     * }
     */
    public static MemorySegment git_odb_stream_read$address() {
        return git_odb_stream_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_stream_read(git_odb_stream *stream, char *buffer, size_t len)
     * }
     */
    public static int git_odb_stream_read(MemorySegment stream, MemorySegment buffer, long len) {
        var mh$ = git_odb_stream_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_stream_read", stream, buffer, len);
            }
            return (int)mh$.invokeExact(stream, buffer, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_stream_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_stream_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_odb_stream_free(git_odb_stream *stream)
     * }
     */
    public static FunctionDescriptor git_odb_stream_free$descriptor() {
        return git_odb_stream_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_odb_stream_free(git_odb_stream *stream)
     * }
     */
    public static MethodHandle git_odb_stream_free$handle() {
        return git_odb_stream_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_odb_stream_free(git_odb_stream *stream)
     * }
     */
    public static MemorySegment git_odb_stream_free$address() {
        return git_odb_stream_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_odb_stream_free(git_odb_stream *stream)
     * }
     */
    public static void git_odb_stream_free(MemorySegment stream) {
        var mh$ = git_odb_stream_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_stream_free", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_open_rstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_open_rstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_open_rstream(git_odb_stream **out, size_t *len, git_object_t *type, git_odb *db, const git_oid *oid)
     * }
     */
    public static FunctionDescriptor git_odb_open_rstream$descriptor() {
        return git_odb_open_rstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_open_rstream(git_odb_stream **out, size_t *len, git_object_t *type, git_odb *db, const git_oid *oid)
     * }
     */
    public static MethodHandle git_odb_open_rstream$handle() {
        return git_odb_open_rstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_open_rstream(git_odb_stream **out, size_t *len, git_object_t *type, git_odb *db, const git_oid *oid)
     * }
     */
    public static MemorySegment git_odb_open_rstream$address() {
        return git_odb_open_rstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_open_rstream(git_odb_stream **out, size_t *len, git_object_t *type, git_odb *db, const git_oid *oid)
     * }
     */
    public static int git_odb_open_rstream(MemorySegment out, MemorySegment len, MemorySegment type, MemorySegment db, MemorySegment oid) {
        var mh$ = git_odb_open_rstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_open_rstream", out, len, type, db, oid);
            }
            return (int)mh$.invokeExact(out, len, type, db, oid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_write_pack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_write_pack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_write_pack(git_odb_writepack **out, git_odb *db, git_indexer_progress_cb progress_cb, void *progress_payload)
     * }
     */
    public static FunctionDescriptor git_odb_write_pack$descriptor() {
        return git_odb_write_pack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_write_pack(git_odb_writepack **out, git_odb *db, git_indexer_progress_cb progress_cb, void *progress_payload)
     * }
     */
    public static MethodHandle git_odb_write_pack$handle() {
        return git_odb_write_pack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_write_pack(git_odb_writepack **out, git_odb *db, git_indexer_progress_cb progress_cb, void *progress_payload)
     * }
     */
    public static MemorySegment git_odb_write_pack$address() {
        return git_odb_write_pack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_write_pack(git_odb_writepack **out, git_odb *db, git_indexer_progress_cb progress_cb, void *progress_payload)
     * }
     */
    public static int git_odb_write_pack(MemorySegment out, MemorySegment db, MemorySegment progress_cb, MemorySegment progress_payload) {
        var mh$ = git_odb_write_pack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_write_pack", out, db, progress_cb, progress_payload);
            }
            return (int)mh$.invokeExact(out, db, progress_cb, progress_payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_write_multi_pack_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_write_multi_pack_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_write_multi_pack_index(git_odb *db)
     * }
     */
    public static FunctionDescriptor git_odb_write_multi_pack_index$descriptor() {
        return git_odb_write_multi_pack_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_write_multi_pack_index(git_odb *db)
     * }
     */
    public static MethodHandle git_odb_write_multi_pack_index$handle() {
        return git_odb_write_multi_pack_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_write_multi_pack_index(git_odb *db)
     * }
     */
    public static MemorySegment git_odb_write_multi_pack_index$address() {
        return git_odb_write_multi_pack_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_write_multi_pack_index(git_odb *db)
     * }
     */
    public static int git_odb_write_multi_pack_index(MemorySegment db) {
        var mh$ = git_odb_write_multi_pack_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_write_multi_pack_index", db);
            }
            return (int)mh$.invokeExact(db);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_hash(git_oid *oid, const void *data, size_t len, git_object_t object_type)
     * }
     */
    public static FunctionDescriptor git_odb_hash$descriptor() {
        return git_odb_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_hash(git_oid *oid, const void *data, size_t len, git_object_t object_type)
     * }
     */
    public static MethodHandle git_odb_hash$handle() {
        return git_odb_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_hash(git_oid *oid, const void *data, size_t len, git_object_t object_type)
     * }
     */
    public static MemorySegment git_odb_hash$address() {
        return git_odb_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_hash(git_oid *oid, const void *data, size_t len, git_object_t object_type)
     * }
     */
    public static int git_odb_hash(MemorySegment oid, MemorySegment data, long len, int object_type) {
        var mh$ = git_odb_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_hash", oid, data, len, object_type);
            }
            return (int)mh$.invokeExact(oid, data, len, object_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_hashfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_hashfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_hashfile(git_oid *oid, const char *path, git_object_t object_type)
     * }
     */
    public static FunctionDescriptor git_odb_hashfile$descriptor() {
        return git_odb_hashfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_hashfile(git_oid *oid, const char *path, git_object_t object_type)
     * }
     */
    public static MethodHandle git_odb_hashfile$handle() {
        return git_odb_hashfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_hashfile(git_oid *oid, const char *path, git_object_t object_type)
     * }
     */
    public static MemorySegment git_odb_hashfile$address() {
        return git_odb_hashfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_hashfile(git_oid *oid, const char *path, git_object_t object_type)
     * }
     */
    public static int git_odb_hashfile(MemorySegment oid, MemorySegment path, int object_type) {
        var mh$ = git_odb_hashfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_hashfile", oid, path, object_type);
            }
            return (int)mh$.invokeExact(oid, path, object_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_object_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_object_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_object_dup(git_odb_object **dest, git_odb_object *source)
     * }
     */
    public static FunctionDescriptor git_odb_object_dup$descriptor() {
        return git_odb_object_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_object_dup(git_odb_object **dest, git_odb_object *source)
     * }
     */
    public static MethodHandle git_odb_object_dup$handle() {
        return git_odb_object_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_object_dup(git_odb_object **dest, git_odb_object *source)
     * }
     */
    public static MemorySegment git_odb_object_dup$address() {
        return git_odb_object_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_object_dup(git_odb_object **dest, git_odb_object *source)
     * }
     */
    public static int git_odb_object_dup(MemorySegment dest, MemorySegment source) {
        var mh$ = git_odb_object_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_object_dup", dest, source);
            }
            return (int)mh$.invokeExact(dest, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_object_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_object_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_odb_object_free(git_odb_object *object)
     * }
     */
    public static FunctionDescriptor git_odb_object_free$descriptor() {
        return git_odb_object_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_odb_object_free(git_odb_object *object)
     * }
     */
    public static MethodHandle git_odb_object_free$handle() {
        return git_odb_object_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_odb_object_free(git_odb_object *object)
     * }
     */
    public static MemorySegment git_odb_object_free$address() {
        return git_odb_object_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_odb_object_free(git_odb_object *object)
     * }
     */
    public static void git_odb_object_free(MemorySegment object) {
        var mh$ = git_odb_object_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_object_free", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_object_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_object_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_odb_object_id(git_odb_object *object)
     * }
     */
    public static FunctionDescriptor git_odb_object_id$descriptor() {
        return git_odb_object_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_odb_object_id(git_odb_object *object)
     * }
     */
    public static MethodHandle git_odb_object_id$handle() {
        return git_odb_object_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_odb_object_id(git_odb_object *object)
     * }
     */
    public static MemorySegment git_odb_object_id$address() {
        return git_odb_object_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_odb_object_id(git_odb_object *object)
     * }
     */
    public static MemorySegment git_odb_object_id(MemorySegment object) {
        var mh$ = git_odb_object_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_object_id", object);
            }
            return (MemorySegment)mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_object_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_object_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const void *git_odb_object_data(git_odb_object *object)
     * }
     */
    public static FunctionDescriptor git_odb_object_data$descriptor() {
        return git_odb_object_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const void *git_odb_object_data(git_odb_object *object)
     * }
     */
    public static MethodHandle git_odb_object_data$handle() {
        return git_odb_object_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const void *git_odb_object_data(git_odb_object *object)
     * }
     */
    public static MemorySegment git_odb_object_data$address() {
        return git_odb_object_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const void *git_odb_object_data(git_odb_object *object)
     * }
     */
    public static MemorySegment git_odb_object_data(MemorySegment object) {
        var mh$ = git_odb_object_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_object_data", object);
            }
            return (MemorySegment)mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_object_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_object_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_odb_object_size(git_odb_object *object)
     * }
     */
    public static FunctionDescriptor git_odb_object_size$descriptor() {
        return git_odb_object_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_odb_object_size(git_odb_object *object)
     * }
     */
    public static MethodHandle git_odb_object_size$handle() {
        return git_odb_object_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_odb_object_size(git_odb_object *object)
     * }
     */
    public static MemorySegment git_odb_object_size$address() {
        return git_odb_object_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_odb_object_size(git_odb_object *object)
     * }
     */
    public static long git_odb_object_size(MemorySegment object) {
        var mh$ = git_odb_object_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_object_size", object);
            }
            return (long)mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_object_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_object_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_object_t git_odb_object_type(git_odb_object *object)
     * }
     */
    public static FunctionDescriptor git_odb_object_type$descriptor() {
        return git_odb_object_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_object_t git_odb_object_type(git_odb_object *object)
     * }
     */
    public static MethodHandle git_odb_object_type$handle() {
        return git_odb_object_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_object_t git_odb_object_type(git_odb_object *object)
     * }
     */
    public static MemorySegment git_odb_object_type$address() {
        return git_odb_object_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_object_t git_odb_object_type(git_odb_object *object)
     * }
     */
    public static int git_odb_object_type(MemorySegment object) {
        var mh$ = git_odb_object_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_object_type", object);
            }
            return (int)mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_add_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_add_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_add_backend(git_odb *odb, git_odb_backend *backend, int priority)
     * }
     */
    public static FunctionDescriptor git_odb_add_backend$descriptor() {
        return git_odb_add_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_add_backend(git_odb *odb, git_odb_backend *backend, int priority)
     * }
     */
    public static MethodHandle git_odb_add_backend$handle() {
        return git_odb_add_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_add_backend(git_odb *odb, git_odb_backend *backend, int priority)
     * }
     */
    public static MemorySegment git_odb_add_backend$address() {
        return git_odb_add_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_add_backend(git_odb *odb, git_odb_backend *backend, int priority)
     * }
     */
    public static int git_odb_add_backend(MemorySegment odb, MemorySegment backend, int priority) {
        var mh$ = git_odb_add_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_add_backend", odb, backend, priority);
            }
            return (int)mh$.invokeExact(odb, backend, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_add_alternate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_add_alternate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_add_alternate(git_odb *odb, git_odb_backend *backend, int priority)
     * }
     */
    public static FunctionDescriptor git_odb_add_alternate$descriptor() {
        return git_odb_add_alternate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_add_alternate(git_odb *odb, git_odb_backend *backend, int priority)
     * }
     */
    public static MethodHandle git_odb_add_alternate$handle() {
        return git_odb_add_alternate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_add_alternate(git_odb *odb, git_odb_backend *backend, int priority)
     * }
     */
    public static MemorySegment git_odb_add_alternate$address() {
        return git_odb_add_alternate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_add_alternate(git_odb *odb, git_odb_backend *backend, int priority)
     * }
     */
    public static int git_odb_add_alternate(MemorySegment odb, MemorySegment backend, int priority) {
        var mh$ = git_odb_add_alternate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_add_alternate", odb, backend, priority);
            }
            return (int)mh$.invokeExact(odb, backend, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_num_backends {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_num_backends");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_odb_num_backends(git_odb *odb)
     * }
     */
    public static FunctionDescriptor git_odb_num_backends$descriptor() {
        return git_odb_num_backends.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_odb_num_backends(git_odb *odb)
     * }
     */
    public static MethodHandle git_odb_num_backends$handle() {
        return git_odb_num_backends.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_odb_num_backends(git_odb *odb)
     * }
     */
    public static MemorySegment git_odb_num_backends$address() {
        return git_odb_num_backends.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_odb_num_backends(git_odb *odb)
     * }
     */
    public static long git_odb_num_backends(MemorySegment odb) {
        var mh$ = git_odb_num_backends.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_num_backends", odb);
            }
            return (long)mh$.invokeExact(odb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_get_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_get_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_get_backend(git_odb_backend **out, git_odb *odb, size_t pos)
     * }
     */
    public static FunctionDescriptor git_odb_get_backend$descriptor() {
        return git_odb_get_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_get_backend(git_odb_backend **out, git_odb *odb, size_t pos)
     * }
     */
    public static MethodHandle git_odb_get_backend$handle() {
        return git_odb_get_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_get_backend(git_odb_backend **out, git_odb *odb, size_t pos)
     * }
     */
    public static MemorySegment git_odb_get_backend$address() {
        return git_odb_get_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_get_backend(git_odb_backend **out, git_odb *odb, size_t pos)
     * }
     */
    public static int git_odb_get_backend(MemorySegment out, MemorySegment odb, long pos) {
        var mh$ = git_odb_get_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_get_backend", out, odb, pos);
            }
            return (int)mh$.invokeExact(out, odb, pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_set_commit_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_set_commit_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_set_commit_graph(git_odb *odb, git_commit_graph *cgraph)
     * }
     */
    public static FunctionDescriptor git_odb_set_commit_graph$descriptor() {
        return git_odb_set_commit_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_set_commit_graph(git_odb *odb, git_commit_graph *cgraph)
     * }
     */
    public static MethodHandle git_odb_set_commit_graph$handle() {
        return git_odb_set_commit_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_set_commit_graph(git_odb *odb, git_commit_graph *cgraph)
     * }
     */
    public static MemorySegment git_odb_set_commit_graph$address() {
        return git_odb_set_commit_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_set_commit_graph(git_odb *odb, git_commit_graph *cgraph)
     * }
     */
    public static int git_odb_set_commit_graph(MemorySegment odb, MemorySegment cgraph) {
        var mh$ = git_odb_set_commit_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_set_commit_graph", odb, cgraph);
            }
            return (int)mh$.invokeExact(odb, cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_object_lookup(git_object **object, git_repository *repo, const git_oid *id, git_object_t type)
     * }
     */
    public static FunctionDescriptor git_object_lookup$descriptor() {
        return git_object_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_object_lookup(git_object **object, git_repository *repo, const git_oid *id, git_object_t type)
     * }
     */
    public static MethodHandle git_object_lookup$handle() {
        return git_object_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_object_lookup(git_object **object, git_repository *repo, const git_oid *id, git_object_t type)
     * }
     */
    public static MemorySegment git_object_lookup$address() {
        return git_object_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_object_lookup(git_object **object, git_repository *repo, const git_oid *id, git_object_t type)
     * }
     */
    public static int git_object_lookup(MemorySegment object, MemorySegment repo, MemorySegment id, int type) {
        var mh$ = git_object_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_lookup", object, repo, id, type);
            }
            return (int)mh$.invokeExact(object, repo, id, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_lookup_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_lookup_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_object_lookup_prefix(git_object **object_out, git_repository *repo, const git_oid *id, size_t len, git_object_t type)
     * }
     */
    public static FunctionDescriptor git_object_lookup_prefix$descriptor() {
        return git_object_lookup_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_object_lookup_prefix(git_object **object_out, git_repository *repo, const git_oid *id, size_t len, git_object_t type)
     * }
     */
    public static MethodHandle git_object_lookup_prefix$handle() {
        return git_object_lookup_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_object_lookup_prefix(git_object **object_out, git_repository *repo, const git_oid *id, size_t len, git_object_t type)
     * }
     */
    public static MemorySegment git_object_lookup_prefix$address() {
        return git_object_lookup_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_object_lookup_prefix(git_object **object_out, git_repository *repo, const git_oid *id, size_t len, git_object_t type)
     * }
     */
    public static int git_object_lookup_prefix(MemorySegment object_out, MemorySegment repo, MemorySegment id, long len, int type) {
        var mh$ = git_object_lookup_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_lookup_prefix", object_out, repo, id, len, type);
            }
            return (int)mh$.invokeExact(object_out, repo, id, len, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_lookup_bypath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_lookup_bypath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_object_lookup_bypath(git_object **out, const git_object *treeish, const char *path, git_object_t type)
     * }
     */
    public static FunctionDescriptor git_object_lookup_bypath$descriptor() {
        return git_object_lookup_bypath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_object_lookup_bypath(git_object **out, const git_object *treeish, const char *path, git_object_t type)
     * }
     */
    public static MethodHandle git_object_lookup_bypath$handle() {
        return git_object_lookup_bypath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_object_lookup_bypath(git_object **out, const git_object *treeish, const char *path, git_object_t type)
     * }
     */
    public static MemorySegment git_object_lookup_bypath$address() {
        return git_object_lookup_bypath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_object_lookup_bypath(git_object **out, const git_object *treeish, const char *path, git_object_t type)
     * }
     */
    public static int git_object_lookup_bypath(MemorySegment out, MemorySegment treeish, MemorySegment path, int type) {
        var mh$ = git_object_lookup_bypath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_lookup_bypath", out, treeish, path, type);
            }
            return (int)mh$.invokeExact(out, treeish, path, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_object_id(const git_object *obj)
     * }
     */
    public static FunctionDescriptor git_object_id$descriptor() {
        return git_object_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_object_id(const git_object *obj)
     * }
     */
    public static MethodHandle git_object_id$handle() {
        return git_object_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_object_id(const git_object *obj)
     * }
     */
    public static MemorySegment git_object_id$address() {
        return git_object_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_object_id(const git_object *obj)
     * }
     */
    public static MemorySegment git_object_id(MemorySegment obj) {
        var mh$ = git_object_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_id", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_short_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_short_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_object_short_id(git_buf *out, const git_object *obj)
     * }
     */
    public static FunctionDescriptor git_object_short_id$descriptor() {
        return git_object_short_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_object_short_id(git_buf *out, const git_object *obj)
     * }
     */
    public static MethodHandle git_object_short_id$handle() {
        return git_object_short_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_object_short_id(git_buf *out, const git_object *obj)
     * }
     */
    public static MemorySegment git_object_short_id$address() {
        return git_object_short_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_object_short_id(git_buf *out, const git_object *obj)
     * }
     */
    public static int git_object_short_id(MemorySegment out, MemorySegment obj) {
        var mh$ = git_object_short_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_short_id", out, obj);
            }
            return (int)mh$.invokeExact(out, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_object_t git_object_type(const git_object *obj)
     * }
     */
    public static FunctionDescriptor git_object_type$descriptor() {
        return git_object_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_object_t git_object_type(const git_object *obj)
     * }
     */
    public static MethodHandle git_object_type$handle() {
        return git_object_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_object_t git_object_type(const git_object *obj)
     * }
     */
    public static MemorySegment git_object_type$address() {
        return git_object_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_object_t git_object_type(const git_object *obj)
     * }
     */
    public static int git_object_type(MemorySegment obj) {
        var mh$ = git_object_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_type", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_object_owner(const git_object *obj)
     * }
     */
    public static FunctionDescriptor git_object_owner$descriptor() {
        return git_object_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_object_owner(const git_object *obj)
     * }
     */
    public static MethodHandle git_object_owner$handle() {
        return git_object_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_object_owner(const git_object *obj)
     * }
     */
    public static MemorySegment git_object_owner$address() {
        return git_object_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_object_owner(const git_object *obj)
     * }
     */
    public static MemorySegment git_object_owner(MemorySegment obj) {
        var mh$ = git_object_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_owner", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_object_free(git_object *object)
     * }
     */
    public static FunctionDescriptor git_object_free$descriptor() {
        return git_object_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_object_free(git_object *object)
     * }
     */
    public static MethodHandle git_object_free$handle() {
        return git_object_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_object_free(git_object *object)
     * }
     */
    public static MemorySegment git_object_free$address() {
        return git_object_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_object_free(git_object *object)
     * }
     */
    public static void git_object_free(MemorySegment object) {
        var mh$ = git_object_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_free", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_type2string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_type2string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_object_type2string(git_object_t type)
     * }
     */
    public static FunctionDescriptor git_object_type2string$descriptor() {
        return git_object_type2string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_object_type2string(git_object_t type)
     * }
     */
    public static MethodHandle git_object_type2string$handle() {
        return git_object_type2string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_object_type2string(git_object_t type)
     * }
     */
    public static MemorySegment git_object_type2string$address() {
        return git_object_type2string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_object_type2string(git_object_t type)
     * }
     */
    public static MemorySegment git_object_type2string(int type) {
        var mh$ = git_object_type2string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_type2string", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_string2type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_string2type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_object_t git_object_string2type(const char *str)
     * }
     */
    public static FunctionDescriptor git_object_string2type$descriptor() {
        return git_object_string2type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_object_t git_object_string2type(const char *str)
     * }
     */
    public static MethodHandle git_object_string2type$handle() {
        return git_object_string2type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_object_t git_object_string2type(const char *str)
     * }
     */
    public static MemorySegment git_object_string2type$address() {
        return git_object_string2type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_object_t git_object_string2type(const char *str)
     * }
     */
    public static int git_object_string2type(MemorySegment str) {
        var mh$ = git_object_string2type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_string2type", str);
            }
            return (int)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_typeisloose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_typeisloose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_object_typeisloose(git_object_t type)
     * }
     */
    public static FunctionDescriptor git_object_typeisloose$descriptor() {
        return git_object_typeisloose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_object_typeisloose(git_object_t type)
     * }
     */
    public static MethodHandle git_object_typeisloose$handle() {
        return git_object_typeisloose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_object_typeisloose(git_object_t type)
     * }
     */
    public static MemorySegment git_object_typeisloose$address() {
        return git_object_typeisloose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_object_typeisloose(git_object_t type)
     * }
     */
    public static int git_object_typeisloose(int type) {
        var mh$ = git_object_typeisloose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_typeisloose", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_peel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_peel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_object_peel(git_object **peeled, const git_object *object, git_object_t target_type)
     * }
     */
    public static FunctionDescriptor git_object_peel$descriptor() {
        return git_object_peel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_object_peel(git_object **peeled, const git_object *object, git_object_t target_type)
     * }
     */
    public static MethodHandle git_object_peel$handle() {
        return git_object_peel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_object_peel(git_object **peeled, const git_object *object, git_object_t target_type)
     * }
     */
    public static MemorySegment git_object_peel$address() {
        return git_object_peel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_object_peel(git_object **peeled, const git_object *object, git_object_t target_type)
     * }
     */
    public static int git_object_peel(MemorySegment peeled, MemorySegment object, int target_type) {
        var mh$ = git_object_peel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_peel", peeled, object, target_type);
            }
            return (int)mh$.invokeExact(peeled, object, target_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_object_dup(git_object **dest, git_object *source)
     * }
     */
    public static FunctionDescriptor git_object_dup$descriptor() {
        return git_object_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_object_dup(git_object **dest, git_object *source)
     * }
     */
    public static MethodHandle git_object_dup$handle() {
        return git_object_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_object_dup(git_object **dest, git_object *source)
     * }
     */
    public static MemorySegment git_object_dup$address() {
        return git_object_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_object_dup(git_object **dest, git_object *source)
     * }
     */
    public static int git_object_dup(MemorySegment dest, MemorySegment source) {
        var mh$ = git_object_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_dup", dest, source);
            }
            return (int)mh$.invokeExact(dest, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object_rawcontent_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object_rawcontent_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_object_rawcontent_is_valid(int *valid, const char *buf, size_t len, git_object_t object_type)
     * }
     */
    public static FunctionDescriptor git_object_rawcontent_is_valid$descriptor() {
        return git_object_rawcontent_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_object_rawcontent_is_valid(int *valid, const char *buf, size_t len, git_object_t object_type)
     * }
     */
    public static MethodHandle git_object_rawcontent_is_valid$handle() {
        return git_object_rawcontent_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_object_rawcontent_is_valid(int *valid, const char *buf, size_t len, git_object_t object_type)
     * }
     */
    public static MemorySegment git_object_rawcontent_is_valid$address() {
        return git_object_rawcontent_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_object_rawcontent_is_valid(int *valid, const char *buf, size_t len, git_object_t object_type)
     * }
     */
    public static int git_object_rawcontent_is_valid(MemorySegment valid, MemorySegment buf, long len, int object_type) {
        var mh$ = git_object_rawcontent_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object_rawcontent_is_valid", valid, buf, len, object_type);
            }
            return (int)mh$.invokeExact(valid, buf, len, object_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_lookup(git_commit **commit, git_repository *repo, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_commit_lookup$descriptor() {
        return git_commit_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_lookup(git_commit **commit, git_repository *repo, const git_oid *id)
     * }
     */
    public static MethodHandle git_commit_lookup$handle() {
        return git_commit_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_lookup(git_commit **commit, git_repository *repo, const git_oid *id)
     * }
     */
    public static MemorySegment git_commit_lookup$address() {
        return git_commit_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_lookup(git_commit **commit, git_repository *repo, const git_oid *id)
     * }
     */
    public static int git_commit_lookup(MemorySegment commit, MemorySegment repo, MemorySegment id) {
        var mh$ = git_commit_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_lookup", commit, repo, id);
            }
            return (int)mh$.invokeExact(commit, repo, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_lookup_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_lookup_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_lookup_prefix(git_commit **commit, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static FunctionDescriptor git_commit_lookup_prefix$descriptor() {
        return git_commit_lookup_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_lookup_prefix(git_commit **commit, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static MethodHandle git_commit_lookup_prefix$handle() {
        return git_commit_lookup_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_lookup_prefix(git_commit **commit, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static MemorySegment git_commit_lookup_prefix$address() {
        return git_commit_lookup_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_lookup_prefix(git_commit **commit, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static int git_commit_lookup_prefix(MemorySegment commit, MemorySegment repo, MemorySegment id, long len) {
        var mh$ = git_commit_lookup_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_lookup_prefix", commit, repo, id, len);
            }
            return (int)mh$.invokeExact(commit, repo, id, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_commit_free(git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_free$descriptor() {
        return git_commit_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_commit_free(git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_free$handle() {
        return git_commit_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_commit_free(git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_free$address() {
        return git_commit_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_commit_free(git_commit *commit)
     * }
     */
    public static void git_commit_free(MemorySegment commit) {
        var mh$ = git_commit_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_free", commit);
            }
            mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_commit_id(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_id$descriptor() {
        return git_commit_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_commit_id(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_id$handle() {
        return git_commit_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_commit_id(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_id$address() {
        return git_commit_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_commit_id(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_id(MemorySegment commit) {
        var mh$ = git_commit_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_id", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_commit_owner(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_owner$descriptor() {
        return git_commit_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_commit_owner(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_owner$handle() {
        return git_commit_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_commit_owner(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_owner$address() {
        return git_commit_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_commit_owner(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_owner(MemorySegment commit) {
        var mh$ = git_commit_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_owner", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_message_encoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_message_encoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_commit_message_encoding(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_message_encoding$descriptor() {
        return git_commit_message_encoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_commit_message_encoding(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_message_encoding$handle() {
        return git_commit_message_encoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_commit_message_encoding(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_message_encoding$address() {
        return git_commit_message_encoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_commit_message_encoding(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_message_encoding(MemorySegment commit) {
        var mh$ = git_commit_message_encoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_message_encoding", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_commit_message(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_message$descriptor() {
        return git_commit_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_commit_message(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_message$handle() {
        return git_commit_message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_commit_message(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_message$address() {
        return git_commit_message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_commit_message(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_message(MemorySegment commit) {
        var mh$ = git_commit_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_message", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_message_raw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_message_raw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_commit_message_raw(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_message_raw$descriptor() {
        return git_commit_message_raw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_commit_message_raw(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_message_raw$handle() {
        return git_commit_message_raw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_commit_message_raw(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_message_raw$address() {
        return git_commit_message_raw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_commit_message_raw(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_message_raw(MemorySegment commit) {
        var mh$ = git_commit_message_raw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_message_raw", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_summary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_summary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_commit_summary(git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_summary$descriptor() {
        return git_commit_summary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_commit_summary(git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_summary$handle() {
        return git_commit_summary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_commit_summary(git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_summary$address() {
        return git_commit_summary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_commit_summary(git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_summary(MemorySegment commit) {
        var mh$ = git_commit_summary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_summary", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_body {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_body");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_commit_body(git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_body$descriptor() {
        return git_commit_body.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_commit_body(git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_body$handle() {
        return git_commit_body.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_commit_body(git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_body$address() {
        return git_commit_body.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_commit_body(git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_body(MemorySegment commit) {
        var mh$ = git_commit_body.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_body", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_time_t git_commit_time(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_time$descriptor() {
        return git_commit_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_time_t git_commit_time(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_time$handle() {
        return git_commit_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_time_t git_commit_time(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_time$address() {
        return git_commit_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_time_t git_commit_time(const git_commit *commit)
     * }
     */
    public static long git_commit_time(MemorySegment commit) {
        var mh$ = git_commit_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_time", commit);
            }
            return (long)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_time_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_time_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_time_offset(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_time_offset$descriptor() {
        return git_commit_time_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_time_offset(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_time_offset$handle() {
        return git_commit_time_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_time_offset(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_time_offset$address() {
        return git_commit_time_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_time_offset(const git_commit *commit)
     * }
     */
    public static int git_commit_time_offset(MemorySegment commit) {
        var mh$ = git_commit_time_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_time_offset", commit);
            }
            return (int)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_committer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_committer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_signature *git_commit_committer(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_committer$descriptor() {
        return git_commit_committer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_signature *git_commit_committer(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_committer$handle() {
        return git_commit_committer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_signature *git_commit_committer(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_committer$address() {
        return git_commit_committer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_signature *git_commit_committer(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_committer(MemorySegment commit) {
        var mh$ = git_commit_committer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_committer", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_author {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_author");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_signature *git_commit_author(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_author$descriptor() {
        return git_commit_author.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_signature *git_commit_author(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_author$handle() {
        return git_commit_author.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_signature *git_commit_author(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_author$address() {
        return git_commit_author.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_signature *git_commit_author(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_author(MemorySegment commit) {
        var mh$ = git_commit_author.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_author", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_committer_with_mailmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_committer_with_mailmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_committer_with_mailmap(git_signature **out, const git_commit *commit, const git_mailmap *mailmap)
     * }
     */
    public static FunctionDescriptor git_commit_committer_with_mailmap$descriptor() {
        return git_commit_committer_with_mailmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_committer_with_mailmap(git_signature **out, const git_commit *commit, const git_mailmap *mailmap)
     * }
     */
    public static MethodHandle git_commit_committer_with_mailmap$handle() {
        return git_commit_committer_with_mailmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_committer_with_mailmap(git_signature **out, const git_commit *commit, const git_mailmap *mailmap)
     * }
     */
    public static MemorySegment git_commit_committer_with_mailmap$address() {
        return git_commit_committer_with_mailmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_committer_with_mailmap(git_signature **out, const git_commit *commit, const git_mailmap *mailmap)
     * }
     */
    public static int git_commit_committer_with_mailmap(MemorySegment out, MemorySegment commit, MemorySegment mailmap) {
        var mh$ = git_commit_committer_with_mailmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_committer_with_mailmap", out, commit, mailmap);
            }
            return (int)mh$.invokeExact(out, commit, mailmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_author_with_mailmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_author_with_mailmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_author_with_mailmap(git_signature **out, const git_commit *commit, const git_mailmap *mailmap)
     * }
     */
    public static FunctionDescriptor git_commit_author_with_mailmap$descriptor() {
        return git_commit_author_with_mailmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_author_with_mailmap(git_signature **out, const git_commit *commit, const git_mailmap *mailmap)
     * }
     */
    public static MethodHandle git_commit_author_with_mailmap$handle() {
        return git_commit_author_with_mailmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_author_with_mailmap(git_signature **out, const git_commit *commit, const git_mailmap *mailmap)
     * }
     */
    public static MemorySegment git_commit_author_with_mailmap$address() {
        return git_commit_author_with_mailmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_author_with_mailmap(git_signature **out, const git_commit *commit, const git_mailmap *mailmap)
     * }
     */
    public static int git_commit_author_with_mailmap(MemorySegment out, MemorySegment commit, MemorySegment mailmap) {
        var mh$ = git_commit_author_with_mailmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_author_with_mailmap", out, commit, mailmap);
            }
            return (int)mh$.invokeExact(out, commit, mailmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_raw_header {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_raw_header");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_commit_raw_header(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_raw_header$descriptor() {
        return git_commit_raw_header.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_commit_raw_header(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_raw_header$handle() {
        return git_commit_raw_header.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_commit_raw_header(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_raw_header$address() {
        return git_commit_raw_header.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_commit_raw_header(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_raw_header(MemorySegment commit) {
        var mh$ = git_commit_raw_header.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_raw_header", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_tree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_tree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_tree(git_tree **tree_out, const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_tree$descriptor() {
        return git_commit_tree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_tree(git_tree **tree_out, const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_tree$handle() {
        return git_commit_tree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_tree(git_tree **tree_out, const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_tree$address() {
        return git_commit_tree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_tree(git_tree **tree_out, const git_commit *commit)
     * }
     */
    public static int git_commit_tree(MemorySegment tree_out, MemorySegment commit) {
        var mh$ = git_commit_tree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_tree", tree_out, commit);
            }
            return (int)mh$.invokeExact(tree_out, commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_tree_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_tree_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_commit_tree_id(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_tree_id$descriptor() {
        return git_commit_tree_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_commit_tree_id(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_tree_id$handle() {
        return git_commit_tree_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_commit_tree_id(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_tree_id$address() {
        return git_commit_tree_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_commit_tree_id(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_tree_id(MemorySegment commit) {
        var mh$ = git_commit_tree_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_tree_id", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_parentcount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_parentcount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int git_commit_parentcount(const git_commit *commit)
     * }
     */
    public static FunctionDescriptor git_commit_parentcount$descriptor() {
        return git_commit_parentcount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int git_commit_parentcount(const git_commit *commit)
     * }
     */
    public static MethodHandle git_commit_parentcount$handle() {
        return git_commit_parentcount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int git_commit_parentcount(const git_commit *commit)
     * }
     */
    public static MemorySegment git_commit_parentcount$address() {
        return git_commit_parentcount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int git_commit_parentcount(const git_commit *commit)
     * }
     */
    public static int git_commit_parentcount(MemorySegment commit) {
        var mh$ = git_commit_parentcount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_parentcount", commit);
            }
            return (int)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_parent(git_commit **out, const git_commit *commit, unsigned int n)
     * }
     */
    public static FunctionDescriptor git_commit_parent$descriptor() {
        return git_commit_parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_parent(git_commit **out, const git_commit *commit, unsigned int n)
     * }
     */
    public static MethodHandle git_commit_parent$handle() {
        return git_commit_parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_parent(git_commit **out, const git_commit *commit, unsigned int n)
     * }
     */
    public static MemorySegment git_commit_parent$address() {
        return git_commit_parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_parent(git_commit **out, const git_commit *commit, unsigned int n)
     * }
     */
    public static int git_commit_parent(MemorySegment out, MemorySegment commit, int n) {
        var mh$ = git_commit_parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_parent", out, commit, n);
            }
            return (int)mh$.invokeExact(out, commit, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_parent_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_parent_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_commit_parent_id(const git_commit *commit, unsigned int n)
     * }
     */
    public static FunctionDescriptor git_commit_parent_id$descriptor() {
        return git_commit_parent_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_commit_parent_id(const git_commit *commit, unsigned int n)
     * }
     */
    public static MethodHandle git_commit_parent_id$handle() {
        return git_commit_parent_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_commit_parent_id(const git_commit *commit, unsigned int n)
     * }
     */
    public static MemorySegment git_commit_parent_id$address() {
        return git_commit_parent_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_commit_parent_id(const git_commit *commit, unsigned int n)
     * }
     */
    public static MemorySegment git_commit_parent_id(MemorySegment commit, int n) {
        var mh$ = git_commit_parent_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_parent_id", commit, n);
            }
            return (MemorySegment)mh$.invokeExact(commit, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_nth_gen_ancestor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_nth_gen_ancestor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_nth_gen_ancestor(git_commit **ancestor, const git_commit *commit, unsigned int n)
     * }
     */
    public static FunctionDescriptor git_commit_nth_gen_ancestor$descriptor() {
        return git_commit_nth_gen_ancestor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_nth_gen_ancestor(git_commit **ancestor, const git_commit *commit, unsigned int n)
     * }
     */
    public static MethodHandle git_commit_nth_gen_ancestor$handle() {
        return git_commit_nth_gen_ancestor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_nth_gen_ancestor(git_commit **ancestor, const git_commit *commit, unsigned int n)
     * }
     */
    public static MemorySegment git_commit_nth_gen_ancestor$address() {
        return git_commit_nth_gen_ancestor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_nth_gen_ancestor(git_commit **ancestor, const git_commit *commit, unsigned int n)
     * }
     */
    public static int git_commit_nth_gen_ancestor(MemorySegment ancestor, MemorySegment commit, int n) {
        var mh$ = git_commit_nth_gen_ancestor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_nth_gen_ancestor", ancestor, commit, n);
            }
            return (int)mh$.invokeExact(ancestor, commit, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_header_field {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_header_field");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_header_field(git_buf *out, const git_commit *commit, const char *field)
     * }
     */
    public static FunctionDescriptor git_commit_header_field$descriptor() {
        return git_commit_header_field.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_header_field(git_buf *out, const git_commit *commit, const char *field)
     * }
     */
    public static MethodHandle git_commit_header_field$handle() {
        return git_commit_header_field.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_header_field(git_buf *out, const git_commit *commit, const char *field)
     * }
     */
    public static MemorySegment git_commit_header_field$address() {
        return git_commit_header_field.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_header_field(git_buf *out, const git_commit *commit, const char *field)
     * }
     */
    public static int git_commit_header_field(MemorySegment out, MemorySegment commit, MemorySegment field) {
        var mh$ = git_commit_header_field.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_header_field", out, commit, field);
            }
            return (int)mh$.invokeExact(out, commit, field);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_extract_signature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_extract_signature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_extract_signature(git_buf *signature, git_buf *signed_data, git_repository *repo, git_oid *commit_id, const char *field)
     * }
     */
    public static FunctionDescriptor git_commit_extract_signature$descriptor() {
        return git_commit_extract_signature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_extract_signature(git_buf *signature, git_buf *signed_data, git_repository *repo, git_oid *commit_id, const char *field)
     * }
     */
    public static MethodHandle git_commit_extract_signature$handle() {
        return git_commit_extract_signature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_extract_signature(git_buf *signature, git_buf *signed_data, git_repository *repo, git_oid *commit_id, const char *field)
     * }
     */
    public static MemorySegment git_commit_extract_signature$address() {
        return git_commit_extract_signature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_extract_signature(git_buf *signature, git_buf *signed_data, git_repository *repo, git_oid *commit_id, const char *field)
     * }
     */
    public static int git_commit_extract_signature(MemorySegment signature, MemorySegment signed_data, MemorySegment repo, MemorySegment commit_id, MemorySegment field) {
        var mh$ = git_commit_extract_signature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_extract_signature", signature, signed_data, repo, commit_id, field);
            }
            return (int)mh$.invokeExact(signature, signed_data, repo, commit_id, field);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_create(git_oid *id, git_repository *repo, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, const git_commit *parents[])
     * }
     */
    public static FunctionDescriptor git_commit_create$descriptor() {
        return git_commit_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_create(git_oid *id, git_repository *repo, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, const git_commit *parents[])
     * }
     */
    public static MethodHandle git_commit_create$handle() {
        return git_commit_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_create(git_oid *id, git_repository *repo, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, const git_commit *parents[])
     * }
     */
    public static MemorySegment git_commit_create$address() {
        return git_commit_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_create(git_oid *id, git_repository *repo, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, const git_commit *parents[])
     * }
     */
    public static int git_commit_create(MemorySegment id, MemorySegment repo, MemorySegment update_ref, MemorySegment author, MemorySegment committer, MemorySegment message_encoding, MemorySegment message, MemorySegment tree, long parent_count, MemorySegment parents) {
        var mh$ = git_commit_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_create", id, repo, update_ref, author, committer, message_encoding, message, tree, parent_count, parents);
            }
            return (int)mh$.invokeExact(id, repo, update_ref, author, committer, message_encoding, message, tree, parent_count, parents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int git_commit_create_v(git_oid *id, git_repository *repo, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, ...)
     * }
     */
    public static class git_commit_create_v {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                git2.C_INT,
                git2.C_POINTER,
                git2.C_POINTER,
                git2.C_POINTER,
                git2.C_POINTER,
                git2.C_POINTER,
                git2.C_POINTER,
                git2.C_POINTER,
                git2.C_POINTER,
                git2.C_LONG
            );
        private static final MemorySegment ADDR = git2.findOrThrow("git_commit_create_v");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private git_commit_create_v(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int git_commit_create_v(git_oid *id, git_repository *repo, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, ...)
         * }
         */
        public static git_commit_create_v makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new git_commit_create_v(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment id, MemorySegment repo, MemorySegment update_ref, MemorySegment author, MemorySegment committer, MemorySegment message_encoding, MemorySegment message, MemorySegment tree, long parent_count, Object... x9) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("git_commit_create_v", id, repo, update_ref, author, committer, message_encoding, message, tree, parent_count, x9);
                }
                return (int) spreader.invokeExact(id, repo, update_ref, author, committer, message_encoding, message, tree, parent_count, x9);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class git_commit_create_from_stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_create_from_stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_create_from_stage(git_oid *id, git_repository *repo, const char *message, const git_commit_create_options *opts)
     * }
     */
    public static FunctionDescriptor git_commit_create_from_stage$descriptor() {
        return git_commit_create_from_stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_create_from_stage(git_oid *id, git_repository *repo, const char *message, const git_commit_create_options *opts)
     * }
     */
    public static MethodHandle git_commit_create_from_stage$handle() {
        return git_commit_create_from_stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_create_from_stage(git_oid *id, git_repository *repo, const char *message, const git_commit_create_options *opts)
     * }
     */
    public static MemorySegment git_commit_create_from_stage$address() {
        return git_commit_create_from_stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_create_from_stage(git_oid *id, git_repository *repo, const char *message, const git_commit_create_options *opts)
     * }
     */
    public static int git_commit_create_from_stage(MemorySegment id, MemorySegment repo, MemorySegment message, MemorySegment opts) {
        var mh$ = git_commit_create_from_stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_create_from_stage", id, repo, message, opts);
            }
            return (int)mh$.invokeExact(id, repo, message, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_amend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_amend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_amend(git_oid *id, const git_commit *commit_to_amend, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree)
     * }
     */
    public static FunctionDescriptor git_commit_amend$descriptor() {
        return git_commit_amend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_amend(git_oid *id, const git_commit *commit_to_amend, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree)
     * }
     */
    public static MethodHandle git_commit_amend$handle() {
        return git_commit_amend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_amend(git_oid *id, const git_commit *commit_to_amend, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree)
     * }
     */
    public static MemorySegment git_commit_amend$address() {
        return git_commit_amend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_amend(git_oid *id, const git_commit *commit_to_amend, const char *update_ref, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree)
     * }
     */
    public static int git_commit_amend(MemorySegment id, MemorySegment commit_to_amend, MemorySegment update_ref, MemorySegment author, MemorySegment committer, MemorySegment message_encoding, MemorySegment message, MemorySegment tree) {
        var mh$ = git_commit_amend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_amend", id, commit_to_amend, update_ref, author, committer, message_encoding, message, tree);
            }
            return (int)mh$.invokeExact(id, commit_to_amend, update_ref, author, committer, message_encoding, message, tree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_create_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_create_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_create_buffer(git_buf *out, git_repository *repo, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, const git_commit *parents[])
     * }
     */
    public static FunctionDescriptor git_commit_create_buffer$descriptor() {
        return git_commit_create_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_create_buffer(git_buf *out, git_repository *repo, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, const git_commit *parents[])
     * }
     */
    public static MethodHandle git_commit_create_buffer$handle() {
        return git_commit_create_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_create_buffer(git_buf *out, git_repository *repo, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, const git_commit *parents[])
     * }
     */
    public static MemorySegment git_commit_create_buffer$address() {
        return git_commit_create_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_create_buffer(git_buf *out, git_repository *repo, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message, const git_tree *tree, size_t parent_count, const git_commit *parents[])
     * }
     */
    public static int git_commit_create_buffer(MemorySegment out, MemorySegment repo, MemorySegment author, MemorySegment committer, MemorySegment message_encoding, MemorySegment message, MemorySegment tree, long parent_count, MemorySegment parents) {
        var mh$ = git_commit_create_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_create_buffer", out, repo, author, committer, message_encoding, message, tree, parent_count, parents);
            }
            return (int)mh$.invokeExact(out, repo, author, committer, message_encoding, message, tree, parent_count, parents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_create_with_signature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_create_with_signature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_create_with_signature(git_oid *out, git_repository *repo, const char *commit_content, const char *signature, const char *signature_field)
     * }
     */
    public static FunctionDescriptor git_commit_create_with_signature$descriptor() {
        return git_commit_create_with_signature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_create_with_signature(git_oid *out, git_repository *repo, const char *commit_content, const char *signature, const char *signature_field)
     * }
     */
    public static MethodHandle git_commit_create_with_signature$handle() {
        return git_commit_create_with_signature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_create_with_signature(git_oid *out, git_repository *repo, const char *commit_content, const char *signature, const char *signature_field)
     * }
     */
    public static MemorySegment git_commit_create_with_signature$address() {
        return git_commit_create_with_signature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_create_with_signature(git_oid *out, git_repository *repo, const char *commit_content, const char *signature, const char *signature_field)
     * }
     */
    public static int git_commit_create_with_signature(MemorySegment out, MemorySegment repo, MemorySegment commit_content, MemorySegment signature, MemorySegment signature_field) {
        var mh$ = git_commit_create_with_signature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_create_with_signature", out, repo, commit_content, signature, signature_field);
            }
            return (int)mh$.invokeExact(out, repo, commit_content, signature, signature_field);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commit_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commit_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_commit_dup(git_commit **out, git_commit *source)
     * }
     */
    public static FunctionDescriptor git_commit_dup$descriptor() {
        return git_commit_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_commit_dup(git_commit **out, git_commit *source)
     * }
     */
    public static MethodHandle git_commit_dup$handle() {
        return git_commit_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_commit_dup(git_commit **out, git_commit *source)
     * }
     */
    public static MemorySegment git_commit_dup$address() {
        return git_commit_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_commit_dup(git_commit **out, git_commit *source)
     * }
     */
    public static int git_commit_dup(MemorySegment out, MemorySegment source) {
        var mh$ = git_commit_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commit_dup", out, source);
            }
            return (int)mh$.invokeExact(out, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_commitarray_dispose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_commitarray_dispose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_commitarray_dispose(git_commitarray *array)
     * }
     */
    public static FunctionDescriptor git_commitarray_dispose$descriptor() {
        return git_commitarray_dispose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_commitarray_dispose(git_commitarray *array)
     * }
     */
    public static MethodHandle git_commitarray_dispose$handle() {
        return git_commitarray_dispose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_commitarray_dispose(git_commitarray *array)
     * }
     */
    public static MemorySegment git_commitarray_dispose$address() {
        return git_commitarray_dispose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_commitarray_dispose(git_commitarray *array)
     * }
     */
    public static void git_commitarray_dispose(MemorySegment array) {
        var mh$ = git_commitarray_dispose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_commitarray_dispose", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_open(git_repository **out, const char *path)
     * }
     */
    public static FunctionDescriptor git_repository_open$descriptor() {
        return git_repository_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_open(git_repository **out, const char *path)
     * }
     */
    public static MethodHandle git_repository_open$handle() {
        return git_repository_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_open(git_repository **out, const char *path)
     * }
     */
    public static MemorySegment git_repository_open$address() {
        return git_repository_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_open(git_repository **out, const char *path)
     * }
     */
    public static int git_repository_open(MemorySegment out, MemorySegment path) {
        var mh$ = git_repository_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_open", out, path);
            }
            return (int)mh$.invokeExact(out, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_open_from_worktree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_open_from_worktree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_open_from_worktree(git_repository **out, git_worktree *wt)
     * }
     */
    public static FunctionDescriptor git_repository_open_from_worktree$descriptor() {
        return git_repository_open_from_worktree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_open_from_worktree(git_repository **out, git_worktree *wt)
     * }
     */
    public static MethodHandle git_repository_open_from_worktree$handle() {
        return git_repository_open_from_worktree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_open_from_worktree(git_repository **out, git_worktree *wt)
     * }
     */
    public static MemorySegment git_repository_open_from_worktree$address() {
        return git_repository_open_from_worktree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_open_from_worktree(git_repository **out, git_worktree *wt)
     * }
     */
    public static int git_repository_open_from_worktree(MemorySegment out, MemorySegment wt) {
        var mh$ = git_repository_open_from_worktree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_open_from_worktree", out, wt);
            }
            return (int)mh$.invokeExact(out, wt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_wrap_odb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_wrap_odb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_wrap_odb(git_repository **out, git_odb *odb)
     * }
     */
    public static FunctionDescriptor git_repository_wrap_odb$descriptor() {
        return git_repository_wrap_odb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_wrap_odb(git_repository **out, git_odb *odb)
     * }
     */
    public static MethodHandle git_repository_wrap_odb$handle() {
        return git_repository_wrap_odb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_wrap_odb(git_repository **out, git_odb *odb)
     * }
     */
    public static MemorySegment git_repository_wrap_odb$address() {
        return git_repository_wrap_odb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_wrap_odb(git_repository **out, git_odb *odb)
     * }
     */
    public static int git_repository_wrap_odb(MemorySegment out, MemorySegment odb) {
        var mh$ = git_repository_wrap_odb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_wrap_odb", out, odb);
            }
            return (int)mh$.invokeExact(out, odb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_discover {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_discover");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_discover(git_buf *out, const char *start_path, int across_fs, const char *ceiling_dirs)
     * }
     */
    public static FunctionDescriptor git_repository_discover$descriptor() {
        return git_repository_discover.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_discover(git_buf *out, const char *start_path, int across_fs, const char *ceiling_dirs)
     * }
     */
    public static MethodHandle git_repository_discover$handle() {
        return git_repository_discover.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_discover(git_buf *out, const char *start_path, int across_fs, const char *ceiling_dirs)
     * }
     */
    public static MemorySegment git_repository_discover$address() {
        return git_repository_discover.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_discover(git_buf *out, const char *start_path, int across_fs, const char *ceiling_dirs)
     * }
     */
    public static int git_repository_discover(MemorySegment out, MemorySegment start_path, int across_fs, MemorySegment ceiling_dirs) {
        var mh$ = git_repository_discover.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_discover", out, start_path, across_fs, ceiling_dirs);
            }
            return (int)mh$.invokeExact(out, start_path, across_fs, ceiling_dirs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_REPOSITORY_OPEN_NO_SEARCH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_OPEN_NO_SEARCH = 1
     * }
     */
    public static int GIT_REPOSITORY_OPEN_NO_SEARCH() {
        return GIT_REPOSITORY_OPEN_NO_SEARCH;
    }
    private static final int GIT_REPOSITORY_OPEN_CROSS_FS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_OPEN_CROSS_FS = 2
     * }
     */
    public static int GIT_REPOSITORY_OPEN_CROSS_FS() {
        return GIT_REPOSITORY_OPEN_CROSS_FS;
    }
    private static final int GIT_REPOSITORY_OPEN_BARE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_OPEN_BARE = 4
     * }
     */
    public static int GIT_REPOSITORY_OPEN_BARE() {
        return GIT_REPOSITORY_OPEN_BARE;
    }
    private static final int GIT_REPOSITORY_OPEN_NO_DOTGIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_OPEN_NO_DOTGIT = 8
     * }
     */
    public static int GIT_REPOSITORY_OPEN_NO_DOTGIT() {
        return GIT_REPOSITORY_OPEN_NO_DOTGIT;
    }
    private static final int GIT_REPOSITORY_OPEN_FROM_ENV = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_OPEN_FROM_ENV = 16
     * }
     */
    public static int GIT_REPOSITORY_OPEN_FROM_ENV() {
        return GIT_REPOSITORY_OPEN_FROM_ENV;
    }

    private static class git_repository_open_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_open_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_open_ext(git_repository **out, const char *path, unsigned int flags, const char *ceiling_dirs)
     * }
     */
    public static FunctionDescriptor git_repository_open_ext$descriptor() {
        return git_repository_open_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_open_ext(git_repository **out, const char *path, unsigned int flags, const char *ceiling_dirs)
     * }
     */
    public static MethodHandle git_repository_open_ext$handle() {
        return git_repository_open_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_open_ext(git_repository **out, const char *path, unsigned int flags, const char *ceiling_dirs)
     * }
     */
    public static MemorySegment git_repository_open_ext$address() {
        return git_repository_open_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_open_ext(git_repository **out, const char *path, unsigned int flags, const char *ceiling_dirs)
     * }
     */
    public static int git_repository_open_ext(MemorySegment out, MemorySegment path, int flags, MemorySegment ceiling_dirs) {
        var mh$ = git_repository_open_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_open_ext", out, path, flags, ceiling_dirs);
            }
            return (int)mh$.invokeExact(out, path, flags, ceiling_dirs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_open_bare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_open_bare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_open_bare(git_repository **out, const char *bare_path)
     * }
     */
    public static FunctionDescriptor git_repository_open_bare$descriptor() {
        return git_repository_open_bare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_open_bare(git_repository **out, const char *bare_path)
     * }
     */
    public static MethodHandle git_repository_open_bare$handle() {
        return git_repository_open_bare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_open_bare(git_repository **out, const char *bare_path)
     * }
     */
    public static MemorySegment git_repository_open_bare$address() {
        return git_repository_open_bare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_open_bare(git_repository **out, const char *bare_path)
     * }
     */
    public static int git_repository_open_bare(MemorySegment out, MemorySegment bare_path) {
        var mh$ = git_repository_open_bare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_open_bare", out, bare_path);
            }
            return (int)mh$.invokeExact(out, bare_path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_repository_free(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_free$descriptor() {
        return git_repository_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_repository_free(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_free$handle() {
        return git_repository_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_repository_free(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_free$address() {
        return git_repository_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_repository_free(git_repository *repo)
     * }
     */
    public static void git_repository_free(MemorySegment repo) {
        var mh$ = git_repository_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_free", repo);
            }
            mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_init(git_repository **out, const char *path, unsigned int is_bare)
     * }
     */
    public static FunctionDescriptor git_repository_init$descriptor() {
        return git_repository_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_init(git_repository **out, const char *path, unsigned int is_bare)
     * }
     */
    public static MethodHandle git_repository_init$handle() {
        return git_repository_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_init(git_repository **out, const char *path, unsigned int is_bare)
     * }
     */
    public static MemorySegment git_repository_init$address() {
        return git_repository_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_init(git_repository **out, const char *path, unsigned int is_bare)
     * }
     */
    public static int git_repository_init(MemorySegment out, MemorySegment path, int is_bare) {
        var mh$ = git_repository_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_init", out, path, is_bare);
            }
            return (int)mh$.invokeExact(out, path, is_bare);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_REPOSITORY_INIT_BARE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_INIT_BARE = 1
     * }
     */
    public static int GIT_REPOSITORY_INIT_BARE() {
        return GIT_REPOSITORY_INIT_BARE;
    }
    private static final int GIT_REPOSITORY_INIT_NO_REINIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_INIT_NO_REINIT = 2
     * }
     */
    public static int GIT_REPOSITORY_INIT_NO_REINIT() {
        return GIT_REPOSITORY_INIT_NO_REINIT;
    }
    private static final int GIT_REPOSITORY_INIT_NO_DOTGIT_DIR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_INIT_NO_DOTGIT_DIR = 4
     * }
     */
    public static int GIT_REPOSITORY_INIT_NO_DOTGIT_DIR() {
        return GIT_REPOSITORY_INIT_NO_DOTGIT_DIR;
    }
    private static final int GIT_REPOSITORY_INIT_MKDIR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_INIT_MKDIR = 8
     * }
     */
    public static int GIT_REPOSITORY_INIT_MKDIR() {
        return GIT_REPOSITORY_INIT_MKDIR;
    }
    private static final int GIT_REPOSITORY_INIT_MKPATH = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_INIT_MKPATH = 16
     * }
     */
    public static int GIT_REPOSITORY_INIT_MKPATH() {
        return GIT_REPOSITORY_INIT_MKPATH;
    }
    private static final int GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE = 32
     * }
     */
    public static int GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE() {
        return GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE;
    }
    private static final int GIT_REPOSITORY_INIT_RELATIVE_GITLINK = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_INIT_RELATIVE_GITLINK = 64
     * }
     */
    public static int GIT_REPOSITORY_INIT_RELATIVE_GITLINK() {
        return GIT_REPOSITORY_INIT_RELATIVE_GITLINK;
    }
    private static final int GIT_REPOSITORY_INIT_SHARED_UMASK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_INIT_SHARED_UMASK = 0
     * }
     */
    public static int GIT_REPOSITORY_INIT_SHARED_UMASK() {
        return GIT_REPOSITORY_INIT_SHARED_UMASK;
    }
    private static final int GIT_REPOSITORY_INIT_SHARED_GROUP = (int)1533L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_INIT_SHARED_GROUP = 1533
     * }
     */
    public static int GIT_REPOSITORY_INIT_SHARED_GROUP() {
        return GIT_REPOSITORY_INIT_SHARED_GROUP;
    }
    private static final int GIT_REPOSITORY_INIT_SHARED_ALL = (int)1535L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_INIT_SHARED_ALL = 1535
     * }
     */
    public static int GIT_REPOSITORY_INIT_SHARED_ALL() {
        return GIT_REPOSITORY_INIT_SHARED_ALL;
    }

    private static class git_repository_init_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_init_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_init_options_init(git_repository_init_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_repository_init_options_init$descriptor() {
        return git_repository_init_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_init_options_init(git_repository_init_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_repository_init_options_init$handle() {
        return git_repository_init_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_init_options_init(git_repository_init_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_repository_init_options_init$address() {
        return git_repository_init_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_init_options_init(git_repository_init_options *opts, unsigned int version)
     * }
     */
    public static int git_repository_init_options_init(MemorySegment opts, int version) {
        var mh$ = git_repository_init_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_init_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_init_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_init_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_init_ext(git_repository **out, const char *repo_path, git_repository_init_options *opts)
     * }
     */
    public static FunctionDescriptor git_repository_init_ext$descriptor() {
        return git_repository_init_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_init_ext(git_repository **out, const char *repo_path, git_repository_init_options *opts)
     * }
     */
    public static MethodHandle git_repository_init_ext$handle() {
        return git_repository_init_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_init_ext(git_repository **out, const char *repo_path, git_repository_init_options *opts)
     * }
     */
    public static MemorySegment git_repository_init_ext$address() {
        return git_repository_init_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_init_ext(git_repository **out, const char *repo_path, git_repository_init_options *opts)
     * }
     */
    public static int git_repository_init_ext(MemorySegment out, MemorySegment repo_path, MemorySegment opts) {
        var mh$ = git_repository_init_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_init_ext", out, repo_path, opts);
            }
            return (int)mh$.invokeExact(out, repo_path, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_head(git_reference **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_head$descriptor() {
        return git_repository_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_head(git_reference **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_head$handle() {
        return git_repository_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_head(git_reference **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_head$address() {
        return git_repository_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_head(git_reference **out, git_repository *repo)
     * }
     */
    public static int git_repository_head(MemorySegment out, MemorySegment repo) {
        var mh$ = git_repository_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_head", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_head_for_worktree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_head_for_worktree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_head_for_worktree(git_reference **out, git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_repository_head_for_worktree$descriptor() {
        return git_repository_head_for_worktree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_head_for_worktree(git_reference **out, git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_repository_head_for_worktree$handle() {
        return git_repository_head_for_worktree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_head_for_worktree(git_reference **out, git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_repository_head_for_worktree$address() {
        return git_repository_head_for_worktree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_head_for_worktree(git_reference **out, git_repository *repo, const char *name)
     * }
     */
    public static int git_repository_head_for_worktree(MemorySegment out, MemorySegment repo, MemorySegment name) {
        var mh$ = git_repository_head_for_worktree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_head_for_worktree", out, repo, name);
            }
            return (int)mh$.invokeExact(out, repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_head_detached {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_head_detached");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_head_detached(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_head_detached$descriptor() {
        return git_repository_head_detached.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_head_detached(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_head_detached$handle() {
        return git_repository_head_detached.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_head_detached(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_head_detached$address() {
        return git_repository_head_detached.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_head_detached(git_repository *repo)
     * }
     */
    public static int git_repository_head_detached(MemorySegment repo) {
        var mh$ = git_repository_head_detached.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_head_detached", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_head_detached_for_worktree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_head_detached_for_worktree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_head_detached_for_worktree(git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_repository_head_detached_for_worktree$descriptor() {
        return git_repository_head_detached_for_worktree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_head_detached_for_worktree(git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_repository_head_detached_for_worktree$handle() {
        return git_repository_head_detached_for_worktree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_head_detached_for_worktree(git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_repository_head_detached_for_worktree$address() {
        return git_repository_head_detached_for_worktree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_head_detached_for_worktree(git_repository *repo, const char *name)
     * }
     */
    public static int git_repository_head_detached_for_worktree(MemorySegment repo, MemorySegment name) {
        var mh$ = git_repository_head_detached_for_worktree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_head_detached_for_worktree", repo, name);
            }
            return (int)mh$.invokeExact(repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_head_unborn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_head_unborn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_head_unborn(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_head_unborn$descriptor() {
        return git_repository_head_unborn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_head_unborn(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_head_unborn$handle() {
        return git_repository_head_unborn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_head_unborn(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_head_unborn$address() {
        return git_repository_head_unborn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_head_unborn(git_repository *repo)
     * }
     */
    public static int git_repository_head_unborn(MemorySegment repo) {
        var mh$ = git_repository_head_unborn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_head_unborn", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_is_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_is_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_is_empty(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_is_empty$descriptor() {
        return git_repository_is_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_is_empty(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_is_empty$handle() {
        return git_repository_is_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_is_empty(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_is_empty$address() {
        return git_repository_is_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_is_empty(git_repository *repo)
     * }
     */
    public static int git_repository_is_empty(MemorySegment repo) {
        var mh$ = git_repository_is_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_is_empty", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_REPOSITORY_ITEM_GITDIR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_GITDIR = 0
     * }
     */
    public static int GIT_REPOSITORY_ITEM_GITDIR() {
        return GIT_REPOSITORY_ITEM_GITDIR;
    }
    private static final int GIT_REPOSITORY_ITEM_WORKDIR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_WORKDIR = 1
     * }
     */
    public static int GIT_REPOSITORY_ITEM_WORKDIR() {
        return GIT_REPOSITORY_ITEM_WORKDIR;
    }
    private static final int GIT_REPOSITORY_ITEM_COMMONDIR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_COMMONDIR = 2
     * }
     */
    public static int GIT_REPOSITORY_ITEM_COMMONDIR() {
        return GIT_REPOSITORY_ITEM_COMMONDIR;
    }
    private static final int GIT_REPOSITORY_ITEM_INDEX = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_INDEX = 3
     * }
     */
    public static int GIT_REPOSITORY_ITEM_INDEX() {
        return GIT_REPOSITORY_ITEM_INDEX;
    }
    private static final int GIT_REPOSITORY_ITEM_OBJECTS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_OBJECTS = 4
     * }
     */
    public static int GIT_REPOSITORY_ITEM_OBJECTS() {
        return GIT_REPOSITORY_ITEM_OBJECTS;
    }
    private static final int GIT_REPOSITORY_ITEM_REFS = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_REFS = 5
     * }
     */
    public static int GIT_REPOSITORY_ITEM_REFS() {
        return GIT_REPOSITORY_ITEM_REFS;
    }
    private static final int GIT_REPOSITORY_ITEM_PACKED_REFS = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_PACKED_REFS = 6
     * }
     */
    public static int GIT_REPOSITORY_ITEM_PACKED_REFS() {
        return GIT_REPOSITORY_ITEM_PACKED_REFS;
    }
    private static final int GIT_REPOSITORY_ITEM_REMOTES = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_REMOTES = 7
     * }
     */
    public static int GIT_REPOSITORY_ITEM_REMOTES() {
        return GIT_REPOSITORY_ITEM_REMOTES;
    }
    private static final int GIT_REPOSITORY_ITEM_CONFIG = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_CONFIG = 8
     * }
     */
    public static int GIT_REPOSITORY_ITEM_CONFIG() {
        return GIT_REPOSITORY_ITEM_CONFIG;
    }
    private static final int GIT_REPOSITORY_ITEM_INFO = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_INFO = 9
     * }
     */
    public static int GIT_REPOSITORY_ITEM_INFO() {
        return GIT_REPOSITORY_ITEM_INFO;
    }
    private static final int GIT_REPOSITORY_ITEM_HOOKS = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_HOOKS = 10
     * }
     */
    public static int GIT_REPOSITORY_ITEM_HOOKS() {
        return GIT_REPOSITORY_ITEM_HOOKS;
    }
    private static final int GIT_REPOSITORY_ITEM_LOGS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_LOGS = 11
     * }
     */
    public static int GIT_REPOSITORY_ITEM_LOGS() {
        return GIT_REPOSITORY_ITEM_LOGS;
    }
    private static final int GIT_REPOSITORY_ITEM_MODULES = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_MODULES = 12
     * }
     */
    public static int GIT_REPOSITORY_ITEM_MODULES() {
        return GIT_REPOSITORY_ITEM_MODULES;
    }
    private static final int GIT_REPOSITORY_ITEM_WORKTREES = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_WORKTREES = 13
     * }
     */
    public static int GIT_REPOSITORY_ITEM_WORKTREES() {
        return GIT_REPOSITORY_ITEM_WORKTREES;
    }
    private static final int GIT_REPOSITORY_ITEM_WORKTREE_CONFIG = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM_WORKTREE_CONFIG = 14
     * }
     */
    public static int GIT_REPOSITORY_ITEM_WORKTREE_CONFIG() {
        return GIT_REPOSITORY_ITEM_WORKTREE_CONFIG;
    }
    private static final int GIT_REPOSITORY_ITEM__LAST = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_ITEM__LAST = 15
     * }
     */
    public static int GIT_REPOSITORY_ITEM__LAST() {
        return GIT_REPOSITORY_ITEM__LAST;
    }

    private static class git_repository_item_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_item_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_item_path(git_buf *out, const git_repository *repo, git_repository_item_t item)
     * }
     */
    public static FunctionDescriptor git_repository_item_path$descriptor() {
        return git_repository_item_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_item_path(git_buf *out, const git_repository *repo, git_repository_item_t item)
     * }
     */
    public static MethodHandle git_repository_item_path$handle() {
        return git_repository_item_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_item_path(git_buf *out, const git_repository *repo, git_repository_item_t item)
     * }
     */
    public static MemorySegment git_repository_item_path$address() {
        return git_repository_item_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_item_path(git_buf *out, const git_repository *repo, git_repository_item_t item)
     * }
     */
    public static int git_repository_item_path(MemorySegment out, MemorySegment repo, int item) {
        var mh$ = git_repository_item_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_item_path", out, repo, item);
            }
            return (int)mh$.invokeExact(out, repo, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_repository_path(const git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_path$descriptor() {
        return git_repository_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_repository_path(const git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_path$handle() {
        return git_repository_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_repository_path(const git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_path$address() {
        return git_repository_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_repository_path(const git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_path(MemorySegment repo) {
        var mh$ = git_repository_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_path", repo);
            }
            return (MemorySegment)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_workdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_workdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_repository_workdir(const git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_workdir$descriptor() {
        return git_repository_workdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_repository_workdir(const git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_workdir$handle() {
        return git_repository_workdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_repository_workdir(const git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_workdir$address() {
        return git_repository_workdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_repository_workdir(const git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_workdir(MemorySegment repo) {
        var mh$ = git_repository_workdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_workdir", repo);
            }
            return (MemorySegment)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_commondir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_commondir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_repository_commondir(const git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_commondir$descriptor() {
        return git_repository_commondir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_repository_commondir(const git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_commondir$handle() {
        return git_repository_commondir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_repository_commondir(const git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_commondir$address() {
        return git_repository_commondir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_repository_commondir(const git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_commondir(MemorySegment repo) {
        var mh$ = git_repository_commondir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_commondir", repo);
            }
            return (MemorySegment)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_set_workdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_set_workdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_set_workdir(git_repository *repo, const char *workdir, int update_gitlink)
     * }
     */
    public static FunctionDescriptor git_repository_set_workdir$descriptor() {
        return git_repository_set_workdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_set_workdir(git_repository *repo, const char *workdir, int update_gitlink)
     * }
     */
    public static MethodHandle git_repository_set_workdir$handle() {
        return git_repository_set_workdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_set_workdir(git_repository *repo, const char *workdir, int update_gitlink)
     * }
     */
    public static MemorySegment git_repository_set_workdir$address() {
        return git_repository_set_workdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_set_workdir(git_repository *repo, const char *workdir, int update_gitlink)
     * }
     */
    public static int git_repository_set_workdir(MemorySegment repo, MemorySegment workdir, int update_gitlink) {
        var mh$ = git_repository_set_workdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_set_workdir", repo, workdir, update_gitlink);
            }
            return (int)mh$.invokeExact(repo, workdir, update_gitlink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_is_bare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_is_bare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_is_bare(const git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_is_bare$descriptor() {
        return git_repository_is_bare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_is_bare(const git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_is_bare$handle() {
        return git_repository_is_bare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_is_bare(const git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_is_bare$address() {
        return git_repository_is_bare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_is_bare(const git_repository *repo)
     * }
     */
    public static int git_repository_is_bare(MemorySegment repo) {
        var mh$ = git_repository_is_bare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_is_bare", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_is_worktree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_is_worktree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_is_worktree(const git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_is_worktree$descriptor() {
        return git_repository_is_worktree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_is_worktree(const git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_is_worktree$handle() {
        return git_repository_is_worktree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_is_worktree(const git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_is_worktree$address() {
        return git_repository_is_worktree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_is_worktree(const git_repository *repo)
     * }
     */
    public static int git_repository_is_worktree(MemorySegment repo) {
        var mh$ = git_repository_is_worktree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_is_worktree", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_config(git_config **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_config$descriptor() {
        return git_repository_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_config(git_config **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_config$handle() {
        return git_repository_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_config(git_config **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_config$address() {
        return git_repository_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_config(git_config **out, git_repository *repo)
     * }
     */
    public static int git_repository_config(MemorySegment out, MemorySegment repo) {
        var mh$ = git_repository_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_config", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_config_snapshot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_config_snapshot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_config_snapshot(git_config **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_config_snapshot$descriptor() {
        return git_repository_config_snapshot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_config_snapshot(git_config **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_config_snapshot$handle() {
        return git_repository_config_snapshot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_config_snapshot(git_config **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_config_snapshot$address() {
        return git_repository_config_snapshot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_config_snapshot(git_config **out, git_repository *repo)
     * }
     */
    public static int git_repository_config_snapshot(MemorySegment out, MemorySegment repo) {
        var mh$ = git_repository_config_snapshot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_config_snapshot", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_odb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_odb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_odb(git_odb **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_odb$descriptor() {
        return git_repository_odb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_odb(git_odb **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_odb$handle() {
        return git_repository_odb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_odb(git_odb **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_odb$address() {
        return git_repository_odb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_odb(git_odb **out, git_repository *repo)
     * }
     */
    public static int git_repository_odb(MemorySegment out, MemorySegment repo) {
        var mh$ = git_repository_odb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_odb", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_refdb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_refdb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_refdb(git_refdb **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_refdb$descriptor() {
        return git_repository_refdb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_refdb(git_refdb **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_refdb$handle() {
        return git_repository_refdb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_refdb(git_refdb **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_refdb$address() {
        return git_repository_refdb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_refdb(git_refdb **out, git_repository *repo)
     * }
     */
    public static int git_repository_refdb(MemorySegment out, MemorySegment repo) {
        var mh$ = git_repository_refdb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_refdb", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_index(git_index **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_index$descriptor() {
        return git_repository_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_index(git_index **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_index$handle() {
        return git_repository_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_index(git_index **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_index$address() {
        return git_repository_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_index(git_index **out, git_repository *repo)
     * }
     */
    public static int git_repository_index(MemorySegment out, MemorySegment repo) {
        var mh$ = git_repository_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_index", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_message(git_buf *out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_message$descriptor() {
        return git_repository_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_message(git_buf *out, git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_message$handle() {
        return git_repository_message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_message(git_buf *out, git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_message$address() {
        return git_repository_message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_message(git_buf *out, git_repository *repo)
     * }
     */
    public static int git_repository_message(MemorySegment out, MemorySegment repo) {
        var mh$ = git_repository_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_message", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_message_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_message_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_message_remove(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_message_remove$descriptor() {
        return git_repository_message_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_message_remove(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_message_remove$handle() {
        return git_repository_message_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_message_remove(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_message_remove$address() {
        return git_repository_message_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_message_remove(git_repository *repo)
     * }
     */
    public static int git_repository_message_remove(MemorySegment repo) {
        var mh$ = git_repository_message_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_message_remove", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_state_cleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_state_cleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_state_cleanup(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_state_cleanup$descriptor() {
        return git_repository_state_cleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_state_cleanup(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_state_cleanup$handle() {
        return git_repository_state_cleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_state_cleanup(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_state_cleanup$address() {
        return git_repository_state_cleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_state_cleanup(git_repository *repo)
     * }
     */
    public static int git_repository_state_cleanup(MemorySegment repo) {
        var mh$ = git_repository_state_cleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_state_cleanup", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_fetchhead_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_fetchhead_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_fetchhead_foreach(git_repository *repo, git_repository_fetchhead_foreach_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_repository_fetchhead_foreach$descriptor() {
        return git_repository_fetchhead_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_fetchhead_foreach(git_repository *repo, git_repository_fetchhead_foreach_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_repository_fetchhead_foreach$handle() {
        return git_repository_fetchhead_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_fetchhead_foreach(git_repository *repo, git_repository_fetchhead_foreach_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_repository_fetchhead_foreach$address() {
        return git_repository_fetchhead_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_fetchhead_foreach(git_repository *repo, git_repository_fetchhead_foreach_cb callback, void *payload)
     * }
     */
    public static int git_repository_fetchhead_foreach(MemorySegment repo, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_repository_fetchhead_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_fetchhead_foreach", repo, callback, payload);
            }
            return (int)mh$.invokeExact(repo, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_mergehead_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_mergehead_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_mergehead_foreach(git_repository *repo, git_repository_mergehead_foreach_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_repository_mergehead_foreach$descriptor() {
        return git_repository_mergehead_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_mergehead_foreach(git_repository *repo, git_repository_mergehead_foreach_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_repository_mergehead_foreach$handle() {
        return git_repository_mergehead_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_mergehead_foreach(git_repository *repo, git_repository_mergehead_foreach_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_repository_mergehead_foreach$address() {
        return git_repository_mergehead_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_mergehead_foreach(git_repository *repo, git_repository_mergehead_foreach_cb callback, void *payload)
     * }
     */
    public static int git_repository_mergehead_foreach(MemorySegment repo, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_repository_mergehead_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_mergehead_foreach", repo, callback, payload);
            }
            return (int)mh$.invokeExact(repo, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_hashfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_hashfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_hashfile(git_oid *out, git_repository *repo, const char *path, git_object_t type, const char *as_path)
     * }
     */
    public static FunctionDescriptor git_repository_hashfile$descriptor() {
        return git_repository_hashfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_hashfile(git_oid *out, git_repository *repo, const char *path, git_object_t type, const char *as_path)
     * }
     */
    public static MethodHandle git_repository_hashfile$handle() {
        return git_repository_hashfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_hashfile(git_oid *out, git_repository *repo, const char *path, git_object_t type, const char *as_path)
     * }
     */
    public static MemorySegment git_repository_hashfile$address() {
        return git_repository_hashfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_hashfile(git_oid *out, git_repository *repo, const char *path, git_object_t type, const char *as_path)
     * }
     */
    public static int git_repository_hashfile(MemorySegment out, MemorySegment repo, MemorySegment path, int type, MemorySegment as_path) {
        var mh$ = git_repository_hashfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_hashfile", out, repo, path, type, as_path);
            }
            return (int)mh$.invokeExact(out, repo, path, type, as_path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_set_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_set_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_set_head(git_repository *repo, const char *refname)
     * }
     */
    public static FunctionDescriptor git_repository_set_head$descriptor() {
        return git_repository_set_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_set_head(git_repository *repo, const char *refname)
     * }
     */
    public static MethodHandle git_repository_set_head$handle() {
        return git_repository_set_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_set_head(git_repository *repo, const char *refname)
     * }
     */
    public static MemorySegment git_repository_set_head$address() {
        return git_repository_set_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_set_head(git_repository *repo, const char *refname)
     * }
     */
    public static int git_repository_set_head(MemorySegment repo, MemorySegment refname) {
        var mh$ = git_repository_set_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_set_head", repo, refname);
            }
            return (int)mh$.invokeExact(repo, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_set_head_detached {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_set_head_detached");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_set_head_detached(git_repository *repo, const git_oid *committish)
     * }
     */
    public static FunctionDescriptor git_repository_set_head_detached$descriptor() {
        return git_repository_set_head_detached.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_set_head_detached(git_repository *repo, const git_oid *committish)
     * }
     */
    public static MethodHandle git_repository_set_head_detached$handle() {
        return git_repository_set_head_detached.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_set_head_detached(git_repository *repo, const git_oid *committish)
     * }
     */
    public static MemorySegment git_repository_set_head_detached$address() {
        return git_repository_set_head_detached.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_set_head_detached(git_repository *repo, const git_oid *committish)
     * }
     */
    public static int git_repository_set_head_detached(MemorySegment repo, MemorySegment committish) {
        var mh$ = git_repository_set_head_detached.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_set_head_detached", repo, committish);
            }
            return (int)mh$.invokeExact(repo, committish);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_set_head_detached_from_annotated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_set_head_detached_from_annotated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_set_head_detached_from_annotated(git_repository *repo, const git_annotated_commit *committish)
     * }
     */
    public static FunctionDescriptor git_repository_set_head_detached_from_annotated$descriptor() {
        return git_repository_set_head_detached_from_annotated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_set_head_detached_from_annotated(git_repository *repo, const git_annotated_commit *committish)
     * }
     */
    public static MethodHandle git_repository_set_head_detached_from_annotated$handle() {
        return git_repository_set_head_detached_from_annotated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_set_head_detached_from_annotated(git_repository *repo, const git_annotated_commit *committish)
     * }
     */
    public static MemorySegment git_repository_set_head_detached_from_annotated$address() {
        return git_repository_set_head_detached_from_annotated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_set_head_detached_from_annotated(git_repository *repo, const git_annotated_commit *committish)
     * }
     */
    public static int git_repository_set_head_detached_from_annotated(MemorySegment repo, MemorySegment committish) {
        var mh$ = git_repository_set_head_detached_from_annotated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_set_head_detached_from_annotated", repo, committish);
            }
            return (int)mh$.invokeExact(repo, committish);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_detach_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_detach_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_detach_head(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_detach_head$descriptor() {
        return git_repository_detach_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_detach_head(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_detach_head$handle() {
        return git_repository_detach_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_detach_head(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_detach_head$address() {
        return git_repository_detach_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_detach_head(git_repository *repo)
     * }
     */
    public static int git_repository_detach_head(MemorySegment repo) {
        var mh$ = git_repository_detach_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_detach_head", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_REPOSITORY_STATE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_NONE = 0
     * }
     */
    public static int GIT_REPOSITORY_STATE_NONE() {
        return GIT_REPOSITORY_STATE_NONE;
    }
    private static final int GIT_REPOSITORY_STATE_MERGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_MERGE = 1
     * }
     */
    public static int GIT_REPOSITORY_STATE_MERGE() {
        return GIT_REPOSITORY_STATE_MERGE;
    }
    private static final int GIT_REPOSITORY_STATE_REVERT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_REVERT = 2
     * }
     */
    public static int GIT_REPOSITORY_STATE_REVERT() {
        return GIT_REPOSITORY_STATE_REVERT;
    }
    private static final int GIT_REPOSITORY_STATE_REVERT_SEQUENCE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_REVERT_SEQUENCE = 3
     * }
     */
    public static int GIT_REPOSITORY_STATE_REVERT_SEQUENCE() {
        return GIT_REPOSITORY_STATE_REVERT_SEQUENCE;
    }
    private static final int GIT_REPOSITORY_STATE_CHERRYPICK = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_CHERRYPICK = 4
     * }
     */
    public static int GIT_REPOSITORY_STATE_CHERRYPICK() {
        return GIT_REPOSITORY_STATE_CHERRYPICK;
    }
    private static final int GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE = 5
     * }
     */
    public static int GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE() {
        return GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE;
    }
    private static final int GIT_REPOSITORY_STATE_BISECT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_BISECT = 6
     * }
     */
    public static int GIT_REPOSITORY_STATE_BISECT() {
        return GIT_REPOSITORY_STATE_BISECT;
    }
    private static final int GIT_REPOSITORY_STATE_REBASE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_REBASE = 7
     * }
     */
    public static int GIT_REPOSITORY_STATE_REBASE() {
        return GIT_REPOSITORY_STATE_REBASE;
    }
    private static final int GIT_REPOSITORY_STATE_REBASE_INTERACTIVE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_REBASE_INTERACTIVE = 8
     * }
     */
    public static int GIT_REPOSITORY_STATE_REBASE_INTERACTIVE() {
        return GIT_REPOSITORY_STATE_REBASE_INTERACTIVE;
    }
    private static final int GIT_REPOSITORY_STATE_REBASE_MERGE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_REBASE_MERGE = 9
     * }
     */
    public static int GIT_REPOSITORY_STATE_REBASE_MERGE() {
        return GIT_REPOSITORY_STATE_REBASE_MERGE;
    }
    private static final int GIT_REPOSITORY_STATE_APPLY_MAILBOX = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_APPLY_MAILBOX = 10
     * }
     */
    public static int GIT_REPOSITORY_STATE_APPLY_MAILBOX() {
        return GIT_REPOSITORY_STATE_APPLY_MAILBOX;
    }
    private static final int GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE = 11
     * }
     */
    public static int GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE() {
        return GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE;
    }

    private static class git_repository_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_state");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_state(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_state$descriptor() {
        return git_repository_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_state(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_state$handle() {
        return git_repository_state.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_state(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_state$address() {
        return git_repository_state.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_state(git_repository *repo)
     * }
     */
    public static int git_repository_state(MemorySegment repo) {
        var mh$ = git_repository_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_state", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_set_namespace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_set_namespace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_set_namespace(git_repository *repo, const char *nmspace)
     * }
     */
    public static FunctionDescriptor git_repository_set_namespace$descriptor() {
        return git_repository_set_namespace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_set_namespace(git_repository *repo, const char *nmspace)
     * }
     */
    public static MethodHandle git_repository_set_namespace$handle() {
        return git_repository_set_namespace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_set_namespace(git_repository *repo, const char *nmspace)
     * }
     */
    public static MemorySegment git_repository_set_namespace$address() {
        return git_repository_set_namespace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_set_namespace(git_repository *repo, const char *nmspace)
     * }
     */
    public static int git_repository_set_namespace(MemorySegment repo, MemorySegment nmspace) {
        var mh$ = git_repository_set_namespace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_set_namespace", repo, nmspace);
            }
            return (int)mh$.invokeExact(repo, nmspace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_get_namespace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_get_namespace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_repository_get_namespace(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_get_namespace$descriptor() {
        return git_repository_get_namespace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_repository_get_namespace(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_get_namespace$handle() {
        return git_repository_get_namespace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_repository_get_namespace(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_get_namespace$address() {
        return git_repository_get_namespace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_repository_get_namespace(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_get_namespace(MemorySegment repo) {
        var mh$ = git_repository_get_namespace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_get_namespace", repo);
            }
            return (MemorySegment)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_is_shallow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_is_shallow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_is_shallow(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_is_shallow$descriptor() {
        return git_repository_is_shallow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_is_shallow(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_is_shallow$handle() {
        return git_repository_is_shallow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_is_shallow(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_is_shallow$address() {
        return git_repository_is_shallow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_is_shallow(git_repository *repo)
     * }
     */
    public static int git_repository_is_shallow(MemorySegment repo) {
        var mh$ = git_repository_is_shallow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_is_shallow", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_ident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_ident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_ident(const char **name, const char **email, const git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_ident$descriptor() {
        return git_repository_ident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_ident(const char **name, const char **email, const git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_ident$handle() {
        return git_repository_ident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_ident(const char **name, const char **email, const git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_ident$address() {
        return git_repository_ident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_ident(const char **name, const char **email, const git_repository *repo)
     * }
     */
    public static int git_repository_ident(MemorySegment name, MemorySegment email, MemorySegment repo) {
        var mh$ = git_repository_ident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_ident", name, email, repo);
            }
            return (int)mh$.invokeExact(name, email, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_set_ident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_set_ident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_set_ident(git_repository *repo, const char *name, const char *email)
     * }
     */
    public static FunctionDescriptor git_repository_set_ident$descriptor() {
        return git_repository_set_ident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_set_ident(git_repository *repo, const char *name, const char *email)
     * }
     */
    public static MethodHandle git_repository_set_ident$handle() {
        return git_repository_set_ident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_set_ident(git_repository *repo, const char *name, const char *email)
     * }
     */
    public static MemorySegment git_repository_set_ident$address() {
        return git_repository_set_ident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_set_ident(git_repository *repo, const char *name, const char *email)
     * }
     */
    public static int git_repository_set_ident(MemorySegment repo, MemorySegment name, MemorySegment email) {
        var mh$ = git_repository_set_ident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_set_ident", repo, name, email);
            }
            return (int)mh$.invokeExact(repo, name, email);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_oid_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_oid_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_oid_t git_repository_oid_type(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_oid_type$descriptor() {
        return git_repository_oid_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_oid_t git_repository_oid_type(git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_oid_type$handle() {
        return git_repository_oid_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_oid_t git_repository_oid_type(git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_oid_type$address() {
        return git_repository_oid_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_oid_t git_repository_oid_type(git_repository *repo)
     * }
     */
    public static int git_repository_oid_type(MemorySegment repo) {
        var mh$ = git_repository_oid_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_oid_type", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_commit_parents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_commit_parents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_commit_parents(git_commitarray *commits, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_repository_commit_parents$descriptor() {
        return git_repository_commit_parents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_commit_parents(git_commitarray *commits, git_repository *repo)
     * }
     */
    public static MethodHandle git_repository_commit_parents$handle() {
        return git_repository_commit_parents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_commit_parents(git_commitarray *commits, git_repository *repo)
     * }
     */
    public static MemorySegment git_repository_commit_parents$address() {
        return git_repository_commit_parents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_commit_parents(git_commitarray *commits, git_repository *repo)
     * }
     */
    public static int git_repository_commit_parents(MemorySegment commits, MemorySegment repo) {
        var mh$ = git_repository_commit_parents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_commit_parents", commits, repo);
            }
            return (int)mh$.invokeExact(commits, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_annotated_commit_from_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_annotated_commit_from_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_ref(git_annotated_commit **out, git_repository *repo, const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_annotated_commit_from_ref$descriptor() {
        return git_annotated_commit_from_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_ref(git_annotated_commit **out, git_repository *repo, const git_reference *ref)
     * }
     */
    public static MethodHandle git_annotated_commit_from_ref$handle() {
        return git_annotated_commit_from_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_ref(git_annotated_commit **out, git_repository *repo, const git_reference *ref)
     * }
     */
    public static MemorySegment git_annotated_commit_from_ref$address() {
        return git_annotated_commit_from_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_ref(git_annotated_commit **out, git_repository *repo, const git_reference *ref)
     * }
     */
    public static int git_annotated_commit_from_ref(MemorySegment out, MemorySegment repo, MemorySegment ref) {
        var mh$ = git_annotated_commit_from_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_annotated_commit_from_ref", out, repo, ref);
            }
            return (int)mh$.invokeExact(out, repo, ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_annotated_commit_from_fetchhead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_annotated_commit_from_fetchhead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_fetchhead(git_annotated_commit **out, git_repository *repo, const char *branch_name, const char *remote_url, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_annotated_commit_from_fetchhead$descriptor() {
        return git_annotated_commit_from_fetchhead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_fetchhead(git_annotated_commit **out, git_repository *repo, const char *branch_name, const char *remote_url, const git_oid *id)
     * }
     */
    public static MethodHandle git_annotated_commit_from_fetchhead$handle() {
        return git_annotated_commit_from_fetchhead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_fetchhead(git_annotated_commit **out, git_repository *repo, const char *branch_name, const char *remote_url, const git_oid *id)
     * }
     */
    public static MemorySegment git_annotated_commit_from_fetchhead$address() {
        return git_annotated_commit_from_fetchhead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_fetchhead(git_annotated_commit **out, git_repository *repo, const char *branch_name, const char *remote_url, const git_oid *id)
     * }
     */
    public static int git_annotated_commit_from_fetchhead(MemorySegment out, MemorySegment repo, MemorySegment branch_name, MemorySegment remote_url, MemorySegment id) {
        var mh$ = git_annotated_commit_from_fetchhead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_annotated_commit_from_fetchhead", out, repo, branch_name, remote_url, id);
            }
            return (int)mh$.invokeExact(out, repo, branch_name, remote_url, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_annotated_commit_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_annotated_commit_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_lookup(git_annotated_commit **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_annotated_commit_lookup$descriptor() {
        return git_annotated_commit_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_lookup(git_annotated_commit **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static MethodHandle git_annotated_commit_lookup$handle() {
        return git_annotated_commit_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_lookup(git_annotated_commit **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static MemorySegment git_annotated_commit_lookup$address() {
        return git_annotated_commit_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_annotated_commit_lookup(git_annotated_commit **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static int git_annotated_commit_lookup(MemorySegment out, MemorySegment repo, MemorySegment id) {
        var mh$ = git_annotated_commit_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_annotated_commit_lookup", out, repo, id);
            }
            return (int)mh$.invokeExact(out, repo, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_annotated_commit_from_revspec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_annotated_commit_from_revspec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_revspec(git_annotated_commit **out, git_repository *repo, const char *revspec)
     * }
     */
    public static FunctionDescriptor git_annotated_commit_from_revspec$descriptor() {
        return git_annotated_commit_from_revspec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_revspec(git_annotated_commit **out, git_repository *repo, const char *revspec)
     * }
     */
    public static MethodHandle git_annotated_commit_from_revspec$handle() {
        return git_annotated_commit_from_revspec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_revspec(git_annotated_commit **out, git_repository *repo, const char *revspec)
     * }
     */
    public static MemorySegment git_annotated_commit_from_revspec$address() {
        return git_annotated_commit_from_revspec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_annotated_commit_from_revspec(git_annotated_commit **out, git_repository *repo, const char *revspec)
     * }
     */
    public static int git_annotated_commit_from_revspec(MemorySegment out, MemorySegment repo, MemorySegment revspec) {
        var mh$ = git_annotated_commit_from_revspec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_annotated_commit_from_revspec", out, repo, revspec);
            }
            return (int)mh$.invokeExact(out, repo, revspec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_annotated_commit_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_annotated_commit_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_annotated_commit_id(const git_annotated_commit *commit)
     * }
     */
    public static FunctionDescriptor git_annotated_commit_id$descriptor() {
        return git_annotated_commit_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_annotated_commit_id(const git_annotated_commit *commit)
     * }
     */
    public static MethodHandle git_annotated_commit_id$handle() {
        return git_annotated_commit_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_annotated_commit_id(const git_annotated_commit *commit)
     * }
     */
    public static MemorySegment git_annotated_commit_id$address() {
        return git_annotated_commit_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_annotated_commit_id(const git_annotated_commit *commit)
     * }
     */
    public static MemorySegment git_annotated_commit_id(MemorySegment commit) {
        var mh$ = git_annotated_commit_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_annotated_commit_id", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_annotated_commit_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_annotated_commit_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_annotated_commit_ref(const git_annotated_commit *commit)
     * }
     */
    public static FunctionDescriptor git_annotated_commit_ref$descriptor() {
        return git_annotated_commit_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_annotated_commit_ref(const git_annotated_commit *commit)
     * }
     */
    public static MethodHandle git_annotated_commit_ref$handle() {
        return git_annotated_commit_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_annotated_commit_ref(const git_annotated_commit *commit)
     * }
     */
    public static MemorySegment git_annotated_commit_ref$address() {
        return git_annotated_commit_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_annotated_commit_ref(const git_annotated_commit *commit)
     * }
     */
    public static MemorySegment git_annotated_commit_ref(MemorySegment commit) {
        var mh$ = git_annotated_commit_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_annotated_commit_ref", commit);
            }
            return (MemorySegment)mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_annotated_commit_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_annotated_commit_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_annotated_commit_free(git_annotated_commit *commit)
     * }
     */
    public static FunctionDescriptor git_annotated_commit_free$descriptor() {
        return git_annotated_commit_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_annotated_commit_free(git_annotated_commit *commit)
     * }
     */
    public static MethodHandle git_annotated_commit_free$handle() {
        return git_annotated_commit_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_annotated_commit_free(git_annotated_commit *commit)
     * }
     */
    public static MemorySegment git_annotated_commit_free$address() {
        return git_annotated_commit_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_annotated_commit_free(git_annotated_commit *commit)
     * }
     */
    public static void git_annotated_commit_free(MemorySegment commit) {
        var mh$ = git_annotated_commit_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_annotated_commit_free", commit);
            }
            mh$.invokeExact(commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_tree_lookup$descriptor() {
        return git_tree_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static MethodHandle git_tree_lookup$handle() {
        return git_tree_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static MemorySegment git_tree_lookup$address() {
        return git_tree_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static int git_tree_lookup(MemorySegment out, MemorySegment repo, MemorySegment id) {
        var mh$ = git_tree_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_lookup", out, repo, id);
            }
            return (int)mh$.invokeExact(out, repo, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_lookup_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_lookup_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tree_lookup_prefix(git_tree **out, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static FunctionDescriptor git_tree_lookup_prefix$descriptor() {
        return git_tree_lookup_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tree_lookup_prefix(git_tree **out, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static MethodHandle git_tree_lookup_prefix$handle() {
        return git_tree_lookup_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tree_lookup_prefix(git_tree **out, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static MemorySegment git_tree_lookup_prefix$address() {
        return git_tree_lookup_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tree_lookup_prefix(git_tree **out, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static int git_tree_lookup_prefix(MemorySegment out, MemorySegment repo, MemorySegment id, long len) {
        var mh$ = git_tree_lookup_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_lookup_prefix", out, repo, id, len);
            }
            return (int)mh$.invokeExact(out, repo, id, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_tree_free(git_tree *tree)
     * }
     */
    public static FunctionDescriptor git_tree_free$descriptor() {
        return git_tree_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_tree_free(git_tree *tree)
     * }
     */
    public static MethodHandle git_tree_free$handle() {
        return git_tree_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_tree_free(git_tree *tree)
     * }
     */
    public static MemorySegment git_tree_free$address() {
        return git_tree_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_tree_free(git_tree *tree)
     * }
     */
    public static void git_tree_free(MemorySegment tree) {
        var mh$ = git_tree_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_free", tree);
            }
            mh$.invokeExact(tree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_tree_id(const git_tree *tree)
     * }
     */
    public static FunctionDescriptor git_tree_id$descriptor() {
        return git_tree_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_tree_id(const git_tree *tree)
     * }
     */
    public static MethodHandle git_tree_id$handle() {
        return git_tree_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_tree_id(const git_tree *tree)
     * }
     */
    public static MemorySegment git_tree_id$address() {
        return git_tree_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_tree_id(const git_tree *tree)
     * }
     */
    public static MemorySegment git_tree_id(MemorySegment tree) {
        var mh$ = git_tree_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_id", tree);
            }
            return (MemorySegment)mh$.invokeExact(tree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_tree_owner(const git_tree *tree)
     * }
     */
    public static FunctionDescriptor git_tree_owner$descriptor() {
        return git_tree_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_tree_owner(const git_tree *tree)
     * }
     */
    public static MethodHandle git_tree_owner$handle() {
        return git_tree_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_tree_owner(const git_tree *tree)
     * }
     */
    public static MemorySegment git_tree_owner$address() {
        return git_tree_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_tree_owner(const git_tree *tree)
     * }
     */
    public static MemorySegment git_tree_owner(MemorySegment tree) {
        var mh$ = git_tree_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_owner", tree);
            }
            return (MemorySegment)mh$.invokeExact(tree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entrycount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entrycount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_tree_entrycount(const git_tree *tree)
     * }
     */
    public static FunctionDescriptor git_tree_entrycount$descriptor() {
        return git_tree_entrycount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_tree_entrycount(const git_tree *tree)
     * }
     */
    public static MethodHandle git_tree_entrycount$handle() {
        return git_tree_entrycount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_tree_entrycount(const git_tree *tree)
     * }
     */
    public static MemorySegment git_tree_entrycount$address() {
        return git_tree_entrycount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_tree_entrycount(const git_tree *tree)
     * }
     */
    public static long git_tree_entrycount(MemorySegment tree) {
        var mh$ = git_tree_entrycount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entrycount", tree);
            }
            return (long)mh$.invokeExact(tree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_byname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_byname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byname(const git_tree *tree, const char *filename)
     * }
     */
    public static FunctionDescriptor git_tree_entry_byname$descriptor() {
        return git_tree_entry_byname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byname(const git_tree *tree, const char *filename)
     * }
     */
    public static MethodHandle git_tree_entry_byname$handle() {
        return git_tree_entry_byname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byname(const git_tree *tree, const char *filename)
     * }
     */
    public static MemorySegment git_tree_entry_byname$address() {
        return git_tree_entry_byname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byname(const git_tree *tree, const char *filename)
     * }
     */
    public static MemorySegment git_tree_entry_byname(MemorySegment tree, MemorySegment filename) {
        var mh$ = git_tree_entry_byname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_byname", tree, filename);
            }
            return (MemorySegment)mh$.invokeExact(tree, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_byindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_byindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byindex(const git_tree *tree, size_t idx)
     * }
     */
    public static FunctionDescriptor git_tree_entry_byindex$descriptor() {
        return git_tree_entry_byindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byindex(const git_tree *tree, size_t idx)
     * }
     */
    public static MethodHandle git_tree_entry_byindex$handle() {
        return git_tree_entry_byindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byindex(const git_tree *tree, size_t idx)
     * }
     */
    public static MemorySegment git_tree_entry_byindex$address() {
        return git_tree_entry_byindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byindex(const git_tree *tree, size_t idx)
     * }
     */
    public static MemorySegment git_tree_entry_byindex(MemorySegment tree, long idx) {
        var mh$ = git_tree_entry_byindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_byindex", tree, idx);
            }
            return (MemorySegment)mh$.invokeExact(tree, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_byid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_byid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byid(const git_tree *tree, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_tree_entry_byid$descriptor() {
        return git_tree_entry_byid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byid(const git_tree *tree, const git_oid *id)
     * }
     */
    public static MethodHandle git_tree_entry_byid$handle() {
        return git_tree_entry_byid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byid(const git_tree *tree, const git_oid *id)
     * }
     */
    public static MemorySegment git_tree_entry_byid$address() {
        return git_tree_entry_byid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_tree_entry *git_tree_entry_byid(const git_tree *tree, const git_oid *id)
     * }
     */
    public static MemorySegment git_tree_entry_byid(MemorySegment tree, MemorySegment id) {
        var mh$ = git_tree_entry_byid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_byid", tree, id);
            }
            return (MemorySegment)mh$.invokeExact(tree, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_bypath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_bypath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tree_entry_bypath(git_tree_entry **out, const git_tree *root, const char *path)
     * }
     */
    public static FunctionDescriptor git_tree_entry_bypath$descriptor() {
        return git_tree_entry_bypath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tree_entry_bypath(git_tree_entry **out, const git_tree *root, const char *path)
     * }
     */
    public static MethodHandle git_tree_entry_bypath$handle() {
        return git_tree_entry_bypath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tree_entry_bypath(git_tree_entry **out, const git_tree *root, const char *path)
     * }
     */
    public static MemorySegment git_tree_entry_bypath$address() {
        return git_tree_entry_bypath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tree_entry_bypath(git_tree_entry **out, const git_tree *root, const char *path)
     * }
     */
    public static int git_tree_entry_bypath(MemorySegment out, MemorySegment root, MemorySegment path) {
        var mh$ = git_tree_entry_bypath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_bypath", out, root, path);
            }
            return (int)mh$.invokeExact(out, root, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tree_entry_dup(git_tree_entry **dest, const git_tree_entry *source)
     * }
     */
    public static FunctionDescriptor git_tree_entry_dup$descriptor() {
        return git_tree_entry_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tree_entry_dup(git_tree_entry **dest, const git_tree_entry *source)
     * }
     */
    public static MethodHandle git_tree_entry_dup$handle() {
        return git_tree_entry_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tree_entry_dup(git_tree_entry **dest, const git_tree_entry *source)
     * }
     */
    public static MemorySegment git_tree_entry_dup$address() {
        return git_tree_entry_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tree_entry_dup(git_tree_entry **dest, const git_tree_entry *source)
     * }
     */
    public static int git_tree_entry_dup(MemorySegment dest, MemorySegment source) {
        var mh$ = git_tree_entry_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_dup", dest, source);
            }
            return (int)mh$.invokeExact(dest, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_tree_entry_free(git_tree_entry *entry)
     * }
     */
    public static FunctionDescriptor git_tree_entry_free$descriptor() {
        return git_tree_entry_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_tree_entry_free(git_tree_entry *entry)
     * }
     */
    public static MethodHandle git_tree_entry_free$handle() {
        return git_tree_entry_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_tree_entry_free(git_tree_entry *entry)
     * }
     */
    public static MemorySegment git_tree_entry_free$address() {
        return git_tree_entry_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_tree_entry_free(git_tree_entry *entry)
     * }
     */
    public static void git_tree_entry_free(MemorySegment entry) {
        var mh$ = git_tree_entry_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_free", entry);
            }
            mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_tree_entry_name(const git_tree_entry *entry)
     * }
     */
    public static FunctionDescriptor git_tree_entry_name$descriptor() {
        return git_tree_entry_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_tree_entry_name(const git_tree_entry *entry)
     * }
     */
    public static MethodHandle git_tree_entry_name$handle() {
        return git_tree_entry_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_tree_entry_name(const git_tree_entry *entry)
     * }
     */
    public static MemorySegment git_tree_entry_name$address() {
        return git_tree_entry_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_tree_entry_name(const git_tree_entry *entry)
     * }
     */
    public static MemorySegment git_tree_entry_name(MemorySegment entry) {
        var mh$ = git_tree_entry_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_name", entry);
            }
            return (MemorySegment)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_tree_entry_id(const git_tree_entry *entry)
     * }
     */
    public static FunctionDescriptor git_tree_entry_id$descriptor() {
        return git_tree_entry_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_tree_entry_id(const git_tree_entry *entry)
     * }
     */
    public static MethodHandle git_tree_entry_id$handle() {
        return git_tree_entry_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_tree_entry_id(const git_tree_entry *entry)
     * }
     */
    public static MemorySegment git_tree_entry_id$address() {
        return git_tree_entry_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_tree_entry_id(const git_tree_entry *entry)
     * }
     */
    public static MemorySegment git_tree_entry_id(MemorySegment entry) {
        var mh$ = git_tree_entry_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_id", entry);
            }
            return (MemorySegment)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_object_t git_tree_entry_type(const git_tree_entry *entry)
     * }
     */
    public static FunctionDescriptor git_tree_entry_type$descriptor() {
        return git_tree_entry_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_object_t git_tree_entry_type(const git_tree_entry *entry)
     * }
     */
    public static MethodHandle git_tree_entry_type$handle() {
        return git_tree_entry_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_object_t git_tree_entry_type(const git_tree_entry *entry)
     * }
     */
    public static MemorySegment git_tree_entry_type$address() {
        return git_tree_entry_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_object_t git_tree_entry_type(const git_tree_entry *entry)
     * }
     */
    public static int git_tree_entry_type(MemorySegment entry) {
        var mh$ = git_tree_entry_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_type", entry);
            }
            return (int)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_filemode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_filemode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_filemode_t git_tree_entry_filemode(const git_tree_entry *entry)
     * }
     */
    public static FunctionDescriptor git_tree_entry_filemode$descriptor() {
        return git_tree_entry_filemode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_filemode_t git_tree_entry_filemode(const git_tree_entry *entry)
     * }
     */
    public static MethodHandle git_tree_entry_filemode$handle() {
        return git_tree_entry_filemode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_filemode_t git_tree_entry_filemode(const git_tree_entry *entry)
     * }
     */
    public static MemorySegment git_tree_entry_filemode$address() {
        return git_tree_entry_filemode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_filemode_t git_tree_entry_filemode(const git_tree_entry *entry)
     * }
     */
    public static int git_tree_entry_filemode(MemorySegment entry) {
        var mh$ = git_tree_entry_filemode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_filemode", entry);
            }
            return (int)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_filemode_raw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_filemode_raw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_filemode_t git_tree_entry_filemode_raw(const git_tree_entry *entry)
     * }
     */
    public static FunctionDescriptor git_tree_entry_filemode_raw$descriptor() {
        return git_tree_entry_filemode_raw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_filemode_t git_tree_entry_filemode_raw(const git_tree_entry *entry)
     * }
     */
    public static MethodHandle git_tree_entry_filemode_raw$handle() {
        return git_tree_entry_filemode_raw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_filemode_t git_tree_entry_filemode_raw(const git_tree_entry *entry)
     * }
     */
    public static MemorySegment git_tree_entry_filemode_raw$address() {
        return git_tree_entry_filemode_raw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_filemode_t git_tree_entry_filemode_raw(const git_tree_entry *entry)
     * }
     */
    public static int git_tree_entry_filemode_raw(MemorySegment entry) {
        var mh$ = git_tree_entry_filemode_raw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_filemode_raw", entry);
            }
            return (int)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_cmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tree_entry_cmp(const git_tree_entry *e1, const git_tree_entry *e2)
     * }
     */
    public static FunctionDescriptor git_tree_entry_cmp$descriptor() {
        return git_tree_entry_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tree_entry_cmp(const git_tree_entry *e1, const git_tree_entry *e2)
     * }
     */
    public static MethodHandle git_tree_entry_cmp$handle() {
        return git_tree_entry_cmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tree_entry_cmp(const git_tree_entry *e1, const git_tree_entry *e2)
     * }
     */
    public static MemorySegment git_tree_entry_cmp$address() {
        return git_tree_entry_cmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tree_entry_cmp(const git_tree_entry *e1, const git_tree_entry *e2)
     * }
     */
    public static int git_tree_entry_cmp(MemorySegment e1, MemorySegment e2) {
        var mh$ = git_tree_entry_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_cmp", e1, e2);
            }
            return (int)mh$.invokeExact(e1, e2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_entry_to_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_entry_to_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tree_entry_to_object(git_object **object_out, git_repository *repo, const git_tree_entry *entry)
     * }
     */
    public static FunctionDescriptor git_tree_entry_to_object$descriptor() {
        return git_tree_entry_to_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tree_entry_to_object(git_object **object_out, git_repository *repo, const git_tree_entry *entry)
     * }
     */
    public static MethodHandle git_tree_entry_to_object$handle() {
        return git_tree_entry_to_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tree_entry_to_object(git_object **object_out, git_repository *repo, const git_tree_entry *entry)
     * }
     */
    public static MemorySegment git_tree_entry_to_object$address() {
        return git_tree_entry_to_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tree_entry_to_object(git_object **object_out, git_repository *repo, const git_tree_entry *entry)
     * }
     */
    public static int git_tree_entry_to_object(MemorySegment object_out, MemorySegment repo, MemorySegment entry) {
        var mh$ = git_tree_entry_to_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_entry_to_object", object_out, repo, entry);
            }
            return (int)mh$.invokeExact(object_out, repo, entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_treebuilder_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_treebuilder_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_treebuilder_new(git_treebuilder **out, git_repository *repo, const git_tree *source)
     * }
     */
    public static FunctionDescriptor git_treebuilder_new$descriptor() {
        return git_treebuilder_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_treebuilder_new(git_treebuilder **out, git_repository *repo, const git_tree *source)
     * }
     */
    public static MethodHandle git_treebuilder_new$handle() {
        return git_treebuilder_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_treebuilder_new(git_treebuilder **out, git_repository *repo, const git_tree *source)
     * }
     */
    public static MemorySegment git_treebuilder_new$address() {
        return git_treebuilder_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_treebuilder_new(git_treebuilder **out, git_repository *repo, const git_tree *source)
     * }
     */
    public static int git_treebuilder_new(MemorySegment out, MemorySegment repo, MemorySegment source) {
        var mh$ = git_treebuilder_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_treebuilder_new", out, repo, source);
            }
            return (int)mh$.invokeExact(out, repo, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_treebuilder_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_treebuilder_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_treebuilder_clear(git_treebuilder *bld)
     * }
     */
    public static FunctionDescriptor git_treebuilder_clear$descriptor() {
        return git_treebuilder_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_treebuilder_clear(git_treebuilder *bld)
     * }
     */
    public static MethodHandle git_treebuilder_clear$handle() {
        return git_treebuilder_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_treebuilder_clear(git_treebuilder *bld)
     * }
     */
    public static MemorySegment git_treebuilder_clear$address() {
        return git_treebuilder_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_treebuilder_clear(git_treebuilder *bld)
     * }
     */
    public static int git_treebuilder_clear(MemorySegment bld) {
        var mh$ = git_treebuilder_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_treebuilder_clear", bld);
            }
            return (int)mh$.invokeExact(bld);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_treebuilder_entrycount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_treebuilder_entrycount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_treebuilder_entrycount(git_treebuilder *bld)
     * }
     */
    public static FunctionDescriptor git_treebuilder_entrycount$descriptor() {
        return git_treebuilder_entrycount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_treebuilder_entrycount(git_treebuilder *bld)
     * }
     */
    public static MethodHandle git_treebuilder_entrycount$handle() {
        return git_treebuilder_entrycount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_treebuilder_entrycount(git_treebuilder *bld)
     * }
     */
    public static MemorySegment git_treebuilder_entrycount$address() {
        return git_treebuilder_entrycount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_treebuilder_entrycount(git_treebuilder *bld)
     * }
     */
    public static long git_treebuilder_entrycount(MemorySegment bld) {
        var mh$ = git_treebuilder_entrycount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_treebuilder_entrycount", bld);
            }
            return (long)mh$.invokeExact(bld);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_treebuilder_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_treebuilder_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_treebuilder_free(git_treebuilder *bld)
     * }
     */
    public static FunctionDescriptor git_treebuilder_free$descriptor() {
        return git_treebuilder_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_treebuilder_free(git_treebuilder *bld)
     * }
     */
    public static MethodHandle git_treebuilder_free$handle() {
        return git_treebuilder_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_treebuilder_free(git_treebuilder *bld)
     * }
     */
    public static MemorySegment git_treebuilder_free$address() {
        return git_treebuilder_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_treebuilder_free(git_treebuilder *bld)
     * }
     */
    public static void git_treebuilder_free(MemorySegment bld) {
        var mh$ = git_treebuilder_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_treebuilder_free", bld);
            }
            mh$.invokeExact(bld);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_treebuilder_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_treebuilder_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_treebuilder_get(git_treebuilder *bld, const char *filename)
     * }
     */
    public static FunctionDescriptor git_treebuilder_get$descriptor() {
        return git_treebuilder_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_treebuilder_get(git_treebuilder *bld, const char *filename)
     * }
     */
    public static MethodHandle git_treebuilder_get$handle() {
        return git_treebuilder_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_tree_entry *git_treebuilder_get(git_treebuilder *bld, const char *filename)
     * }
     */
    public static MemorySegment git_treebuilder_get$address() {
        return git_treebuilder_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_tree_entry *git_treebuilder_get(git_treebuilder *bld, const char *filename)
     * }
     */
    public static MemorySegment git_treebuilder_get(MemorySegment bld, MemorySegment filename) {
        var mh$ = git_treebuilder_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_treebuilder_get", bld, filename);
            }
            return (MemorySegment)mh$.invokeExact(bld, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_treebuilder_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_treebuilder_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_treebuilder_insert(const git_tree_entry **out, git_treebuilder *bld, const char *filename, const git_oid *id, git_filemode_t filemode)
     * }
     */
    public static FunctionDescriptor git_treebuilder_insert$descriptor() {
        return git_treebuilder_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_treebuilder_insert(const git_tree_entry **out, git_treebuilder *bld, const char *filename, const git_oid *id, git_filemode_t filemode)
     * }
     */
    public static MethodHandle git_treebuilder_insert$handle() {
        return git_treebuilder_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_treebuilder_insert(const git_tree_entry **out, git_treebuilder *bld, const char *filename, const git_oid *id, git_filemode_t filemode)
     * }
     */
    public static MemorySegment git_treebuilder_insert$address() {
        return git_treebuilder_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_treebuilder_insert(const git_tree_entry **out, git_treebuilder *bld, const char *filename, const git_oid *id, git_filemode_t filemode)
     * }
     */
    public static int git_treebuilder_insert(MemorySegment out, MemorySegment bld, MemorySegment filename, MemorySegment id, int filemode) {
        var mh$ = git_treebuilder_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_treebuilder_insert", out, bld, filename, id, filemode);
            }
            return (int)mh$.invokeExact(out, bld, filename, id, filemode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_treebuilder_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_treebuilder_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_treebuilder_remove(git_treebuilder *bld, const char *filename)
     * }
     */
    public static FunctionDescriptor git_treebuilder_remove$descriptor() {
        return git_treebuilder_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_treebuilder_remove(git_treebuilder *bld, const char *filename)
     * }
     */
    public static MethodHandle git_treebuilder_remove$handle() {
        return git_treebuilder_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_treebuilder_remove(git_treebuilder *bld, const char *filename)
     * }
     */
    public static MemorySegment git_treebuilder_remove$address() {
        return git_treebuilder_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_treebuilder_remove(git_treebuilder *bld, const char *filename)
     * }
     */
    public static int git_treebuilder_remove(MemorySegment bld, MemorySegment filename) {
        var mh$ = git_treebuilder_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_treebuilder_remove", bld, filename);
            }
            return (int)mh$.invokeExact(bld, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_treebuilder_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_treebuilder_filter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_treebuilder_filter(git_treebuilder *bld, git_treebuilder_filter_cb filter, void *payload)
     * }
     */
    public static FunctionDescriptor git_treebuilder_filter$descriptor() {
        return git_treebuilder_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_treebuilder_filter(git_treebuilder *bld, git_treebuilder_filter_cb filter, void *payload)
     * }
     */
    public static MethodHandle git_treebuilder_filter$handle() {
        return git_treebuilder_filter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_treebuilder_filter(git_treebuilder *bld, git_treebuilder_filter_cb filter, void *payload)
     * }
     */
    public static MemorySegment git_treebuilder_filter$address() {
        return git_treebuilder_filter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_treebuilder_filter(git_treebuilder *bld, git_treebuilder_filter_cb filter, void *payload)
     * }
     */
    public static int git_treebuilder_filter(MemorySegment bld, MemorySegment filter, MemorySegment payload) {
        var mh$ = git_treebuilder_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_treebuilder_filter", bld, filter, payload);
            }
            return (int)mh$.invokeExact(bld, filter, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_treebuilder_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_treebuilder_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_treebuilder_write(git_oid *id, git_treebuilder *bld)
     * }
     */
    public static FunctionDescriptor git_treebuilder_write$descriptor() {
        return git_treebuilder_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_treebuilder_write(git_oid *id, git_treebuilder *bld)
     * }
     */
    public static MethodHandle git_treebuilder_write$handle() {
        return git_treebuilder_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_treebuilder_write(git_oid *id, git_treebuilder *bld)
     * }
     */
    public static MemorySegment git_treebuilder_write$address() {
        return git_treebuilder_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_treebuilder_write(git_oid *id, git_treebuilder *bld)
     * }
     */
    public static int git_treebuilder_write(MemorySegment id, MemorySegment bld) {
        var mh$ = git_treebuilder_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_treebuilder_write", id, bld);
            }
            return (int)mh$.invokeExact(id, bld);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_TREEWALK_PRE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TREEWALK_PRE = 0
     * }
     */
    public static int GIT_TREEWALK_PRE() {
        return GIT_TREEWALK_PRE;
    }
    private static final int GIT_TREEWALK_POST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TREEWALK_POST = 1
     * }
     */
    public static int GIT_TREEWALK_POST() {
        return GIT_TREEWALK_POST;
    }

    private static class git_tree_walk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_walk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tree_walk(const git_tree *tree, git_treewalk_mode mode, git_treewalk_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_tree_walk$descriptor() {
        return git_tree_walk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tree_walk(const git_tree *tree, git_treewalk_mode mode, git_treewalk_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_tree_walk$handle() {
        return git_tree_walk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tree_walk(const git_tree *tree, git_treewalk_mode mode, git_treewalk_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_tree_walk$address() {
        return git_tree_walk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tree_walk(const git_tree *tree, git_treewalk_mode mode, git_treewalk_cb callback, void *payload)
     * }
     */
    public static int git_tree_walk(MemorySegment tree, int mode, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_tree_walk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_walk", tree, mode, callback, payload);
            }
            return (int)mh$.invokeExact(tree, mode, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tree_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tree_dup(git_tree **out, git_tree *source)
     * }
     */
    public static FunctionDescriptor git_tree_dup$descriptor() {
        return git_tree_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tree_dup(git_tree **out, git_tree *source)
     * }
     */
    public static MethodHandle git_tree_dup$handle() {
        return git_tree_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tree_dup(git_tree **out, git_tree *source)
     * }
     */
    public static MemorySegment git_tree_dup$address() {
        return git_tree_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tree_dup(git_tree **out, git_tree *source)
     * }
     */
    public static int git_tree_dup(MemorySegment out, MemorySegment source) {
        var mh$ = git_tree_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_dup", out, source);
            }
            return (int)mh$.invokeExact(out, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_TREE_UPDATE_UPSERT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TREE_UPDATE_UPSERT = 0
     * }
     */
    public static int GIT_TREE_UPDATE_UPSERT() {
        return GIT_TREE_UPDATE_UPSERT;
    }
    private static final int GIT_TREE_UPDATE_REMOVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TREE_UPDATE_REMOVE = 1
     * }
     */
    public static int GIT_TREE_UPDATE_REMOVE() {
        return GIT_TREE_UPDATE_REMOVE;
    }

    private static class git_tree_create_updated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tree_create_updated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tree_create_updated(git_oid *out, git_repository *repo, git_tree *baseline, size_t nupdates, const git_tree_update *updates)
     * }
     */
    public static FunctionDescriptor git_tree_create_updated$descriptor() {
        return git_tree_create_updated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tree_create_updated(git_oid *out, git_repository *repo, git_tree *baseline, size_t nupdates, const git_tree_update *updates)
     * }
     */
    public static MethodHandle git_tree_create_updated$handle() {
        return git_tree_create_updated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tree_create_updated(git_oid *out, git_repository *repo, git_tree *baseline, size_t nupdates, const git_tree_update *updates)
     * }
     */
    public static MemorySegment git_tree_create_updated$address() {
        return git_tree_create_updated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tree_create_updated(git_oid *out, git_repository *repo, git_tree *baseline, size_t nupdates, const git_tree_update *updates)
     * }
     */
    public static int git_tree_create_updated(MemorySegment out, MemorySegment repo, MemorySegment baseline, long nupdates, MemorySegment updates) {
        var mh$ = git_tree_create_updated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tree_create_updated", out, repo, baseline, nupdates, updates);
            }
            return (int)mh$.invokeExact(out, repo, baseline, nupdates, updates);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_strarray_dispose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_strarray_dispose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_strarray_dispose(git_strarray *array)
     * }
     */
    public static FunctionDescriptor git_strarray_dispose$descriptor() {
        return git_strarray_dispose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_strarray_dispose(git_strarray *array)
     * }
     */
    public static MethodHandle git_strarray_dispose$handle() {
        return git_strarray_dispose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_strarray_dispose(git_strarray *array)
     * }
     */
    public static MemorySegment git_strarray_dispose$address() {
        return git_strarray_dispose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_strarray_dispose(git_strarray *array)
     * }
     */
    public static void git_strarray_dispose(MemorySegment array) {
        var mh$ = git_strarray_dispose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_strarray_dispose", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_lookup(git_reference **out, git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_reference_lookup$descriptor() {
        return git_reference_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_lookup(git_reference **out, git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_reference_lookup$handle() {
        return git_reference_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_lookup(git_reference **out, git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_reference_lookup$address() {
        return git_reference_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_lookup(git_reference **out, git_repository *repo, const char *name)
     * }
     */
    public static int git_reference_lookup(MemorySegment out, MemorySegment repo, MemorySegment name) {
        var mh$ = git_reference_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_lookup", out, repo, name);
            }
            return (int)mh$.invokeExact(out, repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_name_to_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_name_to_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_name_to_id(git_oid *out, git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_reference_name_to_id$descriptor() {
        return git_reference_name_to_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_name_to_id(git_oid *out, git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_reference_name_to_id$handle() {
        return git_reference_name_to_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_name_to_id(git_oid *out, git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_reference_name_to_id$address() {
        return git_reference_name_to_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_name_to_id(git_oid *out, git_repository *repo, const char *name)
     * }
     */
    public static int git_reference_name_to_id(MemorySegment out, MemorySegment repo, MemorySegment name) {
        var mh$ = git_reference_name_to_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_name_to_id", out, repo, name);
            }
            return (int)mh$.invokeExact(out, repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_dwim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_dwim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_dwim(git_reference **out, git_repository *repo, const char *shorthand)
     * }
     */
    public static FunctionDescriptor git_reference_dwim$descriptor() {
        return git_reference_dwim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_dwim(git_reference **out, git_repository *repo, const char *shorthand)
     * }
     */
    public static MethodHandle git_reference_dwim$handle() {
        return git_reference_dwim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_dwim(git_reference **out, git_repository *repo, const char *shorthand)
     * }
     */
    public static MemorySegment git_reference_dwim$address() {
        return git_reference_dwim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_dwim(git_reference **out, git_repository *repo, const char *shorthand)
     * }
     */
    public static int git_reference_dwim(MemorySegment out, MemorySegment repo, MemorySegment shorthand) {
        var mh$ = git_reference_dwim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_dwim", out, repo, shorthand);
            }
            return (int)mh$.invokeExact(out, repo, shorthand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_symbolic_create_matching {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_symbolic_create_matching");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_symbolic_create_matching(git_reference **out, git_repository *repo, const char *name, const char *target, int force, const char *current_value, const char *log_message)
     * }
     */
    public static FunctionDescriptor git_reference_symbolic_create_matching$descriptor() {
        return git_reference_symbolic_create_matching.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_symbolic_create_matching(git_reference **out, git_repository *repo, const char *name, const char *target, int force, const char *current_value, const char *log_message)
     * }
     */
    public static MethodHandle git_reference_symbolic_create_matching$handle() {
        return git_reference_symbolic_create_matching.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_symbolic_create_matching(git_reference **out, git_repository *repo, const char *name, const char *target, int force, const char *current_value, const char *log_message)
     * }
     */
    public static MemorySegment git_reference_symbolic_create_matching$address() {
        return git_reference_symbolic_create_matching.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_symbolic_create_matching(git_reference **out, git_repository *repo, const char *name, const char *target, int force, const char *current_value, const char *log_message)
     * }
     */
    public static int git_reference_symbolic_create_matching(MemorySegment out, MemorySegment repo, MemorySegment name, MemorySegment target, int force, MemorySegment current_value, MemorySegment log_message) {
        var mh$ = git_reference_symbolic_create_matching.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_symbolic_create_matching", out, repo, name, target, force, current_value, log_message);
            }
            return (int)mh$.invokeExact(out, repo, name, target, force, current_value, log_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_symbolic_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_symbolic_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_symbolic_create(git_reference **out, git_repository *repo, const char *name, const char *target, int force, const char *log_message)
     * }
     */
    public static FunctionDescriptor git_reference_symbolic_create$descriptor() {
        return git_reference_symbolic_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_symbolic_create(git_reference **out, git_repository *repo, const char *name, const char *target, int force, const char *log_message)
     * }
     */
    public static MethodHandle git_reference_symbolic_create$handle() {
        return git_reference_symbolic_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_symbolic_create(git_reference **out, git_repository *repo, const char *name, const char *target, int force, const char *log_message)
     * }
     */
    public static MemorySegment git_reference_symbolic_create$address() {
        return git_reference_symbolic_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_symbolic_create(git_reference **out, git_repository *repo, const char *name, const char *target, int force, const char *log_message)
     * }
     */
    public static int git_reference_symbolic_create(MemorySegment out, MemorySegment repo, MemorySegment name, MemorySegment target, int force, MemorySegment log_message) {
        var mh$ = git_reference_symbolic_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_symbolic_create", out, repo, name, target, force, log_message);
            }
            return (int)mh$.invokeExact(out, repo, name, target, force, log_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_create(git_reference **out, git_repository *repo, const char *name, const git_oid *id, int force, const char *log_message)
     * }
     */
    public static FunctionDescriptor git_reference_create$descriptor() {
        return git_reference_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_create(git_reference **out, git_repository *repo, const char *name, const git_oid *id, int force, const char *log_message)
     * }
     */
    public static MethodHandle git_reference_create$handle() {
        return git_reference_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_create(git_reference **out, git_repository *repo, const char *name, const git_oid *id, int force, const char *log_message)
     * }
     */
    public static MemorySegment git_reference_create$address() {
        return git_reference_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_create(git_reference **out, git_repository *repo, const char *name, const git_oid *id, int force, const char *log_message)
     * }
     */
    public static int git_reference_create(MemorySegment out, MemorySegment repo, MemorySegment name, MemorySegment id, int force, MemorySegment log_message) {
        var mh$ = git_reference_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_create", out, repo, name, id, force, log_message);
            }
            return (int)mh$.invokeExact(out, repo, name, id, force, log_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_create_matching {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_create_matching");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_create_matching(git_reference **out, git_repository *repo, const char *name, const git_oid *id, int force, const git_oid *current_id, const char *log_message)
     * }
     */
    public static FunctionDescriptor git_reference_create_matching$descriptor() {
        return git_reference_create_matching.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_create_matching(git_reference **out, git_repository *repo, const char *name, const git_oid *id, int force, const git_oid *current_id, const char *log_message)
     * }
     */
    public static MethodHandle git_reference_create_matching$handle() {
        return git_reference_create_matching.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_create_matching(git_reference **out, git_repository *repo, const char *name, const git_oid *id, int force, const git_oid *current_id, const char *log_message)
     * }
     */
    public static MemorySegment git_reference_create_matching$address() {
        return git_reference_create_matching.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_create_matching(git_reference **out, git_repository *repo, const char *name, const git_oid *id, int force, const git_oid *current_id, const char *log_message)
     * }
     */
    public static int git_reference_create_matching(MemorySegment out, MemorySegment repo, MemorySegment name, MemorySegment id, int force, MemorySegment current_id, MemorySegment log_message) {
        var mh$ = git_reference_create_matching.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_create_matching", out, repo, name, id, force, current_id, log_message);
            }
            return (int)mh$.invokeExact(out, repo, name, id, force, current_id, log_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_reference_target(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_target$descriptor() {
        return git_reference_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_reference_target(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_target$handle() {
        return git_reference_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_reference_target(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_target$address() {
        return git_reference_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_reference_target(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_target(MemorySegment ref) {
        var mh$ = git_reference_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_target", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_target_peel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_target_peel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_reference_target_peel(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_target_peel$descriptor() {
        return git_reference_target_peel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_reference_target_peel(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_target_peel$handle() {
        return git_reference_target_peel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_reference_target_peel(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_target_peel$address() {
        return git_reference_target_peel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_reference_target_peel(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_target_peel(MemorySegment ref) {
        var mh$ = git_reference_target_peel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_target_peel", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_symbolic_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_symbolic_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_reference_symbolic_target(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_symbolic_target$descriptor() {
        return git_reference_symbolic_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_reference_symbolic_target(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_symbolic_target$handle() {
        return git_reference_symbolic_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_reference_symbolic_target(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_symbolic_target$address() {
        return git_reference_symbolic_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_reference_symbolic_target(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_symbolic_target(MemorySegment ref) {
        var mh$ = git_reference_symbolic_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_symbolic_target", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_reference_t git_reference_type(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_type$descriptor() {
        return git_reference_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_reference_t git_reference_type(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_type$handle() {
        return git_reference_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_reference_t git_reference_type(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_type$address() {
        return git_reference_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_reference_t git_reference_type(const git_reference *ref)
     * }
     */
    public static int git_reference_type(MemorySegment ref) {
        var mh$ = git_reference_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_type", ref);
            }
            return (int)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_reference_name(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_name$descriptor() {
        return git_reference_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_reference_name(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_name$handle() {
        return git_reference_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_reference_name(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_name$address() {
        return git_reference_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_reference_name(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_name(MemorySegment ref) {
        var mh$ = git_reference_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_name", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_resolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_resolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_resolve(git_reference **out, const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_resolve$descriptor() {
        return git_reference_resolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_resolve(git_reference **out, const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_resolve$handle() {
        return git_reference_resolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_resolve(git_reference **out, const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_resolve$address() {
        return git_reference_resolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_resolve(git_reference **out, const git_reference *ref)
     * }
     */
    public static int git_reference_resolve(MemorySegment out, MemorySegment ref) {
        var mh$ = git_reference_resolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_resolve", out, ref);
            }
            return (int)mh$.invokeExact(out, ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_reference_owner(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_owner$descriptor() {
        return git_reference_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_reference_owner(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_owner$handle() {
        return git_reference_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_reference_owner(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_owner$address() {
        return git_reference_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_reference_owner(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_owner(MemorySegment ref) {
        var mh$ = git_reference_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_owner", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_symbolic_set_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_symbolic_set_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_symbolic_set_target(git_reference **out, git_reference *ref, const char *target, const char *log_message)
     * }
     */
    public static FunctionDescriptor git_reference_symbolic_set_target$descriptor() {
        return git_reference_symbolic_set_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_symbolic_set_target(git_reference **out, git_reference *ref, const char *target, const char *log_message)
     * }
     */
    public static MethodHandle git_reference_symbolic_set_target$handle() {
        return git_reference_symbolic_set_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_symbolic_set_target(git_reference **out, git_reference *ref, const char *target, const char *log_message)
     * }
     */
    public static MemorySegment git_reference_symbolic_set_target$address() {
        return git_reference_symbolic_set_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_symbolic_set_target(git_reference **out, git_reference *ref, const char *target, const char *log_message)
     * }
     */
    public static int git_reference_symbolic_set_target(MemorySegment out, MemorySegment ref, MemorySegment target, MemorySegment log_message) {
        var mh$ = git_reference_symbolic_set_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_symbolic_set_target", out, ref, target, log_message);
            }
            return (int)mh$.invokeExact(out, ref, target, log_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_set_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_set_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_set_target(git_reference **out, git_reference *ref, const git_oid *id, const char *log_message)
     * }
     */
    public static FunctionDescriptor git_reference_set_target$descriptor() {
        return git_reference_set_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_set_target(git_reference **out, git_reference *ref, const git_oid *id, const char *log_message)
     * }
     */
    public static MethodHandle git_reference_set_target$handle() {
        return git_reference_set_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_set_target(git_reference **out, git_reference *ref, const git_oid *id, const char *log_message)
     * }
     */
    public static MemorySegment git_reference_set_target$address() {
        return git_reference_set_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_set_target(git_reference **out, git_reference *ref, const git_oid *id, const char *log_message)
     * }
     */
    public static int git_reference_set_target(MemorySegment out, MemorySegment ref, MemorySegment id, MemorySegment log_message) {
        var mh$ = git_reference_set_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_set_target", out, ref, id, log_message);
            }
            return (int)mh$.invokeExact(out, ref, id, log_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_rename(git_reference **new_ref, git_reference *ref, const char *new_name, int force, const char *log_message)
     * }
     */
    public static FunctionDescriptor git_reference_rename$descriptor() {
        return git_reference_rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_rename(git_reference **new_ref, git_reference *ref, const char *new_name, int force, const char *log_message)
     * }
     */
    public static MethodHandle git_reference_rename$handle() {
        return git_reference_rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_rename(git_reference **new_ref, git_reference *ref, const char *new_name, int force, const char *log_message)
     * }
     */
    public static MemorySegment git_reference_rename$address() {
        return git_reference_rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_rename(git_reference **new_ref, git_reference *ref, const char *new_name, int force, const char *log_message)
     * }
     */
    public static int git_reference_rename(MemorySegment new_ref, MemorySegment ref, MemorySegment new_name, int force, MemorySegment log_message) {
        var mh$ = git_reference_rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_rename", new_ref, ref, new_name, force, log_message);
            }
            return (int)mh$.invokeExact(new_ref, ref, new_name, force, log_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_delete(git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_delete$descriptor() {
        return git_reference_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_delete(git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_delete$handle() {
        return git_reference_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_delete(git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_delete$address() {
        return git_reference_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_delete(git_reference *ref)
     * }
     */
    public static int git_reference_delete(MemorySegment ref) {
        var mh$ = git_reference_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_delete", ref);
            }
            return (int)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_remove(git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_reference_remove$descriptor() {
        return git_reference_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_remove(git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_reference_remove$handle() {
        return git_reference_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_remove(git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_reference_remove$address() {
        return git_reference_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_remove(git_repository *repo, const char *name)
     * }
     */
    public static int git_reference_remove(MemorySegment repo, MemorySegment name) {
        var mh$ = git_reference_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_remove", repo, name);
            }
            return (int)mh$.invokeExact(repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_list(git_strarray *array, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_reference_list$descriptor() {
        return git_reference_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_list(git_strarray *array, git_repository *repo)
     * }
     */
    public static MethodHandle git_reference_list$handle() {
        return git_reference_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_list(git_strarray *array, git_repository *repo)
     * }
     */
    public static MemorySegment git_reference_list$address() {
        return git_reference_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_list(git_strarray *array, git_repository *repo)
     * }
     */
    public static int git_reference_list(MemorySegment array, MemorySegment repo) {
        var mh$ = git_reference_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_list", array, repo);
            }
            return (int)mh$.invokeExact(array, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_foreach(git_repository *repo, git_reference_foreach_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_reference_foreach$descriptor() {
        return git_reference_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_foreach(git_repository *repo, git_reference_foreach_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_reference_foreach$handle() {
        return git_reference_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_foreach(git_repository *repo, git_reference_foreach_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_reference_foreach$address() {
        return git_reference_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_foreach(git_repository *repo, git_reference_foreach_cb callback, void *payload)
     * }
     */
    public static int git_reference_foreach(MemorySegment repo, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_reference_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_foreach", repo, callback, payload);
            }
            return (int)mh$.invokeExact(repo, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_foreach_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_foreach_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_foreach_name(git_repository *repo, git_reference_foreach_name_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_reference_foreach_name$descriptor() {
        return git_reference_foreach_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_foreach_name(git_repository *repo, git_reference_foreach_name_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_reference_foreach_name$handle() {
        return git_reference_foreach_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_foreach_name(git_repository *repo, git_reference_foreach_name_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_reference_foreach_name$address() {
        return git_reference_foreach_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_foreach_name(git_repository *repo, git_reference_foreach_name_cb callback, void *payload)
     * }
     */
    public static int git_reference_foreach_name(MemorySegment repo, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_reference_foreach_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_foreach_name", repo, callback, payload);
            }
            return (int)mh$.invokeExact(repo, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_dup(git_reference **dest, git_reference *source)
     * }
     */
    public static FunctionDescriptor git_reference_dup$descriptor() {
        return git_reference_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_dup(git_reference **dest, git_reference *source)
     * }
     */
    public static MethodHandle git_reference_dup$handle() {
        return git_reference_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_dup(git_reference **dest, git_reference *source)
     * }
     */
    public static MemorySegment git_reference_dup$address() {
        return git_reference_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_dup(git_reference **dest, git_reference *source)
     * }
     */
    public static int git_reference_dup(MemorySegment dest, MemorySegment source) {
        var mh$ = git_reference_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_dup", dest, source);
            }
            return (int)mh$.invokeExact(dest, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_reference_free(git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_free$descriptor() {
        return git_reference_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_reference_free(git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_free$handle() {
        return git_reference_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_reference_free(git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_free$address() {
        return git_reference_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_reference_free(git_reference *ref)
     * }
     */
    public static void git_reference_free(MemorySegment ref) {
        var mh$ = git_reference_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_free", ref);
            }
            mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_cmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_cmp(const git_reference *ref1, const git_reference *ref2)
     * }
     */
    public static FunctionDescriptor git_reference_cmp$descriptor() {
        return git_reference_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_cmp(const git_reference *ref1, const git_reference *ref2)
     * }
     */
    public static MethodHandle git_reference_cmp$handle() {
        return git_reference_cmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_cmp(const git_reference *ref1, const git_reference *ref2)
     * }
     */
    public static MemorySegment git_reference_cmp$address() {
        return git_reference_cmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_cmp(const git_reference *ref1, const git_reference *ref2)
     * }
     */
    public static int git_reference_cmp(MemorySegment ref1, MemorySegment ref2) {
        var mh$ = git_reference_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_cmp", ref1, ref2);
            }
            return (int)mh$.invokeExact(ref1, ref2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_reference_iterator_new$descriptor() {
        return git_reference_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_reference_iterator_new$handle() {
        return git_reference_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_reference_iterator_new$address() {
        return git_reference_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_iterator_new(git_reference_iterator **out, git_repository *repo)
     * }
     */
    public static int git_reference_iterator_new(MemorySegment out, MemorySegment repo) {
        var mh$ = git_reference_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_iterator_new", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_iterator_glob_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_iterator_glob_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_iterator_glob_new(git_reference_iterator **out, git_repository *repo, const char *glob)
     * }
     */
    public static FunctionDescriptor git_reference_iterator_glob_new$descriptor() {
        return git_reference_iterator_glob_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_iterator_glob_new(git_reference_iterator **out, git_repository *repo, const char *glob)
     * }
     */
    public static MethodHandle git_reference_iterator_glob_new$handle() {
        return git_reference_iterator_glob_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_iterator_glob_new(git_reference_iterator **out, git_repository *repo, const char *glob)
     * }
     */
    public static MemorySegment git_reference_iterator_glob_new$address() {
        return git_reference_iterator_glob_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_iterator_glob_new(git_reference_iterator **out, git_repository *repo, const char *glob)
     * }
     */
    public static int git_reference_iterator_glob_new(MemorySegment out, MemorySegment repo, MemorySegment glob) {
        var mh$ = git_reference_iterator_glob_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_iterator_glob_new", out, repo, glob);
            }
            return (int)mh$.invokeExact(out, repo, glob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_next(git_reference **out, git_reference_iterator *iter)
     * }
     */
    public static FunctionDescriptor git_reference_next$descriptor() {
        return git_reference_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_next(git_reference **out, git_reference_iterator *iter)
     * }
     */
    public static MethodHandle git_reference_next$handle() {
        return git_reference_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_next(git_reference **out, git_reference_iterator *iter)
     * }
     */
    public static MemorySegment git_reference_next$address() {
        return git_reference_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_next(git_reference **out, git_reference_iterator *iter)
     * }
     */
    public static int git_reference_next(MemorySegment out, MemorySegment iter) {
        var mh$ = git_reference_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_next", out, iter);
            }
            return (int)mh$.invokeExact(out, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_next_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_next_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_next_name(const char **out, git_reference_iterator *iter)
     * }
     */
    public static FunctionDescriptor git_reference_next_name$descriptor() {
        return git_reference_next_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_next_name(const char **out, git_reference_iterator *iter)
     * }
     */
    public static MethodHandle git_reference_next_name$handle() {
        return git_reference_next_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_next_name(const char **out, git_reference_iterator *iter)
     * }
     */
    public static MemorySegment git_reference_next_name$address() {
        return git_reference_next_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_next_name(const char **out, git_reference_iterator *iter)
     * }
     */
    public static int git_reference_next_name(MemorySegment out, MemorySegment iter) {
        var mh$ = git_reference_next_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_next_name", out, iter);
            }
            return (int)mh$.invokeExact(out, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_iterator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_iterator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_reference_iterator_free(git_reference_iterator *iter)
     * }
     */
    public static FunctionDescriptor git_reference_iterator_free$descriptor() {
        return git_reference_iterator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_reference_iterator_free(git_reference_iterator *iter)
     * }
     */
    public static MethodHandle git_reference_iterator_free$handle() {
        return git_reference_iterator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_reference_iterator_free(git_reference_iterator *iter)
     * }
     */
    public static MemorySegment git_reference_iterator_free$address() {
        return git_reference_iterator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_reference_iterator_free(git_reference_iterator *iter)
     * }
     */
    public static void git_reference_iterator_free(MemorySegment iter) {
        var mh$ = git_reference_iterator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_iterator_free", iter);
            }
            mh$.invokeExact(iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_foreach_glob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_foreach_glob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_foreach_glob(git_repository *repo, const char *glob, git_reference_foreach_name_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_reference_foreach_glob$descriptor() {
        return git_reference_foreach_glob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_foreach_glob(git_repository *repo, const char *glob, git_reference_foreach_name_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_reference_foreach_glob$handle() {
        return git_reference_foreach_glob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_foreach_glob(git_repository *repo, const char *glob, git_reference_foreach_name_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_reference_foreach_glob$address() {
        return git_reference_foreach_glob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_foreach_glob(git_repository *repo, const char *glob, git_reference_foreach_name_cb callback, void *payload)
     * }
     */
    public static int git_reference_foreach_glob(MemorySegment repo, MemorySegment glob, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_reference_foreach_glob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_foreach_glob", repo, glob, callback, payload);
            }
            return (int)mh$.invokeExact(repo, glob, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_has_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_has_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_has_log(git_repository *repo, const char *refname)
     * }
     */
    public static FunctionDescriptor git_reference_has_log$descriptor() {
        return git_reference_has_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_has_log(git_repository *repo, const char *refname)
     * }
     */
    public static MethodHandle git_reference_has_log$handle() {
        return git_reference_has_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_has_log(git_repository *repo, const char *refname)
     * }
     */
    public static MemorySegment git_reference_has_log$address() {
        return git_reference_has_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_has_log(git_repository *repo, const char *refname)
     * }
     */
    public static int git_reference_has_log(MemorySegment repo, MemorySegment refname) {
        var mh$ = git_reference_has_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_has_log", repo, refname);
            }
            return (int)mh$.invokeExact(repo, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_ensure_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_ensure_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_ensure_log(git_repository *repo, const char *refname)
     * }
     */
    public static FunctionDescriptor git_reference_ensure_log$descriptor() {
        return git_reference_ensure_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_ensure_log(git_repository *repo, const char *refname)
     * }
     */
    public static MethodHandle git_reference_ensure_log$handle() {
        return git_reference_ensure_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_ensure_log(git_repository *repo, const char *refname)
     * }
     */
    public static MemorySegment git_reference_ensure_log$address() {
        return git_reference_ensure_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_ensure_log(git_repository *repo, const char *refname)
     * }
     */
    public static int git_reference_ensure_log(MemorySegment repo, MemorySegment refname) {
        var mh$ = git_reference_ensure_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_ensure_log", repo, refname);
            }
            return (int)mh$.invokeExact(repo, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_is_branch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_is_branch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_is_branch(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_is_branch$descriptor() {
        return git_reference_is_branch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_is_branch(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_is_branch$handle() {
        return git_reference_is_branch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_is_branch(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_is_branch$address() {
        return git_reference_is_branch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_is_branch(const git_reference *ref)
     * }
     */
    public static int git_reference_is_branch(MemorySegment ref) {
        var mh$ = git_reference_is_branch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_is_branch", ref);
            }
            return (int)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_is_remote {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_is_remote");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_is_remote(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_is_remote$descriptor() {
        return git_reference_is_remote.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_is_remote(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_is_remote$handle() {
        return git_reference_is_remote.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_is_remote(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_is_remote$address() {
        return git_reference_is_remote.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_is_remote(const git_reference *ref)
     * }
     */
    public static int git_reference_is_remote(MemorySegment ref) {
        var mh$ = git_reference_is_remote.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_is_remote", ref);
            }
            return (int)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_is_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_is_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_is_tag(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_is_tag$descriptor() {
        return git_reference_is_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_is_tag(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_is_tag$handle() {
        return git_reference_is_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_is_tag(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_is_tag$address() {
        return git_reference_is_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_is_tag(const git_reference *ref)
     * }
     */
    public static int git_reference_is_tag(MemorySegment ref) {
        var mh$ = git_reference_is_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_is_tag", ref);
            }
            return (int)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_is_note {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_is_note");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_is_note(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_is_note$descriptor() {
        return git_reference_is_note.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_is_note(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_is_note$handle() {
        return git_reference_is_note.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_is_note(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_is_note$address() {
        return git_reference_is_note.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_is_note(const git_reference *ref)
     * }
     */
    public static int git_reference_is_note(MemorySegment ref) {
        var mh$ = git_reference_is_note.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_is_note", ref);
            }
            return (int)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_REFERENCE_FORMAT_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REFERENCE_FORMAT_NORMAL = 0
     * }
     */
    public static int GIT_REFERENCE_FORMAT_NORMAL() {
        return GIT_REFERENCE_FORMAT_NORMAL;
    }
    private static final int GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL = 1
     * }
     */
    public static int GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL() {
        return GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL;
    }
    private static final int GIT_REFERENCE_FORMAT_REFSPEC_PATTERN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REFERENCE_FORMAT_REFSPEC_PATTERN = 2
     * }
     */
    public static int GIT_REFERENCE_FORMAT_REFSPEC_PATTERN() {
        return GIT_REFERENCE_FORMAT_REFSPEC_PATTERN;
    }
    private static final int GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND = 4
     * }
     */
    public static int GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND() {
        return GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND;
    }

    private static class git_reference_normalize_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_normalize_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_normalize_name(char *buffer_out, size_t buffer_size, const char *name, unsigned int flags)
     * }
     */
    public static FunctionDescriptor git_reference_normalize_name$descriptor() {
        return git_reference_normalize_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_normalize_name(char *buffer_out, size_t buffer_size, const char *name, unsigned int flags)
     * }
     */
    public static MethodHandle git_reference_normalize_name$handle() {
        return git_reference_normalize_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_normalize_name(char *buffer_out, size_t buffer_size, const char *name, unsigned int flags)
     * }
     */
    public static MemorySegment git_reference_normalize_name$address() {
        return git_reference_normalize_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_normalize_name(char *buffer_out, size_t buffer_size, const char *name, unsigned int flags)
     * }
     */
    public static int git_reference_normalize_name(MemorySegment buffer_out, long buffer_size, MemorySegment name, int flags) {
        var mh$ = git_reference_normalize_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_normalize_name", buffer_out, buffer_size, name, flags);
            }
            return (int)mh$.invokeExact(buffer_out, buffer_size, name, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_peel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_peel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_peel(git_object **out, const git_reference *ref, git_object_t type)
     * }
     */
    public static FunctionDescriptor git_reference_peel$descriptor() {
        return git_reference_peel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_peel(git_object **out, const git_reference *ref, git_object_t type)
     * }
     */
    public static MethodHandle git_reference_peel$handle() {
        return git_reference_peel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_peel(git_object **out, const git_reference *ref, git_object_t type)
     * }
     */
    public static MemorySegment git_reference_peel$address() {
        return git_reference_peel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_peel(git_object **out, const git_reference *ref, git_object_t type)
     * }
     */
    public static int git_reference_peel(MemorySegment out, MemorySegment ref, int type) {
        var mh$ = git_reference_peel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_peel", out, ref, type);
            }
            return (int)mh$.invokeExact(out, ref, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_name_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_name_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_name_is_valid(int *valid, const char *refname)
     * }
     */
    public static FunctionDescriptor git_reference_name_is_valid$descriptor() {
        return git_reference_name_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_name_is_valid(int *valid, const char *refname)
     * }
     */
    public static MethodHandle git_reference_name_is_valid$handle() {
        return git_reference_name_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_name_is_valid(int *valid, const char *refname)
     * }
     */
    public static MemorySegment git_reference_name_is_valid$address() {
        return git_reference_name_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_name_is_valid(int *valid, const char *refname)
     * }
     */
    public static int git_reference_name_is_valid(MemorySegment valid, MemorySegment refname) {
        var mh$ = git_reference_name_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_name_is_valid", valid, refname);
            }
            return (int)mh$.invokeExact(valid, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_shorthand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_shorthand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_reference_shorthand(const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_reference_shorthand$descriptor() {
        return git_reference_shorthand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_reference_shorthand(const git_reference *ref)
     * }
     */
    public static MethodHandle git_reference_shorthand$handle() {
        return git_reference_shorthand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_reference_shorthand(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_shorthand$address() {
        return git_reference_shorthand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_reference_shorthand(const git_reference *ref)
     * }
     */
    public static MemorySegment git_reference_shorthand(MemorySegment ref) {
        var mh$ = git_reference_shorthand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_shorthand", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_DIFF_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_NORMAL = 0
     * }
     */
    public static int GIT_DIFF_NORMAL() {
        return GIT_DIFF_NORMAL;
    }
    private static final int GIT_DIFF_REVERSE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_REVERSE = 1
     * }
     */
    public static int GIT_DIFF_REVERSE() {
        return GIT_DIFF_REVERSE;
    }
    private static final int GIT_DIFF_INCLUDE_IGNORED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_INCLUDE_IGNORED = 2
     * }
     */
    public static int GIT_DIFF_INCLUDE_IGNORED() {
        return GIT_DIFF_INCLUDE_IGNORED;
    }
    private static final int GIT_DIFF_RECURSE_IGNORED_DIRS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_RECURSE_IGNORED_DIRS = 4
     * }
     */
    public static int GIT_DIFF_RECURSE_IGNORED_DIRS() {
        return GIT_DIFF_RECURSE_IGNORED_DIRS;
    }
    private static final int GIT_DIFF_INCLUDE_UNTRACKED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_INCLUDE_UNTRACKED = 8
     * }
     */
    public static int GIT_DIFF_INCLUDE_UNTRACKED() {
        return GIT_DIFF_INCLUDE_UNTRACKED;
    }
    private static final int GIT_DIFF_RECURSE_UNTRACKED_DIRS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_RECURSE_UNTRACKED_DIRS = 16
     * }
     */
    public static int GIT_DIFF_RECURSE_UNTRACKED_DIRS() {
        return GIT_DIFF_RECURSE_UNTRACKED_DIRS;
    }
    private static final int GIT_DIFF_INCLUDE_UNMODIFIED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_INCLUDE_UNMODIFIED = 32
     * }
     */
    public static int GIT_DIFF_INCLUDE_UNMODIFIED() {
        return GIT_DIFF_INCLUDE_UNMODIFIED;
    }
    private static final int GIT_DIFF_INCLUDE_TYPECHANGE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_INCLUDE_TYPECHANGE = 64
     * }
     */
    public static int GIT_DIFF_INCLUDE_TYPECHANGE() {
        return GIT_DIFF_INCLUDE_TYPECHANGE;
    }
    private static final int GIT_DIFF_INCLUDE_TYPECHANGE_TREES = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_INCLUDE_TYPECHANGE_TREES = 128
     * }
     */
    public static int GIT_DIFF_INCLUDE_TYPECHANGE_TREES() {
        return GIT_DIFF_INCLUDE_TYPECHANGE_TREES;
    }
    private static final int GIT_DIFF_IGNORE_FILEMODE = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_IGNORE_FILEMODE = 256
     * }
     */
    public static int GIT_DIFF_IGNORE_FILEMODE() {
        return GIT_DIFF_IGNORE_FILEMODE;
    }
    private static final int GIT_DIFF_IGNORE_SUBMODULES = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_IGNORE_SUBMODULES = 512
     * }
     */
    public static int GIT_DIFF_IGNORE_SUBMODULES() {
        return GIT_DIFF_IGNORE_SUBMODULES;
    }
    private static final int GIT_DIFF_IGNORE_CASE = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_IGNORE_CASE = 1024
     * }
     */
    public static int GIT_DIFF_IGNORE_CASE() {
        return GIT_DIFF_IGNORE_CASE;
    }
    private static final int GIT_DIFF_INCLUDE_CASECHANGE = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_INCLUDE_CASECHANGE = 2048
     * }
     */
    public static int GIT_DIFF_INCLUDE_CASECHANGE() {
        return GIT_DIFF_INCLUDE_CASECHANGE;
    }
    private static final int GIT_DIFF_DISABLE_PATHSPEC_MATCH = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_DISABLE_PATHSPEC_MATCH = 4096
     * }
     */
    public static int GIT_DIFF_DISABLE_PATHSPEC_MATCH() {
        return GIT_DIFF_DISABLE_PATHSPEC_MATCH;
    }
    private static final int GIT_DIFF_SKIP_BINARY_CHECK = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_SKIP_BINARY_CHECK = 8192
     * }
     */
    public static int GIT_DIFF_SKIP_BINARY_CHECK() {
        return GIT_DIFF_SKIP_BINARY_CHECK;
    }
    private static final int GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS = 16384
     * }
     */
    public static int GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS() {
        return GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS;
    }
    private static final int GIT_DIFF_UPDATE_INDEX = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_UPDATE_INDEX = 32768
     * }
     */
    public static int GIT_DIFF_UPDATE_INDEX() {
        return GIT_DIFF_UPDATE_INDEX;
    }
    private static final int GIT_DIFF_INCLUDE_UNREADABLE = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_INCLUDE_UNREADABLE = 65536
     * }
     */
    public static int GIT_DIFF_INCLUDE_UNREADABLE() {
        return GIT_DIFF_INCLUDE_UNREADABLE;
    }
    private static final int GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED = 131072
     * }
     */
    public static int GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED() {
        return GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED;
    }
    private static final int GIT_DIFF_INDENT_HEURISTIC = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_INDENT_HEURISTIC = 262144
     * }
     */
    public static int GIT_DIFF_INDENT_HEURISTIC() {
        return GIT_DIFF_INDENT_HEURISTIC;
    }
    private static final int GIT_DIFF_IGNORE_BLANK_LINES = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_IGNORE_BLANK_LINES = 524288
     * }
     */
    public static int GIT_DIFF_IGNORE_BLANK_LINES() {
        return GIT_DIFF_IGNORE_BLANK_LINES;
    }
    private static final int GIT_DIFF_FORCE_TEXT = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FORCE_TEXT = 1048576
     * }
     */
    public static int GIT_DIFF_FORCE_TEXT() {
        return GIT_DIFF_FORCE_TEXT;
    }
    private static final int GIT_DIFF_FORCE_BINARY = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FORCE_BINARY = 2097152
     * }
     */
    public static int GIT_DIFF_FORCE_BINARY() {
        return GIT_DIFF_FORCE_BINARY;
    }
    private static final int GIT_DIFF_IGNORE_WHITESPACE = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_IGNORE_WHITESPACE = 4194304
     * }
     */
    public static int GIT_DIFF_IGNORE_WHITESPACE() {
        return GIT_DIFF_IGNORE_WHITESPACE;
    }
    private static final int GIT_DIFF_IGNORE_WHITESPACE_CHANGE = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_IGNORE_WHITESPACE_CHANGE = 8388608
     * }
     */
    public static int GIT_DIFF_IGNORE_WHITESPACE_CHANGE() {
        return GIT_DIFF_IGNORE_WHITESPACE_CHANGE;
    }
    private static final int GIT_DIFF_IGNORE_WHITESPACE_EOL = (int)16777216L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_IGNORE_WHITESPACE_EOL = 16777216
     * }
     */
    public static int GIT_DIFF_IGNORE_WHITESPACE_EOL() {
        return GIT_DIFF_IGNORE_WHITESPACE_EOL;
    }
    private static final int GIT_DIFF_SHOW_UNTRACKED_CONTENT = (int)33554432L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_SHOW_UNTRACKED_CONTENT = 33554432
     * }
     */
    public static int GIT_DIFF_SHOW_UNTRACKED_CONTENT() {
        return GIT_DIFF_SHOW_UNTRACKED_CONTENT;
    }
    private static final int GIT_DIFF_SHOW_UNMODIFIED = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_SHOW_UNMODIFIED = 67108864
     * }
     */
    public static int GIT_DIFF_SHOW_UNMODIFIED() {
        return GIT_DIFF_SHOW_UNMODIFIED;
    }
    private static final int GIT_DIFF_PATIENCE = (int)268435456L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_PATIENCE = 268435456
     * }
     */
    public static int GIT_DIFF_PATIENCE() {
        return GIT_DIFF_PATIENCE;
    }
    private static final int GIT_DIFF_MINIMAL = (int)536870912L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_MINIMAL = 536870912
     * }
     */
    public static int GIT_DIFF_MINIMAL() {
        return GIT_DIFF_MINIMAL;
    }
    private static final int GIT_DIFF_SHOW_BINARY = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_SHOW_BINARY = 1073741824
     * }
     */
    public static int GIT_DIFF_SHOW_BINARY() {
        return GIT_DIFF_SHOW_BINARY;
    }
    private static final int GIT_DIFF_FLAG_BINARY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FLAG_BINARY = 1
     * }
     */
    public static int GIT_DIFF_FLAG_BINARY() {
        return GIT_DIFF_FLAG_BINARY;
    }
    private static final int GIT_DIFF_FLAG_NOT_BINARY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FLAG_NOT_BINARY = 2
     * }
     */
    public static int GIT_DIFF_FLAG_NOT_BINARY() {
        return GIT_DIFF_FLAG_NOT_BINARY;
    }
    private static final int GIT_DIFF_FLAG_VALID_ID = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FLAG_VALID_ID = 4
     * }
     */
    public static int GIT_DIFF_FLAG_VALID_ID() {
        return GIT_DIFF_FLAG_VALID_ID;
    }
    private static final int GIT_DIFF_FLAG_EXISTS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FLAG_EXISTS = 8
     * }
     */
    public static int GIT_DIFF_FLAG_EXISTS() {
        return GIT_DIFF_FLAG_EXISTS;
    }
    private static final int GIT_DIFF_FLAG_VALID_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FLAG_VALID_SIZE = 16
     * }
     */
    public static int GIT_DIFF_FLAG_VALID_SIZE() {
        return GIT_DIFF_FLAG_VALID_SIZE;
    }
    private static final int GIT_DELTA_UNMODIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_UNMODIFIED = 0
     * }
     */
    public static int GIT_DELTA_UNMODIFIED() {
        return GIT_DELTA_UNMODIFIED;
    }
    private static final int GIT_DELTA_ADDED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_ADDED = 1
     * }
     */
    public static int GIT_DELTA_ADDED() {
        return GIT_DELTA_ADDED;
    }
    private static final int GIT_DELTA_DELETED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_DELETED = 2
     * }
     */
    public static int GIT_DELTA_DELETED() {
        return GIT_DELTA_DELETED;
    }
    private static final int GIT_DELTA_MODIFIED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_MODIFIED = 3
     * }
     */
    public static int GIT_DELTA_MODIFIED() {
        return GIT_DELTA_MODIFIED;
    }
    private static final int GIT_DELTA_RENAMED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_RENAMED = 4
     * }
     */
    public static int GIT_DELTA_RENAMED() {
        return GIT_DELTA_RENAMED;
    }
    private static final int GIT_DELTA_COPIED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_COPIED = 5
     * }
     */
    public static int GIT_DELTA_COPIED() {
        return GIT_DELTA_COPIED;
    }
    private static final int GIT_DELTA_IGNORED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_IGNORED = 6
     * }
     */
    public static int GIT_DELTA_IGNORED() {
        return GIT_DELTA_IGNORED;
    }
    private static final int GIT_DELTA_UNTRACKED = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_UNTRACKED = 7
     * }
     */
    public static int GIT_DELTA_UNTRACKED() {
        return GIT_DELTA_UNTRACKED;
    }
    private static final int GIT_DELTA_TYPECHANGE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_TYPECHANGE = 8
     * }
     */
    public static int GIT_DELTA_TYPECHANGE() {
        return GIT_DELTA_TYPECHANGE;
    }
    private static final int GIT_DELTA_UNREADABLE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_UNREADABLE = 9
     * }
     */
    public static int GIT_DELTA_UNREADABLE() {
        return GIT_DELTA_UNREADABLE;
    }
    private static final int GIT_DELTA_CONFLICTED = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DELTA_CONFLICTED = 10
     * }
     */
    public static int GIT_DELTA_CONFLICTED() {
        return GIT_DELTA_CONFLICTED;
    }

    private static class git_diff_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_options_init(git_diff_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_diff_options_init$descriptor() {
        return git_diff_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_options_init(git_diff_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_diff_options_init$handle() {
        return git_diff_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_options_init(git_diff_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_diff_options_init$address() {
        return git_diff_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_options_init(git_diff_options *opts, unsigned int version)
     * }
     */
    public static int git_diff_options_init(MemorySegment opts, int version) {
        var mh$ = git_diff_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_DIFF_BINARY_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_BINARY_NONE = 0
     * }
     */
    public static int GIT_DIFF_BINARY_NONE() {
        return GIT_DIFF_BINARY_NONE;
    }
    private static final int GIT_DIFF_BINARY_LITERAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_BINARY_LITERAL = 1
     * }
     */
    public static int GIT_DIFF_BINARY_LITERAL() {
        return GIT_DIFF_BINARY_LITERAL;
    }
    private static final int GIT_DIFF_BINARY_DELTA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_BINARY_DELTA = 2
     * }
     */
    public static int GIT_DIFF_BINARY_DELTA() {
        return GIT_DIFF_BINARY_DELTA;
    }
    private static final int GIT_DIFF_LINE_CONTEXT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_LINE_CONTEXT = 32
     * }
     */
    public static int GIT_DIFF_LINE_CONTEXT() {
        return GIT_DIFF_LINE_CONTEXT;
    }
    private static final int GIT_DIFF_LINE_ADDITION = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_LINE_ADDITION = 43
     * }
     */
    public static int GIT_DIFF_LINE_ADDITION() {
        return GIT_DIFF_LINE_ADDITION;
    }
    private static final int GIT_DIFF_LINE_DELETION = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_LINE_DELETION = 45
     * }
     */
    public static int GIT_DIFF_LINE_DELETION() {
        return GIT_DIFF_LINE_DELETION;
    }
    private static final int GIT_DIFF_LINE_CONTEXT_EOFNL = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_LINE_CONTEXT_EOFNL = 61
     * }
     */
    public static int GIT_DIFF_LINE_CONTEXT_EOFNL() {
        return GIT_DIFF_LINE_CONTEXT_EOFNL;
    }
    private static final int GIT_DIFF_LINE_ADD_EOFNL = (int)62L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_LINE_ADD_EOFNL = 62
     * }
     */
    public static int GIT_DIFF_LINE_ADD_EOFNL() {
        return GIT_DIFF_LINE_ADD_EOFNL;
    }
    private static final int GIT_DIFF_LINE_DEL_EOFNL = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_LINE_DEL_EOFNL = 60
     * }
     */
    public static int GIT_DIFF_LINE_DEL_EOFNL() {
        return GIT_DIFF_LINE_DEL_EOFNL;
    }
    private static final int GIT_DIFF_LINE_FILE_HDR = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_LINE_FILE_HDR = 70
     * }
     */
    public static int GIT_DIFF_LINE_FILE_HDR() {
        return GIT_DIFF_LINE_FILE_HDR;
    }
    private static final int GIT_DIFF_LINE_HUNK_HDR = (int)72L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_LINE_HUNK_HDR = 72
     * }
     */
    public static int GIT_DIFF_LINE_HUNK_HDR() {
        return GIT_DIFF_LINE_HUNK_HDR;
    }
    private static final int GIT_DIFF_LINE_BINARY = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_LINE_BINARY = 66
     * }
     */
    public static int GIT_DIFF_LINE_BINARY() {
        return GIT_DIFF_LINE_BINARY;
    }
    private static final int GIT_DIFF_FIND_BY_CONFIG = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_BY_CONFIG = 0
     * }
     */
    public static int GIT_DIFF_FIND_BY_CONFIG() {
        return GIT_DIFF_FIND_BY_CONFIG;
    }
    private static final int GIT_DIFF_FIND_RENAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_RENAMES = 1
     * }
     */
    public static int GIT_DIFF_FIND_RENAMES() {
        return GIT_DIFF_FIND_RENAMES;
    }
    private static final int GIT_DIFF_FIND_RENAMES_FROM_REWRITES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_RENAMES_FROM_REWRITES = 2
     * }
     */
    public static int GIT_DIFF_FIND_RENAMES_FROM_REWRITES() {
        return GIT_DIFF_FIND_RENAMES_FROM_REWRITES;
    }
    private static final int GIT_DIFF_FIND_COPIES = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_COPIES = 4
     * }
     */
    public static int GIT_DIFF_FIND_COPIES() {
        return GIT_DIFF_FIND_COPIES;
    }
    private static final int GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED = 8
     * }
     */
    public static int GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED() {
        return GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED;
    }
    private static final int GIT_DIFF_FIND_REWRITES = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_REWRITES = 16
     * }
     */
    public static int GIT_DIFF_FIND_REWRITES() {
        return GIT_DIFF_FIND_REWRITES;
    }
    private static final int GIT_DIFF_BREAK_REWRITES = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_BREAK_REWRITES = 32
     * }
     */
    public static int GIT_DIFF_BREAK_REWRITES() {
        return GIT_DIFF_BREAK_REWRITES;
    }
    private static final int GIT_DIFF_FIND_AND_BREAK_REWRITES = (int)48L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_AND_BREAK_REWRITES = 48
     * }
     */
    public static int GIT_DIFF_FIND_AND_BREAK_REWRITES() {
        return GIT_DIFF_FIND_AND_BREAK_REWRITES;
    }
    private static final int GIT_DIFF_FIND_FOR_UNTRACKED = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_FOR_UNTRACKED = 64
     * }
     */
    public static int GIT_DIFF_FIND_FOR_UNTRACKED() {
        return GIT_DIFF_FIND_FOR_UNTRACKED;
    }
    private static final int GIT_DIFF_FIND_ALL = (int)255L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_ALL = 255
     * }
     */
    public static int GIT_DIFF_FIND_ALL() {
        return GIT_DIFF_FIND_ALL;
    }
    private static final int GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE = 0
     * }
     */
    public static int GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE() {
        return GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE;
    }
    private static final int GIT_DIFF_FIND_IGNORE_WHITESPACE = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_IGNORE_WHITESPACE = 4096
     * }
     */
    public static int GIT_DIFF_FIND_IGNORE_WHITESPACE() {
        return GIT_DIFF_FIND_IGNORE_WHITESPACE;
    }
    private static final int GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE = 8192
     * }
     */
    public static int GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE() {
        return GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE;
    }
    private static final int GIT_DIFF_FIND_EXACT_MATCH_ONLY = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_EXACT_MATCH_ONLY = 16384
     * }
     */
    public static int GIT_DIFF_FIND_EXACT_MATCH_ONLY() {
        return GIT_DIFF_FIND_EXACT_MATCH_ONLY;
    }
    private static final int GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY = 32768
     * }
     */
    public static int GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY() {
        return GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY;
    }
    private static final int GIT_DIFF_FIND_REMOVE_UNMODIFIED = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FIND_REMOVE_UNMODIFIED = 65536
     * }
     */
    public static int GIT_DIFF_FIND_REMOVE_UNMODIFIED() {
        return GIT_DIFF_FIND_REMOVE_UNMODIFIED;
    }

    private static class git_diff_find_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_find_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_find_options_init(git_diff_find_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_diff_find_options_init$descriptor() {
        return git_diff_find_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_find_options_init(git_diff_find_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_diff_find_options_init$handle() {
        return git_diff_find_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_find_options_init(git_diff_find_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_diff_find_options_init$address() {
        return git_diff_find_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_find_options_init(git_diff_find_options *opts, unsigned int version)
     * }
     */
    public static int git_diff_find_options_init(MemorySegment opts, int version) {
        var mh$ = git_diff_find_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_find_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_diff_free(git_diff *diff)
     * }
     */
    public static FunctionDescriptor git_diff_free$descriptor() {
        return git_diff_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_diff_free(git_diff *diff)
     * }
     */
    public static MethodHandle git_diff_free$handle() {
        return git_diff_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_diff_free(git_diff *diff)
     * }
     */
    public static MemorySegment git_diff_free$address() {
        return git_diff_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_diff_free(git_diff *diff)
     * }
     */
    public static void git_diff_free(MemorySegment diff) {
        var mh$ = git_diff_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_free", diff);
            }
            mh$.invokeExact(diff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_tree_to_tree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_tree_to_tree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_tree(git_diff **diff, git_repository *repo, git_tree *old_tree, git_tree *new_tree, const git_diff_options *opts)
     * }
     */
    public static FunctionDescriptor git_diff_tree_to_tree$descriptor() {
        return git_diff_tree_to_tree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_tree(git_diff **diff, git_repository *repo, git_tree *old_tree, git_tree *new_tree, const git_diff_options *opts)
     * }
     */
    public static MethodHandle git_diff_tree_to_tree$handle() {
        return git_diff_tree_to_tree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_tree(git_diff **diff, git_repository *repo, git_tree *old_tree, git_tree *new_tree, const git_diff_options *opts)
     * }
     */
    public static MemorySegment git_diff_tree_to_tree$address() {
        return git_diff_tree_to_tree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_tree_to_tree(git_diff **diff, git_repository *repo, git_tree *old_tree, git_tree *new_tree, const git_diff_options *opts)
     * }
     */
    public static int git_diff_tree_to_tree(MemorySegment diff, MemorySegment repo, MemorySegment old_tree, MemorySegment new_tree, MemorySegment opts) {
        var mh$ = git_diff_tree_to_tree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_tree_to_tree", diff, repo, old_tree, new_tree, opts);
            }
            return (int)mh$.invokeExact(diff, repo, old_tree, new_tree, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_tree_to_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_tree_to_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_index(git_diff **diff, git_repository *repo, git_tree *old_tree, git_index *index, const git_diff_options *opts)
     * }
     */
    public static FunctionDescriptor git_diff_tree_to_index$descriptor() {
        return git_diff_tree_to_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_index(git_diff **diff, git_repository *repo, git_tree *old_tree, git_index *index, const git_diff_options *opts)
     * }
     */
    public static MethodHandle git_diff_tree_to_index$handle() {
        return git_diff_tree_to_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_index(git_diff **diff, git_repository *repo, git_tree *old_tree, git_index *index, const git_diff_options *opts)
     * }
     */
    public static MemorySegment git_diff_tree_to_index$address() {
        return git_diff_tree_to_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_tree_to_index(git_diff **diff, git_repository *repo, git_tree *old_tree, git_index *index, const git_diff_options *opts)
     * }
     */
    public static int git_diff_tree_to_index(MemorySegment diff, MemorySegment repo, MemorySegment old_tree, MemorySegment index, MemorySegment opts) {
        var mh$ = git_diff_tree_to_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_tree_to_index", diff, repo, old_tree, index, opts);
            }
            return (int)mh$.invokeExact(diff, repo, old_tree, index, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_index_to_workdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_index_to_workdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_index_to_workdir(git_diff **diff, git_repository *repo, git_index *index, const git_diff_options *opts)
     * }
     */
    public static FunctionDescriptor git_diff_index_to_workdir$descriptor() {
        return git_diff_index_to_workdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_index_to_workdir(git_diff **diff, git_repository *repo, git_index *index, const git_diff_options *opts)
     * }
     */
    public static MethodHandle git_diff_index_to_workdir$handle() {
        return git_diff_index_to_workdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_index_to_workdir(git_diff **diff, git_repository *repo, git_index *index, const git_diff_options *opts)
     * }
     */
    public static MemorySegment git_diff_index_to_workdir$address() {
        return git_diff_index_to_workdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_index_to_workdir(git_diff **diff, git_repository *repo, git_index *index, const git_diff_options *opts)
     * }
     */
    public static int git_diff_index_to_workdir(MemorySegment diff, MemorySegment repo, MemorySegment index, MemorySegment opts) {
        var mh$ = git_diff_index_to_workdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_index_to_workdir", diff, repo, index, opts);
            }
            return (int)mh$.invokeExact(diff, repo, index, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_tree_to_workdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_tree_to_workdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_workdir(git_diff **diff, git_repository *repo, git_tree *old_tree, const git_diff_options *opts)
     * }
     */
    public static FunctionDescriptor git_diff_tree_to_workdir$descriptor() {
        return git_diff_tree_to_workdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_workdir(git_diff **diff, git_repository *repo, git_tree *old_tree, const git_diff_options *opts)
     * }
     */
    public static MethodHandle git_diff_tree_to_workdir$handle() {
        return git_diff_tree_to_workdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_workdir(git_diff **diff, git_repository *repo, git_tree *old_tree, const git_diff_options *opts)
     * }
     */
    public static MemorySegment git_diff_tree_to_workdir$address() {
        return git_diff_tree_to_workdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_tree_to_workdir(git_diff **diff, git_repository *repo, git_tree *old_tree, const git_diff_options *opts)
     * }
     */
    public static int git_diff_tree_to_workdir(MemorySegment diff, MemorySegment repo, MemorySegment old_tree, MemorySegment opts) {
        var mh$ = git_diff_tree_to_workdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_tree_to_workdir", diff, repo, old_tree, opts);
            }
            return (int)mh$.invokeExact(diff, repo, old_tree, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_tree_to_workdir_with_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_tree_to_workdir_with_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_workdir_with_index(git_diff **diff, git_repository *repo, git_tree *old_tree, const git_diff_options *opts)
     * }
     */
    public static FunctionDescriptor git_diff_tree_to_workdir_with_index$descriptor() {
        return git_diff_tree_to_workdir_with_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_workdir_with_index(git_diff **diff, git_repository *repo, git_tree *old_tree, const git_diff_options *opts)
     * }
     */
    public static MethodHandle git_diff_tree_to_workdir_with_index$handle() {
        return git_diff_tree_to_workdir_with_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_tree_to_workdir_with_index(git_diff **diff, git_repository *repo, git_tree *old_tree, const git_diff_options *opts)
     * }
     */
    public static MemorySegment git_diff_tree_to_workdir_with_index$address() {
        return git_diff_tree_to_workdir_with_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_tree_to_workdir_with_index(git_diff **diff, git_repository *repo, git_tree *old_tree, const git_diff_options *opts)
     * }
     */
    public static int git_diff_tree_to_workdir_with_index(MemorySegment diff, MemorySegment repo, MemorySegment old_tree, MemorySegment opts) {
        var mh$ = git_diff_tree_to_workdir_with_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_tree_to_workdir_with_index", diff, repo, old_tree, opts);
            }
            return (int)mh$.invokeExact(diff, repo, old_tree, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_index_to_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_index_to_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_index_to_index(git_diff **diff, git_repository *repo, git_index *old_index, git_index *new_index, const git_diff_options *opts)
     * }
     */
    public static FunctionDescriptor git_diff_index_to_index$descriptor() {
        return git_diff_index_to_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_index_to_index(git_diff **diff, git_repository *repo, git_index *old_index, git_index *new_index, const git_diff_options *opts)
     * }
     */
    public static MethodHandle git_diff_index_to_index$handle() {
        return git_diff_index_to_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_index_to_index(git_diff **diff, git_repository *repo, git_index *old_index, git_index *new_index, const git_diff_options *opts)
     * }
     */
    public static MemorySegment git_diff_index_to_index$address() {
        return git_diff_index_to_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_index_to_index(git_diff **diff, git_repository *repo, git_index *old_index, git_index *new_index, const git_diff_options *opts)
     * }
     */
    public static int git_diff_index_to_index(MemorySegment diff, MemorySegment repo, MemorySegment old_index, MemorySegment new_index, MemorySegment opts) {
        var mh$ = git_diff_index_to_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_index_to_index", diff, repo, old_index, new_index, opts);
            }
            return (int)mh$.invokeExact(diff, repo, old_index, new_index, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_merge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_merge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_merge(git_diff *onto, const git_diff *from)
     * }
     */
    public static FunctionDescriptor git_diff_merge$descriptor() {
        return git_diff_merge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_merge(git_diff *onto, const git_diff *from)
     * }
     */
    public static MethodHandle git_diff_merge$handle() {
        return git_diff_merge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_merge(git_diff *onto, const git_diff *from)
     * }
     */
    public static MemorySegment git_diff_merge$address() {
        return git_diff_merge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_merge(git_diff *onto, const git_diff *from)
     * }
     */
    public static int git_diff_merge(MemorySegment onto, MemorySegment from) {
        var mh$ = git_diff_merge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_merge", onto, from);
            }
            return (int)mh$.invokeExact(onto, from);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_find_similar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_find_similar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_find_similar(git_diff *diff, const git_diff_find_options *options)
     * }
     */
    public static FunctionDescriptor git_diff_find_similar$descriptor() {
        return git_diff_find_similar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_find_similar(git_diff *diff, const git_diff_find_options *options)
     * }
     */
    public static MethodHandle git_diff_find_similar$handle() {
        return git_diff_find_similar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_find_similar(git_diff *diff, const git_diff_find_options *options)
     * }
     */
    public static MemorySegment git_diff_find_similar$address() {
        return git_diff_find_similar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_find_similar(git_diff *diff, const git_diff_find_options *options)
     * }
     */
    public static int git_diff_find_similar(MemorySegment diff, MemorySegment options) {
        var mh$ = git_diff_find_similar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_find_similar", diff, options);
            }
            return (int)mh$.invokeExact(diff, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_num_deltas {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_num_deltas");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_diff_num_deltas(const git_diff *diff)
     * }
     */
    public static FunctionDescriptor git_diff_num_deltas$descriptor() {
        return git_diff_num_deltas.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_diff_num_deltas(const git_diff *diff)
     * }
     */
    public static MethodHandle git_diff_num_deltas$handle() {
        return git_diff_num_deltas.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_diff_num_deltas(const git_diff *diff)
     * }
     */
    public static MemorySegment git_diff_num_deltas$address() {
        return git_diff_num_deltas.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_diff_num_deltas(const git_diff *diff)
     * }
     */
    public static long git_diff_num_deltas(MemorySegment diff) {
        var mh$ = git_diff_num_deltas.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_num_deltas", diff);
            }
            return (long)mh$.invokeExact(diff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_num_deltas_of_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_num_deltas_of_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_diff_num_deltas_of_type(const git_diff *diff, git_delta_t type)
     * }
     */
    public static FunctionDescriptor git_diff_num_deltas_of_type$descriptor() {
        return git_diff_num_deltas_of_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_diff_num_deltas_of_type(const git_diff *diff, git_delta_t type)
     * }
     */
    public static MethodHandle git_diff_num_deltas_of_type$handle() {
        return git_diff_num_deltas_of_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_diff_num_deltas_of_type(const git_diff *diff, git_delta_t type)
     * }
     */
    public static MemorySegment git_diff_num_deltas_of_type$address() {
        return git_diff_num_deltas_of_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_diff_num_deltas_of_type(const git_diff *diff, git_delta_t type)
     * }
     */
    public static long git_diff_num_deltas_of_type(MemorySegment diff, int type) {
        var mh$ = git_diff_num_deltas_of_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_num_deltas_of_type", diff, type);
            }
            return (long)mh$.invokeExact(diff, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_get_delta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_get_delta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)
     * }
     */
    public static FunctionDescriptor git_diff_get_delta$descriptor() {
        return git_diff_get_delta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)
     * }
     */
    public static MethodHandle git_diff_get_delta$handle() {
        return git_diff_get_delta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)
     * }
     */
    public static MemorySegment git_diff_get_delta$address() {
        return git_diff_get_delta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)
     * }
     */
    public static MemorySegment git_diff_get_delta(MemorySegment diff, long idx) {
        var mh$ = git_diff_get_delta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_get_delta", diff, idx);
            }
            return (MemorySegment)mh$.invokeExact(diff, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_is_sorted_icase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_is_sorted_icase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_is_sorted_icase(const git_diff *diff)
     * }
     */
    public static FunctionDescriptor git_diff_is_sorted_icase$descriptor() {
        return git_diff_is_sorted_icase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_is_sorted_icase(const git_diff *diff)
     * }
     */
    public static MethodHandle git_diff_is_sorted_icase$handle() {
        return git_diff_is_sorted_icase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_is_sorted_icase(const git_diff *diff)
     * }
     */
    public static MemorySegment git_diff_is_sorted_icase$address() {
        return git_diff_is_sorted_icase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_is_sorted_icase(const git_diff *diff)
     * }
     */
    public static int git_diff_is_sorted_icase(MemorySegment diff) {
        var mh$ = git_diff_is_sorted_icase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_is_sorted_icase", diff);
            }
            return (int)mh$.invokeExact(diff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_foreach(git_diff *diff, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static FunctionDescriptor git_diff_foreach$descriptor() {
        return git_diff_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_foreach(git_diff *diff, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static MethodHandle git_diff_foreach$handle() {
        return git_diff_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_foreach(git_diff *diff, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static MemorySegment git_diff_foreach$address() {
        return git_diff_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_foreach(git_diff *diff, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static int git_diff_foreach(MemorySegment diff, MemorySegment file_cb, MemorySegment binary_cb, MemorySegment hunk_cb, MemorySegment line_cb, MemorySegment payload) {
        var mh$ = git_diff_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_foreach", diff, file_cb, binary_cb, hunk_cb, line_cb, payload);
            }
            return (int)mh$.invokeExact(diff, file_cb, binary_cb, hunk_cb, line_cb, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_status_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_CHAR,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_status_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char git_diff_status_char(git_delta_t status)
     * }
     */
    public static FunctionDescriptor git_diff_status_char$descriptor() {
        return git_diff_status_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char git_diff_status_char(git_delta_t status)
     * }
     */
    public static MethodHandle git_diff_status_char$handle() {
        return git_diff_status_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char git_diff_status_char(git_delta_t status)
     * }
     */
    public static MemorySegment git_diff_status_char$address() {
        return git_diff_status_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char git_diff_status_char(git_delta_t status)
     * }
     */
    public static byte git_diff_status_char(int status) {
        var mh$ = git_diff_status_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_status_char", status);
            }
            return (byte)mh$.invokeExact(status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_DIFF_FORMAT_PATCH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FORMAT_PATCH = 1
     * }
     */
    public static int GIT_DIFF_FORMAT_PATCH() {
        return GIT_DIFF_FORMAT_PATCH;
    }
    private static final int GIT_DIFF_FORMAT_PATCH_HEADER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FORMAT_PATCH_HEADER = 2
     * }
     */
    public static int GIT_DIFF_FORMAT_PATCH_HEADER() {
        return GIT_DIFF_FORMAT_PATCH_HEADER;
    }
    private static final int GIT_DIFF_FORMAT_RAW = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FORMAT_RAW = 3
     * }
     */
    public static int GIT_DIFF_FORMAT_RAW() {
        return GIT_DIFF_FORMAT_RAW;
    }
    private static final int GIT_DIFF_FORMAT_NAME_ONLY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FORMAT_NAME_ONLY = 4
     * }
     */
    public static int GIT_DIFF_FORMAT_NAME_ONLY() {
        return GIT_DIFF_FORMAT_NAME_ONLY;
    }
    private static final int GIT_DIFF_FORMAT_NAME_STATUS = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FORMAT_NAME_STATUS = 5
     * }
     */
    public static int GIT_DIFF_FORMAT_NAME_STATUS() {
        return GIT_DIFF_FORMAT_NAME_STATUS;
    }
    private static final int GIT_DIFF_FORMAT_PATCH_ID = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FORMAT_PATCH_ID = 6
     * }
     */
    public static int GIT_DIFF_FORMAT_PATCH_ID() {
        return GIT_DIFF_FORMAT_PATCH_ID;
    }

    private static class git_diff_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_print(git_diff *diff, git_diff_format_t format, git_diff_line_cb print_cb, void *payload)
     * }
     */
    public static FunctionDescriptor git_diff_print$descriptor() {
        return git_diff_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_print(git_diff *diff, git_diff_format_t format, git_diff_line_cb print_cb, void *payload)
     * }
     */
    public static MethodHandle git_diff_print$handle() {
        return git_diff_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_print(git_diff *diff, git_diff_format_t format, git_diff_line_cb print_cb, void *payload)
     * }
     */
    public static MemorySegment git_diff_print$address() {
        return git_diff_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_print(git_diff *diff, git_diff_format_t format, git_diff_line_cb print_cb, void *payload)
     * }
     */
    public static int git_diff_print(MemorySegment diff, int format, MemorySegment print_cb, MemorySegment payload) {
        var mh$ = git_diff_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_print", diff, format, print_cb, payload);
            }
            return (int)mh$.invokeExact(diff, format, print_cb, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_to_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_to_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_to_buf(git_buf *out, git_diff *diff, git_diff_format_t format)
     * }
     */
    public static FunctionDescriptor git_diff_to_buf$descriptor() {
        return git_diff_to_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_to_buf(git_buf *out, git_diff *diff, git_diff_format_t format)
     * }
     */
    public static MethodHandle git_diff_to_buf$handle() {
        return git_diff_to_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_to_buf(git_buf *out, git_diff *diff, git_diff_format_t format)
     * }
     */
    public static MemorySegment git_diff_to_buf$address() {
        return git_diff_to_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_to_buf(git_buf *out, git_diff *diff, git_diff_format_t format)
     * }
     */
    public static int git_diff_to_buf(MemorySegment out, MemorySegment diff, int format) {
        var mh$ = git_diff_to_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_to_buf", out, diff, format);
            }
            return (int)mh$.invokeExact(out, diff, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_blobs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_blobs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_blobs(const git_blob *old_blob, const char *old_as_path, const git_blob *new_blob, const char *new_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static FunctionDescriptor git_diff_blobs$descriptor() {
        return git_diff_blobs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_blobs(const git_blob *old_blob, const char *old_as_path, const git_blob *new_blob, const char *new_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static MethodHandle git_diff_blobs$handle() {
        return git_diff_blobs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_blobs(const git_blob *old_blob, const char *old_as_path, const git_blob *new_blob, const char *new_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static MemorySegment git_diff_blobs$address() {
        return git_diff_blobs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_blobs(const git_blob *old_blob, const char *old_as_path, const git_blob *new_blob, const char *new_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static int git_diff_blobs(MemorySegment old_blob, MemorySegment old_as_path, MemorySegment new_blob, MemorySegment new_as_path, MemorySegment options, MemorySegment file_cb, MemorySegment binary_cb, MemorySegment hunk_cb, MemorySegment line_cb, MemorySegment payload) {
        var mh$ = git_diff_blobs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_blobs", old_blob, old_as_path, new_blob, new_as_path, options, file_cb, binary_cb, hunk_cb, line_cb, payload);
            }
            return (int)mh$.invokeExact(old_blob, old_as_path, new_blob, new_as_path, options, file_cb, binary_cb, hunk_cb, line_cb, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_blob_to_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_blob_to_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_blob_to_buffer(const git_blob *old_blob, const char *old_as_path, const char *buffer, size_t buffer_len, const char *buffer_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static FunctionDescriptor git_diff_blob_to_buffer$descriptor() {
        return git_diff_blob_to_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_blob_to_buffer(const git_blob *old_blob, const char *old_as_path, const char *buffer, size_t buffer_len, const char *buffer_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static MethodHandle git_diff_blob_to_buffer$handle() {
        return git_diff_blob_to_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_blob_to_buffer(const git_blob *old_blob, const char *old_as_path, const char *buffer, size_t buffer_len, const char *buffer_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static MemorySegment git_diff_blob_to_buffer$address() {
        return git_diff_blob_to_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_blob_to_buffer(const git_blob *old_blob, const char *old_as_path, const char *buffer, size_t buffer_len, const char *buffer_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static int git_diff_blob_to_buffer(MemorySegment old_blob, MemorySegment old_as_path, MemorySegment buffer, long buffer_len, MemorySegment buffer_as_path, MemorySegment options, MemorySegment file_cb, MemorySegment binary_cb, MemorySegment hunk_cb, MemorySegment line_cb, MemorySegment payload) {
        var mh$ = git_diff_blob_to_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_blob_to_buffer", old_blob, old_as_path, buffer, buffer_len, buffer_as_path, options, file_cb, binary_cb, hunk_cb, line_cb, payload);
            }
            return (int)mh$.invokeExact(old_blob, old_as_path, buffer, buffer_len, buffer_as_path, options, file_cb, binary_cb, hunk_cb, line_cb, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_buffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_buffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_buffers(const void *old_buffer, size_t old_len, const char *old_as_path, const void *new_buffer, size_t new_len, const char *new_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static FunctionDescriptor git_diff_buffers$descriptor() {
        return git_diff_buffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_buffers(const void *old_buffer, size_t old_len, const char *old_as_path, const void *new_buffer, size_t new_len, const char *new_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static MethodHandle git_diff_buffers$handle() {
        return git_diff_buffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_buffers(const void *old_buffer, size_t old_len, const char *old_as_path, const void *new_buffer, size_t new_len, const char *new_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static MemorySegment git_diff_buffers$address() {
        return git_diff_buffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_buffers(const void *old_buffer, size_t old_len, const char *old_as_path, const void *new_buffer, size_t new_len, const char *new_as_path, const git_diff_options *options, git_diff_file_cb file_cb, git_diff_binary_cb binary_cb, git_diff_hunk_cb hunk_cb, git_diff_line_cb line_cb, void *payload)
     * }
     */
    public static int git_diff_buffers(MemorySegment old_buffer, long old_len, MemorySegment old_as_path, MemorySegment new_buffer, long new_len, MemorySegment new_as_path, MemorySegment options, MemorySegment file_cb, MemorySegment binary_cb, MemorySegment hunk_cb, MemorySegment line_cb, MemorySegment payload) {
        var mh$ = git_diff_buffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_buffers", old_buffer, old_len, old_as_path, new_buffer, new_len, new_as_path, options, file_cb, binary_cb, hunk_cb, line_cb, payload);
            }
            return (int)mh$.invokeExact(old_buffer, old_len, old_as_path, new_buffer, new_len, new_as_path, options, file_cb, binary_cb, hunk_cb, line_cb, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_from_buffer(git_diff **out, const char *content, size_t content_len)
     * }
     */
    public static FunctionDescriptor git_diff_from_buffer$descriptor() {
        return git_diff_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_from_buffer(git_diff **out, const char *content, size_t content_len)
     * }
     */
    public static MethodHandle git_diff_from_buffer$handle() {
        return git_diff_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_from_buffer(git_diff **out, const char *content, size_t content_len)
     * }
     */
    public static MemorySegment git_diff_from_buffer$address() {
        return git_diff_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_from_buffer(git_diff **out, const char *content, size_t content_len)
     * }
     */
    public static int git_diff_from_buffer(MemorySegment out, MemorySegment content, long content_len) {
        var mh$ = git_diff_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_from_buffer", out, content, content_len);
            }
            return (int)mh$.invokeExact(out, content, content_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_DIFF_STATS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_STATS_NONE = 0
     * }
     */
    public static int GIT_DIFF_STATS_NONE() {
        return GIT_DIFF_STATS_NONE;
    }
    private static final int GIT_DIFF_STATS_FULL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_STATS_FULL = 1
     * }
     */
    public static int GIT_DIFF_STATS_FULL() {
        return GIT_DIFF_STATS_FULL;
    }
    private static final int GIT_DIFF_STATS_SHORT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_STATS_SHORT = 2
     * }
     */
    public static int GIT_DIFF_STATS_SHORT() {
        return GIT_DIFF_STATS_SHORT;
    }
    private static final int GIT_DIFF_STATS_NUMBER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_STATS_NUMBER = 4
     * }
     */
    public static int GIT_DIFF_STATS_NUMBER() {
        return GIT_DIFF_STATS_NUMBER;
    }
    private static final int GIT_DIFF_STATS_INCLUDE_SUMMARY = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_STATS_INCLUDE_SUMMARY = 8
     * }
     */
    public static int GIT_DIFF_STATS_INCLUDE_SUMMARY() {
        return GIT_DIFF_STATS_INCLUDE_SUMMARY;
    }

    private static class git_diff_get_stats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_get_stats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_get_stats(git_diff_stats **out, git_diff *diff)
     * }
     */
    public static FunctionDescriptor git_diff_get_stats$descriptor() {
        return git_diff_get_stats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_get_stats(git_diff_stats **out, git_diff *diff)
     * }
     */
    public static MethodHandle git_diff_get_stats$handle() {
        return git_diff_get_stats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_get_stats(git_diff_stats **out, git_diff *diff)
     * }
     */
    public static MemorySegment git_diff_get_stats$address() {
        return git_diff_get_stats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_get_stats(git_diff_stats **out, git_diff *diff)
     * }
     */
    public static int git_diff_get_stats(MemorySegment out, MemorySegment diff) {
        var mh$ = git_diff_get_stats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_get_stats", out, diff);
            }
            return (int)mh$.invokeExact(out, diff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_stats_files_changed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_stats_files_changed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_diff_stats_files_changed(const git_diff_stats *stats)
     * }
     */
    public static FunctionDescriptor git_diff_stats_files_changed$descriptor() {
        return git_diff_stats_files_changed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_diff_stats_files_changed(const git_diff_stats *stats)
     * }
     */
    public static MethodHandle git_diff_stats_files_changed$handle() {
        return git_diff_stats_files_changed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_diff_stats_files_changed(const git_diff_stats *stats)
     * }
     */
    public static MemorySegment git_diff_stats_files_changed$address() {
        return git_diff_stats_files_changed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_diff_stats_files_changed(const git_diff_stats *stats)
     * }
     */
    public static long git_diff_stats_files_changed(MemorySegment stats) {
        var mh$ = git_diff_stats_files_changed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_stats_files_changed", stats);
            }
            return (long)mh$.invokeExact(stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_stats_insertions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_stats_insertions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_diff_stats_insertions(const git_diff_stats *stats)
     * }
     */
    public static FunctionDescriptor git_diff_stats_insertions$descriptor() {
        return git_diff_stats_insertions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_diff_stats_insertions(const git_diff_stats *stats)
     * }
     */
    public static MethodHandle git_diff_stats_insertions$handle() {
        return git_diff_stats_insertions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_diff_stats_insertions(const git_diff_stats *stats)
     * }
     */
    public static MemorySegment git_diff_stats_insertions$address() {
        return git_diff_stats_insertions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_diff_stats_insertions(const git_diff_stats *stats)
     * }
     */
    public static long git_diff_stats_insertions(MemorySegment stats) {
        var mh$ = git_diff_stats_insertions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_stats_insertions", stats);
            }
            return (long)mh$.invokeExact(stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_stats_deletions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_stats_deletions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_diff_stats_deletions(const git_diff_stats *stats)
     * }
     */
    public static FunctionDescriptor git_diff_stats_deletions$descriptor() {
        return git_diff_stats_deletions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_diff_stats_deletions(const git_diff_stats *stats)
     * }
     */
    public static MethodHandle git_diff_stats_deletions$handle() {
        return git_diff_stats_deletions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_diff_stats_deletions(const git_diff_stats *stats)
     * }
     */
    public static MemorySegment git_diff_stats_deletions$address() {
        return git_diff_stats_deletions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_diff_stats_deletions(const git_diff_stats *stats)
     * }
     */
    public static long git_diff_stats_deletions(MemorySegment stats) {
        var mh$ = git_diff_stats_deletions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_stats_deletions", stats);
            }
            return (long)mh$.invokeExact(stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_stats_to_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_stats_to_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_stats_to_buf(git_buf *out, const git_diff_stats *stats, git_diff_stats_format_t format, size_t width)
     * }
     */
    public static FunctionDescriptor git_diff_stats_to_buf$descriptor() {
        return git_diff_stats_to_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_stats_to_buf(git_buf *out, const git_diff_stats *stats, git_diff_stats_format_t format, size_t width)
     * }
     */
    public static MethodHandle git_diff_stats_to_buf$handle() {
        return git_diff_stats_to_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_stats_to_buf(git_buf *out, const git_diff_stats *stats, git_diff_stats_format_t format, size_t width)
     * }
     */
    public static MemorySegment git_diff_stats_to_buf$address() {
        return git_diff_stats_to_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_stats_to_buf(git_buf *out, const git_diff_stats *stats, git_diff_stats_format_t format, size_t width)
     * }
     */
    public static int git_diff_stats_to_buf(MemorySegment out, MemorySegment stats, int format, long width) {
        var mh$ = git_diff_stats_to_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_stats_to_buf", out, stats, format, width);
            }
            return (int)mh$.invokeExact(out, stats, format, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_stats_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_stats_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_diff_stats_free(git_diff_stats *stats)
     * }
     */
    public static FunctionDescriptor git_diff_stats_free$descriptor() {
        return git_diff_stats_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_diff_stats_free(git_diff_stats *stats)
     * }
     */
    public static MethodHandle git_diff_stats_free$handle() {
        return git_diff_stats_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_diff_stats_free(git_diff_stats *stats)
     * }
     */
    public static MemorySegment git_diff_stats_free$address() {
        return git_diff_stats_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_diff_stats_free(git_diff_stats *stats)
     * }
     */
    public static void git_diff_stats_free(MemorySegment stats) {
        var mh$ = git_diff_stats_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_stats_free", stats);
            }
            mh$.invokeExact(stats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_patchid_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_patchid_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_patchid_options_init(git_diff_patchid_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_diff_patchid_options_init$descriptor() {
        return git_diff_patchid_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_patchid_options_init(git_diff_patchid_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_diff_patchid_options_init$handle() {
        return git_diff_patchid_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_patchid_options_init(git_diff_patchid_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_diff_patchid_options_init$address() {
        return git_diff_patchid_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_patchid_options_init(git_diff_patchid_options *opts, unsigned int version)
     * }
     */
    public static int git_diff_patchid_options_init(MemorySegment opts, int version) {
        var mh$ = git_diff_patchid_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_patchid_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_patchid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_patchid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_patchid(git_oid *out, git_diff *diff, git_diff_patchid_options *opts)
     * }
     */
    public static FunctionDescriptor git_diff_patchid$descriptor() {
        return git_diff_patchid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_patchid(git_oid *out, git_diff *diff, git_diff_patchid_options *opts)
     * }
     */
    public static MethodHandle git_diff_patchid$handle() {
        return git_diff_patchid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_patchid(git_oid *out, git_diff *diff, git_diff_patchid_options *opts)
     * }
     */
    public static MemorySegment git_diff_patchid$address() {
        return git_diff_patchid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_patchid(git_oid *out, git_diff *diff, git_diff_patchid_options *opts)
     * }
     */
    public static int git_diff_patchid(MemorySegment out, MemorySegment diff, MemorySegment opts) {
        var mh$ = git_diff_patchid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_patchid", out, diff, opts);
            }
            return (int)mh$.invokeExact(out, diff, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_APPLY_CHECK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_APPLY_CHECK = 1
     * }
     */
    public static int GIT_APPLY_CHECK() {
        return GIT_APPLY_CHECK;
    }

    private static class git_apply_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_apply_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_apply_options_init(git_apply_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_apply_options_init$descriptor() {
        return git_apply_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_apply_options_init(git_apply_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_apply_options_init$handle() {
        return git_apply_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_apply_options_init(git_apply_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_apply_options_init$address() {
        return git_apply_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_apply_options_init(git_apply_options *opts, unsigned int version)
     * }
     */
    public static int git_apply_options_init(MemorySegment opts, int version) {
        var mh$ = git_apply_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_apply_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_apply_to_tree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_apply_to_tree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_apply_to_tree(git_index **out, git_repository *repo, git_tree *preimage, git_diff *diff, const git_apply_options *options)
     * }
     */
    public static FunctionDescriptor git_apply_to_tree$descriptor() {
        return git_apply_to_tree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_apply_to_tree(git_index **out, git_repository *repo, git_tree *preimage, git_diff *diff, const git_apply_options *options)
     * }
     */
    public static MethodHandle git_apply_to_tree$handle() {
        return git_apply_to_tree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_apply_to_tree(git_index **out, git_repository *repo, git_tree *preimage, git_diff *diff, const git_apply_options *options)
     * }
     */
    public static MemorySegment git_apply_to_tree$address() {
        return git_apply_to_tree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_apply_to_tree(git_index **out, git_repository *repo, git_tree *preimage, git_diff *diff, const git_apply_options *options)
     * }
     */
    public static int git_apply_to_tree(MemorySegment out, MemorySegment repo, MemorySegment preimage, MemorySegment diff, MemorySegment options) {
        var mh$ = git_apply_to_tree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_apply_to_tree", out, repo, preimage, diff, options);
            }
            return (int)mh$.invokeExact(out, repo, preimage, diff, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_APPLY_LOCATION_WORKDIR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_APPLY_LOCATION_WORKDIR = 0
     * }
     */
    public static int GIT_APPLY_LOCATION_WORKDIR() {
        return GIT_APPLY_LOCATION_WORKDIR;
    }
    private static final int GIT_APPLY_LOCATION_INDEX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_APPLY_LOCATION_INDEX = 1
     * }
     */
    public static int GIT_APPLY_LOCATION_INDEX() {
        return GIT_APPLY_LOCATION_INDEX;
    }
    private static final int GIT_APPLY_LOCATION_BOTH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_APPLY_LOCATION_BOTH = 2
     * }
     */
    public static int GIT_APPLY_LOCATION_BOTH() {
        return GIT_APPLY_LOCATION_BOTH;
    }

    private static class git_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_apply(git_repository *repo, git_diff *diff, git_apply_location_t location, const git_apply_options *options)
     * }
     */
    public static FunctionDescriptor git_apply$descriptor() {
        return git_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_apply(git_repository *repo, git_diff *diff, git_apply_location_t location, const git_apply_options *options)
     * }
     */
    public static MethodHandle git_apply$handle() {
        return git_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_apply(git_repository *repo, git_diff *diff, git_apply_location_t location, const git_apply_options *options)
     * }
     */
    public static MemorySegment git_apply$address() {
        return git_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_apply(git_repository *repo, git_diff *diff, git_apply_location_t location, const git_apply_options *options)
     * }
     */
    public static int git_apply(MemorySegment repo, MemorySegment diff, int location, MemorySegment options) {
        var mh$ = git_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_apply", repo, diff, location, options);
            }
            return (int)mh$.invokeExact(repo, diff, location, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_ATTR_VALUE_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ATTR_VALUE_UNSPECIFIED = 0
     * }
     */
    public static int GIT_ATTR_VALUE_UNSPECIFIED() {
        return GIT_ATTR_VALUE_UNSPECIFIED;
    }
    private static final int GIT_ATTR_VALUE_TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ATTR_VALUE_TRUE = 1
     * }
     */
    public static int GIT_ATTR_VALUE_TRUE() {
        return GIT_ATTR_VALUE_TRUE;
    }
    private static final int GIT_ATTR_VALUE_FALSE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ATTR_VALUE_FALSE = 2
     * }
     */
    public static int GIT_ATTR_VALUE_FALSE() {
        return GIT_ATTR_VALUE_FALSE;
    }
    private static final int GIT_ATTR_VALUE_STRING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ATTR_VALUE_STRING = 3
     * }
     */
    public static int GIT_ATTR_VALUE_STRING() {
        return GIT_ATTR_VALUE_STRING;
    }

    private static class git_attr_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_attr_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_attr_value_t git_attr_value(const char *attr)
     * }
     */
    public static FunctionDescriptor git_attr_value$descriptor() {
        return git_attr_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_attr_value_t git_attr_value(const char *attr)
     * }
     */
    public static MethodHandle git_attr_value$handle() {
        return git_attr_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_attr_value_t git_attr_value(const char *attr)
     * }
     */
    public static MemorySegment git_attr_value$address() {
        return git_attr_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_attr_value_t git_attr_value(const char *attr)
     * }
     */
    public static int git_attr_value(MemorySegment attr) {
        var mh$ = git_attr_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_attr_value", attr);
            }
            return (int)mh$.invokeExact(attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_attr_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_attr_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_attr_get(const char **value_out, git_repository *repo, uint32_t flags, const char *path, const char *name)
     * }
     */
    public static FunctionDescriptor git_attr_get$descriptor() {
        return git_attr_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_attr_get(const char **value_out, git_repository *repo, uint32_t flags, const char *path, const char *name)
     * }
     */
    public static MethodHandle git_attr_get$handle() {
        return git_attr_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_attr_get(const char **value_out, git_repository *repo, uint32_t flags, const char *path, const char *name)
     * }
     */
    public static MemorySegment git_attr_get$address() {
        return git_attr_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_attr_get(const char **value_out, git_repository *repo, uint32_t flags, const char *path, const char *name)
     * }
     */
    public static int git_attr_get(MemorySegment value_out, MemorySegment repo, int flags, MemorySegment path, MemorySegment name) {
        var mh$ = git_attr_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_attr_get", value_out, repo, flags, path, name);
            }
            return (int)mh$.invokeExact(value_out, repo, flags, path, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_attr_get_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_attr_get_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_attr_get_ext(const char **value_out, git_repository *repo, git_attr_options *opts, const char *path, const char *name)
     * }
     */
    public static FunctionDescriptor git_attr_get_ext$descriptor() {
        return git_attr_get_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_attr_get_ext(const char **value_out, git_repository *repo, git_attr_options *opts, const char *path, const char *name)
     * }
     */
    public static MethodHandle git_attr_get_ext$handle() {
        return git_attr_get_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_attr_get_ext(const char **value_out, git_repository *repo, git_attr_options *opts, const char *path, const char *name)
     * }
     */
    public static MemorySegment git_attr_get_ext$address() {
        return git_attr_get_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_attr_get_ext(const char **value_out, git_repository *repo, git_attr_options *opts, const char *path, const char *name)
     * }
     */
    public static int git_attr_get_ext(MemorySegment value_out, MemorySegment repo, MemorySegment opts, MemorySegment path, MemorySegment name) {
        var mh$ = git_attr_get_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_attr_get_ext", value_out, repo, opts, path, name);
            }
            return (int)mh$.invokeExact(value_out, repo, opts, path, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_attr_get_many {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_attr_get_many");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_attr_get_many(const char **values_out, git_repository *repo, uint32_t flags, const char *path, size_t num_attr, const char **names)
     * }
     */
    public static FunctionDescriptor git_attr_get_many$descriptor() {
        return git_attr_get_many.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_attr_get_many(const char **values_out, git_repository *repo, uint32_t flags, const char *path, size_t num_attr, const char **names)
     * }
     */
    public static MethodHandle git_attr_get_many$handle() {
        return git_attr_get_many.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_attr_get_many(const char **values_out, git_repository *repo, uint32_t flags, const char *path, size_t num_attr, const char **names)
     * }
     */
    public static MemorySegment git_attr_get_many$address() {
        return git_attr_get_many.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_attr_get_many(const char **values_out, git_repository *repo, uint32_t flags, const char *path, size_t num_attr, const char **names)
     * }
     */
    public static int git_attr_get_many(MemorySegment values_out, MemorySegment repo, int flags, MemorySegment path, long num_attr, MemorySegment names) {
        var mh$ = git_attr_get_many.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_attr_get_many", values_out, repo, flags, path, num_attr, names);
            }
            return (int)mh$.invokeExact(values_out, repo, flags, path, num_attr, names);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_attr_get_many_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_attr_get_many_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_attr_get_many_ext(const char **values_out, git_repository *repo, git_attr_options *opts, const char *path, size_t num_attr, const char **names)
     * }
     */
    public static FunctionDescriptor git_attr_get_many_ext$descriptor() {
        return git_attr_get_many_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_attr_get_many_ext(const char **values_out, git_repository *repo, git_attr_options *opts, const char *path, size_t num_attr, const char **names)
     * }
     */
    public static MethodHandle git_attr_get_many_ext$handle() {
        return git_attr_get_many_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_attr_get_many_ext(const char **values_out, git_repository *repo, git_attr_options *opts, const char *path, size_t num_attr, const char **names)
     * }
     */
    public static MemorySegment git_attr_get_many_ext$address() {
        return git_attr_get_many_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_attr_get_many_ext(const char **values_out, git_repository *repo, git_attr_options *opts, const char *path, size_t num_attr, const char **names)
     * }
     */
    public static int git_attr_get_many_ext(MemorySegment values_out, MemorySegment repo, MemorySegment opts, MemorySegment path, long num_attr, MemorySegment names) {
        var mh$ = git_attr_get_many_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_attr_get_many_ext", values_out, repo, opts, path, num_attr, names);
            }
            return (int)mh$.invokeExact(values_out, repo, opts, path, num_attr, names);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_attr_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_attr_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_attr_foreach(git_repository *repo, uint32_t flags, const char *path, git_attr_foreach_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_attr_foreach$descriptor() {
        return git_attr_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_attr_foreach(git_repository *repo, uint32_t flags, const char *path, git_attr_foreach_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_attr_foreach$handle() {
        return git_attr_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_attr_foreach(git_repository *repo, uint32_t flags, const char *path, git_attr_foreach_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_attr_foreach$address() {
        return git_attr_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_attr_foreach(git_repository *repo, uint32_t flags, const char *path, git_attr_foreach_cb callback, void *payload)
     * }
     */
    public static int git_attr_foreach(MemorySegment repo, int flags, MemorySegment path, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_attr_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_attr_foreach", repo, flags, path, callback, payload);
            }
            return (int)mh$.invokeExact(repo, flags, path, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_attr_foreach_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_attr_foreach_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_attr_foreach_ext(git_repository *repo, git_attr_options *opts, const char *path, git_attr_foreach_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_attr_foreach_ext$descriptor() {
        return git_attr_foreach_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_attr_foreach_ext(git_repository *repo, git_attr_options *opts, const char *path, git_attr_foreach_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_attr_foreach_ext$handle() {
        return git_attr_foreach_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_attr_foreach_ext(git_repository *repo, git_attr_options *opts, const char *path, git_attr_foreach_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_attr_foreach_ext$address() {
        return git_attr_foreach_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_attr_foreach_ext(git_repository *repo, git_attr_options *opts, const char *path, git_attr_foreach_cb callback, void *payload)
     * }
     */
    public static int git_attr_foreach_ext(MemorySegment repo, MemorySegment opts, MemorySegment path, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_attr_foreach_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_attr_foreach_ext", repo, opts, path, callback, payload);
            }
            return (int)mh$.invokeExact(repo, opts, path, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

