// Generated by jextract

package com.sernamar.jgit2.bindings;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class git2_1 extends git2_2 {

    git2_1() {
        // Should not be called directly
    }

    private static class git_attr_cache_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_attr_cache_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_attr_cache_flush(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_attr_cache_flush$descriptor() {
        return git_attr_cache_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_attr_cache_flush(git_repository *repo)
     * }
     */
    public static MethodHandle git_attr_cache_flush$handle() {
        return git_attr_cache_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_attr_cache_flush(git_repository *repo)
     * }
     */
    public static MemorySegment git_attr_cache_flush$address() {
        return git_attr_cache_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_attr_cache_flush(git_repository *repo)
     * }
     */
    public static int git_attr_cache_flush(MemorySegment repo) {
        var mh$ = git_attr_cache_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_attr_cache_flush", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_attr_add_macro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_attr_add_macro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_attr_add_macro(git_repository *repo, const char *name, const char *values)
     * }
     */
    public static FunctionDescriptor git_attr_add_macro$descriptor() {
        return git_attr_add_macro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_attr_add_macro(git_repository *repo, const char *name, const char *values)
     * }
     */
    public static MethodHandle git_attr_add_macro$handle() {
        return git_attr_add_macro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_attr_add_macro(git_repository *repo, const char *name, const char *values)
     * }
     */
    public static MemorySegment git_attr_add_macro$address() {
        return git_attr_add_macro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_attr_add_macro(git_repository *repo, const char *name, const char *values)
     * }
     */
    public static int git_attr_add_macro(MemorySegment repo, MemorySegment name, MemorySegment values) {
        var mh$ = git_attr_add_macro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_attr_add_macro", repo, name, values);
            }
            return (int)mh$.invokeExact(repo, name, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_lookup(git_blob **blob, git_repository *repo, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_blob_lookup$descriptor() {
        return git_blob_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_lookup(git_blob **blob, git_repository *repo, const git_oid *id)
     * }
     */
    public static MethodHandle git_blob_lookup$handle() {
        return git_blob_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_lookup(git_blob **blob, git_repository *repo, const git_oid *id)
     * }
     */
    public static MemorySegment git_blob_lookup$address() {
        return git_blob_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_lookup(git_blob **blob, git_repository *repo, const git_oid *id)
     * }
     */
    public static int git_blob_lookup(MemorySegment blob, MemorySegment repo, MemorySegment id) {
        var mh$ = git_blob_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_lookup", blob, repo, id);
            }
            return (int)mh$.invokeExact(blob, repo, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_lookup_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_lookup_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_lookup_prefix(git_blob **blob, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static FunctionDescriptor git_blob_lookup_prefix$descriptor() {
        return git_blob_lookup_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_lookup_prefix(git_blob **blob, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static MethodHandle git_blob_lookup_prefix$handle() {
        return git_blob_lookup_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_lookup_prefix(git_blob **blob, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static MemorySegment git_blob_lookup_prefix$address() {
        return git_blob_lookup_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_lookup_prefix(git_blob **blob, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static int git_blob_lookup_prefix(MemorySegment blob, MemorySegment repo, MemorySegment id, long len) {
        var mh$ = git_blob_lookup_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_lookup_prefix", blob, repo, id, len);
            }
            return (int)mh$.invokeExact(blob, repo, id, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_blob_free(git_blob *blob)
     * }
     */
    public static FunctionDescriptor git_blob_free$descriptor() {
        return git_blob_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_blob_free(git_blob *blob)
     * }
     */
    public static MethodHandle git_blob_free$handle() {
        return git_blob_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_blob_free(git_blob *blob)
     * }
     */
    public static MemorySegment git_blob_free$address() {
        return git_blob_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_blob_free(git_blob *blob)
     * }
     */
    public static void git_blob_free(MemorySegment blob) {
        var mh$ = git_blob_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_free", blob);
            }
            mh$.invokeExact(blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_blob_id(const git_blob *blob)
     * }
     */
    public static FunctionDescriptor git_blob_id$descriptor() {
        return git_blob_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_blob_id(const git_blob *blob)
     * }
     */
    public static MethodHandle git_blob_id$handle() {
        return git_blob_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_blob_id(const git_blob *blob)
     * }
     */
    public static MemorySegment git_blob_id$address() {
        return git_blob_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_blob_id(const git_blob *blob)
     * }
     */
    public static MemorySegment git_blob_id(MemorySegment blob) {
        var mh$ = git_blob_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_id", blob);
            }
            return (MemorySegment)mh$.invokeExact(blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_blob_owner(const git_blob *blob)
     * }
     */
    public static FunctionDescriptor git_blob_owner$descriptor() {
        return git_blob_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_blob_owner(const git_blob *blob)
     * }
     */
    public static MethodHandle git_blob_owner$handle() {
        return git_blob_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_blob_owner(const git_blob *blob)
     * }
     */
    public static MemorySegment git_blob_owner$address() {
        return git_blob_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_blob_owner(const git_blob *blob)
     * }
     */
    public static MemorySegment git_blob_owner(MemorySegment blob) {
        var mh$ = git_blob_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_owner", blob);
            }
            return (MemorySegment)mh$.invokeExact(blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_rawcontent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_rawcontent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const void *git_blob_rawcontent(const git_blob *blob)
     * }
     */
    public static FunctionDescriptor git_blob_rawcontent$descriptor() {
        return git_blob_rawcontent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const void *git_blob_rawcontent(const git_blob *blob)
     * }
     */
    public static MethodHandle git_blob_rawcontent$handle() {
        return git_blob_rawcontent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const void *git_blob_rawcontent(const git_blob *blob)
     * }
     */
    public static MemorySegment git_blob_rawcontent$address() {
        return git_blob_rawcontent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const void *git_blob_rawcontent(const git_blob *blob)
     * }
     */
    public static MemorySegment git_blob_rawcontent(MemorySegment blob) {
        var mh$ = git_blob_rawcontent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_rawcontent", blob);
            }
            return (MemorySegment)mh$.invokeExact(blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_rawsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_rawsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_object_size_t git_blob_rawsize(const git_blob *blob)
     * }
     */
    public static FunctionDescriptor git_blob_rawsize$descriptor() {
        return git_blob_rawsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_object_size_t git_blob_rawsize(const git_blob *blob)
     * }
     */
    public static MethodHandle git_blob_rawsize$handle() {
        return git_blob_rawsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_object_size_t git_blob_rawsize(const git_blob *blob)
     * }
     */
    public static MemorySegment git_blob_rawsize$address() {
        return git_blob_rawsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_object_size_t git_blob_rawsize(const git_blob *blob)
     * }
     */
    public static long git_blob_rawsize(MemorySegment blob) {
        var mh$ = git_blob_rawsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_rawsize", blob);
            }
            return (long)mh$.invokeExact(blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_BLOB_FILTER_CHECK_FOR_BINARY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLOB_FILTER_CHECK_FOR_BINARY = 1
     * }
     */
    public static int GIT_BLOB_FILTER_CHECK_FOR_BINARY() {
        return GIT_BLOB_FILTER_CHECK_FOR_BINARY;
    }
    private static final int GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES = 2
     * }
     */
    public static int GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES() {
        return GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES;
    }
    private static final int GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD = 4
     * }
     */
    public static int GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD() {
        return GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD;
    }
    private static final int GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT = 8
     * }
     */
    public static int GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT() {
        return GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT;
    }

    private static class git_blob_filter_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_filter_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_filter_options_init(git_blob_filter_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_blob_filter_options_init$descriptor() {
        return git_blob_filter_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_filter_options_init(git_blob_filter_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_blob_filter_options_init$handle() {
        return git_blob_filter_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_filter_options_init(git_blob_filter_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_blob_filter_options_init$address() {
        return git_blob_filter_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_filter_options_init(git_blob_filter_options *opts, unsigned int version)
     * }
     */
    public static int git_blob_filter_options_init(MemorySegment opts, int version) {
        var mh$ = git_blob_filter_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_filter_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_filter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_filter(git_buf *out, git_blob *blob, const char *as_path, git_blob_filter_options *opts)
     * }
     */
    public static FunctionDescriptor git_blob_filter$descriptor() {
        return git_blob_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_filter(git_buf *out, git_blob *blob, const char *as_path, git_blob_filter_options *opts)
     * }
     */
    public static MethodHandle git_blob_filter$handle() {
        return git_blob_filter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_filter(git_buf *out, git_blob *blob, const char *as_path, git_blob_filter_options *opts)
     * }
     */
    public static MemorySegment git_blob_filter$address() {
        return git_blob_filter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_filter(git_buf *out, git_blob *blob, const char *as_path, git_blob_filter_options *opts)
     * }
     */
    public static int git_blob_filter(MemorySegment out, MemorySegment blob, MemorySegment as_path, MemorySegment opts) {
        var mh$ = git_blob_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_filter", out, blob, as_path, opts);
            }
            return (int)mh$.invokeExact(out, blob, as_path, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_create_from_workdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_create_from_workdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_workdir(git_oid *id, git_repository *repo, const char *relative_path)
     * }
     */
    public static FunctionDescriptor git_blob_create_from_workdir$descriptor() {
        return git_blob_create_from_workdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_workdir(git_oid *id, git_repository *repo, const char *relative_path)
     * }
     */
    public static MethodHandle git_blob_create_from_workdir$handle() {
        return git_blob_create_from_workdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_workdir(git_oid *id, git_repository *repo, const char *relative_path)
     * }
     */
    public static MemorySegment git_blob_create_from_workdir$address() {
        return git_blob_create_from_workdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_create_from_workdir(git_oid *id, git_repository *repo, const char *relative_path)
     * }
     */
    public static int git_blob_create_from_workdir(MemorySegment id, MemorySegment repo, MemorySegment relative_path) {
        var mh$ = git_blob_create_from_workdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_create_from_workdir", id, repo, relative_path);
            }
            return (int)mh$.invokeExact(id, repo, relative_path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_create_from_disk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_create_from_disk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_disk(git_oid *id, git_repository *repo, const char *path)
     * }
     */
    public static FunctionDescriptor git_blob_create_from_disk$descriptor() {
        return git_blob_create_from_disk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_disk(git_oid *id, git_repository *repo, const char *path)
     * }
     */
    public static MethodHandle git_blob_create_from_disk$handle() {
        return git_blob_create_from_disk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_disk(git_oid *id, git_repository *repo, const char *path)
     * }
     */
    public static MemorySegment git_blob_create_from_disk$address() {
        return git_blob_create_from_disk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_create_from_disk(git_oid *id, git_repository *repo, const char *path)
     * }
     */
    public static int git_blob_create_from_disk(MemorySegment id, MemorySegment repo, MemorySegment path) {
        var mh$ = git_blob_create_from_disk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_create_from_disk", id, repo, path);
            }
            return (int)mh$.invokeExact(id, repo, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_create_from_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_create_from_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_stream(git_writestream **out, git_repository *repo, const char *hintpath)
     * }
     */
    public static FunctionDescriptor git_blob_create_from_stream$descriptor() {
        return git_blob_create_from_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_stream(git_writestream **out, git_repository *repo, const char *hintpath)
     * }
     */
    public static MethodHandle git_blob_create_from_stream$handle() {
        return git_blob_create_from_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_stream(git_writestream **out, git_repository *repo, const char *hintpath)
     * }
     */
    public static MemorySegment git_blob_create_from_stream$address() {
        return git_blob_create_from_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_create_from_stream(git_writestream **out, git_repository *repo, const char *hintpath)
     * }
     */
    public static int git_blob_create_from_stream(MemorySegment out, MemorySegment repo, MemorySegment hintpath) {
        var mh$ = git_blob_create_from_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_create_from_stream", out, repo, hintpath);
            }
            return (int)mh$.invokeExact(out, repo, hintpath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_create_from_stream_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_create_from_stream_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_stream_commit(git_oid *out, git_writestream *stream)
     * }
     */
    public static FunctionDescriptor git_blob_create_from_stream_commit$descriptor() {
        return git_blob_create_from_stream_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_stream_commit(git_oid *out, git_writestream *stream)
     * }
     */
    public static MethodHandle git_blob_create_from_stream_commit$handle() {
        return git_blob_create_from_stream_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_stream_commit(git_oid *out, git_writestream *stream)
     * }
     */
    public static MemorySegment git_blob_create_from_stream_commit$address() {
        return git_blob_create_from_stream_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_create_from_stream_commit(git_oid *out, git_writestream *stream)
     * }
     */
    public static int git_blob_create_from_stream_commit(MemorySegment out, MemorySegment stream) {
        var mh$ = git_blob_create_from_stream_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_create_from_stream_commit", out, stream);
            }
            return (int)mh$.invokeExact(out, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_create_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_create_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_buffer(git_oid *id, git_repository *repo, const void *buffer, size_t len)
     * }
     */
    public static FunctionDescriptor git_blob_create_from_buffer$descriptor() {
        return git_blob_create_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_buffer(git_oid *id, git_repository *repo, const void *buffer, size_t len)
     * }
     */
    public static MethodHandle git_blob_create_from_buffer$handle() {
        return git_blob_create_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_create_from_buffer(git_oid *id, git_repository *repo, const void *buffer, size_t len)
     * }
     */
    public static MemorySegment git_blob_create_from_buffer$address() {
        return git_blob_create_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_create_from_buffer(git_oid *id, git_repository *repo, const void *buffer, size_t len)
     * }
     */
    public static int git_blob_create_from_buffer(MemorySegment id, MemorySegment repo, MemorySegment buffer, long len) {
        var mh$ = git_blob_create_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_create_from_buffer", id, repo, buffer, len);
            }
            return (int)mh$.invokeExact(id, repo, buffer, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_is_binary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_is_binary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_is_binary(const git_blob *blob)
     * }
     */
    public static FunctionDescriptor git_blob_is_binary$descriptor() {
        return git_blob_is_binary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_is_binary(const git_blob *blob)
     * }
     */
    public static MethodHandle git_blob_is_binary$handle() {
        return git_blob_is_binary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_is_binary(const git_blob *blob)
     * }
     */
    public static MemorySegment git_blob_is_binary$address() {
        return git_blob_is_binary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_is_binary(const git_blob *blob)
     * }
     */
    public static int git_blob_is_binary(MemorySegment blob) {
        var mh$ = git_blob_is_binary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_is_binary", blob);
            }
            return (int)mh$.invokeExact(blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_data_is_binary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_data_is_binary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_data_is_binary(const char *data, size_t len)
     * }
     */
    public static FunctionDescriptor git_blob_data_is_binary$descriptor() {
        return git_blob_data_is_binary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_data_is_binary(const char *data, size_t len)
     * }
     */
    public static MethodHandle git_blob_data_is_binary$handle() {
        return git_blob_data_is_binary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_data_is_binary(const char *data, size_t len)
     * }
     */
    public static MemorySegment git_blob_data_is_binary$address() {
        return git_blob_data_is_binary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_data_is_binary(const char *data, size_t len)
     * }
     */
    public static int git_blob_data_is_binary(MemorySegment data, long len) {
        var mh$ = git_blob_data_is_binary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_data_is_binary", data, len);
            }
            return (int)mh$.invokeExact(data, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_dup(git_blob **out, git_blob *source)
     * }
     */
    public static FunctionDescriptor git_blob_dup$descriptor() {
        return git_blob_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_dup(git_blob **out, git_blob *source)
     * }
     */
    public static MethodHandle git_blob_dup$handle() {
        return git_blob_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_dup(git_blob **out, git_blob *source)
     * }
     */
    public static MemorySegment git_blob_dup$address() {
        return git_blob_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_dup(git_blob **out, git_blob *source)
     * }
     */
    public static int git_blob_dup(MemorySegment out, MemorySegment source) {
        var mh$ = git_blob_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_dup", out, source);
            }
            return (int)mh$.invokeExact(out, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_BLAME_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLAME_NORMAL = 0
     * }
     */
    public static int GIT_BLAME_NORMAL() {
        return GIT_BLAME_NORMAL;
    }
    private static final int GIT_BLAME_TRACK_COPIES_SAME_FILE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLAME_TRACK_COPIES_SAME_FILE = 1
     * }
     */
    public static int GIT_BLAME_TRACK_COPIES_SAME_FILE() {
        return GIT_BLAME_TRACK_COPIES_SAME_FILE;
    }
    private static final int GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES = 2
     * }
     */
    public static int GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES() {
        return GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES;
    }
    private static final int GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES = 4
     * }
     */
    public static int GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES() {
        return GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES;
    }
    private static final int GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES = 8
     * }
     */
    public static int GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES() {
        return GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES;
    }
    private static final int GIT_BLAME_FIRST_PARENT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLAME_FIRST_PARENT = 16
     * }
     */
    public static int GIT_BLAME_FIRST_PARENT() {
        return GIT_BLAME_FIRST_PARENT;
    }
    private static final int GIT_BLAME_USE_MAILMAP = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLAME_USE_MAILMAP = 32
     * }
     */
    public static int GIT_BLAME_USE_MAILMAP() {
        return GIT_BLAME_USE_MAILMAP;
    }
    private static final int GIT_BLAME_IGNORE_WHITESPACE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_BLAME_IGNORE_WHITESPACE = 64
     * }
     */
    public static int GIT_BLAME_IGNORE_WHITESPACE() {
        return GIT_BLAME_IGNORE_WHITESPACE;
    }

    private static class git_blame_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blame_options_init(git_blame_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_blame_options_init$descriptor() {
        return git_blame_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blame_options_init(git_blame_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_blame_options_init$handle() {
        return git_blame_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blame_options_init(git_blame_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_blame_options_init$address() {
        return git_blame_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blame_options_init(git_blame_options *opts, unsigned int version)
     * }
     */
    public static int git_blame_options_init(MemorySegment opts, int version) {
        var mh$ = git_blame_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_linecount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_linecount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_blame_linecount(git_blame *blame)
     * }
     */
    public static FunctionDescriptor git_blame_linecount$descriptor() {
        return git_blame_linecount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_blame_linecount(git_blame *blame)
     * }
     */
    public static MethodHandle git_blame_linecount$handle() {
        return git_blame_linecount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_blame_linecount(git_blame *blame)
     * }
     */
    public static MemorySegment git_blame_linecount$address() {
        return git_blame_linecount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_blame_linecount(git_blame *blame)
     * }
     */
    public static long git_blame_linecount(MemorySegment blame) {
        var mh$ = git_blame_linecount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_linecount", blame);
            }
            return (long)mh$.invokeExact(blame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_hunkcount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_hunkcount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_blame_hunkcount(git_blame *blame)
     * }
     */
    public static FunctionDescriptor git_blame_hunkcount$descriptor() {
        return git_blame_hunkcount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_blame_hunkcount(git_blame *blame)
     * }
     */
    public static MethodHandle git_blame_hunkcount$handle() {
        return git_blame_hunkcount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_blame_hunkcount(git_blame *blame)
     * }
     */
    public static MemorySegment git_blame_hunkcount$address() {
        return git_blame_hunkcount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_blame_hunkcount(git_blame *blame)
     * }
     */
    public static long git_blame_hunkcount(MemorySegment blame) {
        var mh$ = git_blame_hunkcount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_hunkcount", blame);
            }
            return (long)mh$.invokeExact(blame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_hunk_byindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_hunk_byindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_hunk_byindex(git_blame *blame, size_t index)
     * }
     */
    public static FunctionDescriptor git_blame_hunk_byindex$descriptor() {
        return git_blame_hunk_byindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_hunk_byindex(git_blame *blame, size_t index)
     * }
     */
    public static MethodHandle git_blame_hunk_byindex$handle() {
        return git_blame_hunk_byindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_hunk_byindex(git_blame *blame, size_t index)
     * }
     */
    public static MemorySegment git_blame_hunk_byindex$address() {
        return git_blame_hunk_byindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_hunk_byindex(git_blame *blame, size_t index)
     * }
     */
    public static MemorySegment git_blame_hunk_byindex(MemorySegment blame, long index) {
        var mh$ = git_blame_hunk_byindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_hunk_byindex", blame, index);
            }
            return (MemorySegment)mh$.invokeExact(blame, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_hunk_byline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_hunk_byline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_hunk_byline(git_blame *blame, size_t lineno)
     * }
     */
    public static FunctionDescriptor git_blame_hunk_byline$descriptor() {
        return git_blame_hunk_byline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_hunk_byline(git_blame *blame, size_t lineno)
     * }
     */
    public static MethodHandle git_blame_hunk_byline$handle() {
        return git_blame_hunk_byline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_hunk_byline(git_blame *blame, size_t lineno)
     * }
     */
    public static MemorySegment git_blame_hunk_byline$address() {
        return git_blame_hunk_byline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_hunk_byline(git_blame *blame, size_t lineno)
     * }
     */
    public static MemorySegment git_blame_hunk_byline(MemorySegment blame, long lineno) {
        var mh$ = git_blame_hunk_byline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_hunk_byline", blame, lineno);
            }
            return (MemorySegment)mh$.invokeExact(blame, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_line_byindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_line_byindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_blame_line *git_blame_line_byindex(git_blame *blame, size_t idx)
     * }
     */
    public static FunctionDescriptor git_blame_line_byindex$descriptor() {
        return git_blame_line_byindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_blame_line *git_blame_line_byindex(git_blame *blame, size_t idx)
     * }
     */
    public static MethodHandle git_blame_line_byindex$handle() {
        return git_blame_line_byindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_blame_line *git_blame_line_byindex(git_blame *blame, size_t idx)
     * }
     */
    public static MemorySegment git_blame_line_byindex$address() {
        return git_blame_line_byindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_blame_line *git_blame_line_byindex(git_blame *blame, size_t idx)
     * }
     */
    public static MemorySegment git_blame_line_byindex(MemorySegment blame, long idx) {
        var mh$ = git_blame_line_byindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_line_byindex", blame, idx);
            }
            return (MemorySegment)mh$.invokeExact(blame, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_get_hunk_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_get_hunk_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint32_t git_blame_get_hunk_count(git_blame *blame)
     * }
     */
    public static FunctionDescriptor git_blame_get_hunk_count$descriptor() {
        return git_blame_get_hunk_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint32_t git_blame_get_hunk_count(git_blame *blame)
     * }
     */
    public static MethodHandle git_blame_get_hunk_count$handle() {
        return git_blame_get_hunk_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint32_t git_blame_get_hunk_count(git_blame *blame)
     * }
     */
    public static MemorySegment git_blame_get_hunk_count$address() {
        return git_blame_get_hunk_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint32_t git_blame_get_hunk_count(git_blame *blame)
     * }
     */
    public static int git_blame_get_hunk_count(MemorySegment blame) {
        var mh$ = git_blame_get_hunk_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_get_hunk_count", blame);
            }
            return (int)mh$.invokeExact(blame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_get_hunk_byindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_get_hunk_byindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_get_hunk_byindex(git_blame *blame, uint32_t index)
     * }
     */
    public static FunctionDescriptor git_blame_get_hunk_byindex$descriptor() {
        return git_blame_get_hunk_byindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_get_hunk_byindex(git_blame *blame, uint32_t index)
     * }
     */
    public static MethodHandle git_blame_get_hunk_byindex$handle() {
        return git_blame_get_hunk_byindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_get_hunk_byindex(git_blame *blame, uint32_t index)
     * }
     */
    public static MemorySegment git_blame_get_hunk_byindex$address() {
        return git_blame_get_hunk_byindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_get_hunk_byindex(git_blame *blame, uint32_t index)
     * }
     */
    public static MemorySegment git_blame_get_hunk_byindex(MemorySegment blame, int index) {
        var mh$ = git_blame_get_hunk_byindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_get_hunk_byindex", blame, index);
            }
            return (MemorySegment)mh$.invokeExact(blame, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_get_hunk_byline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_get_hunk_byline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_get_hunk_byline(git_blame *blame, size_t lineno)
     * }
     */
    public static FunctionDescriptor git_blame_get_hunk_byline$descriptor() {
        return git_blame_get_hunk_byline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_get_hunk_byline(git_blame *blame, size_t lineno)
     * }
     */
    public static MethodHandle git_blame_get_hunk_byline$handle() {
        return git_blame_get_hunk_byline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_get_hunk_byline(git_blame *blame, size_t lineno)
     * }
     */
    public static MemorySegment git_blame_get_hunk_byline$address() {
        return git_blame_get_hunk_byline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_blame_hunk *git_blame_get_hunk_byline(git_blame *blame, size_t lineno)
     * }
     */
    public static MemorySegment git_blame_get_hunk_byline(MemorySegment blame, long lineno) {
        var mh$ = git_blame_get_hunk_byline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_get_hunk_byline", blame, lineno);
            }
            return (MemorySegment)mh$.invokeExact(blame, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blame_file(git_blame **out, git_repository *repo, const char *path, git_blame_options *options)
     * }
     */
    public static FunctionDescriptor git_blame_file$descriptor() {
        return git_blame_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blame_file(git_blame **out, git_repository *repo, const char *path, git_blame_options *options)
     * }
     */
    public static MethodHandle git_blame_file$handle() {
        return git_blame_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blame_file(git_blame **out, git_repository *repo, const char *path, git_blame_options *options)
     * }
     */
    public static MemorySegment git_blame_file$address() {
        return git_blame_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blame_file(git_blame **out, git_repository *repo, const char *path, git_blame_options *options)
     * }
     */
    public static int git_blame_file(MemorySegment out, MemorySegment repo, MemorySegment path, MemorySegment options) {
        var mh$ = git_blame_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_file", out, repo, path, options);
            }
            return (int)mh$.invokeExact(out, repo, path, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_file_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_file_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blame_file_from_buffer(git_blame **out, git_repository *repo, const char *path, const char *contents, size_t contents_len, git_blame_options *options)
     * }
     */
    public static FunctionDescriptor git_blame_file_from_buffer$descriptor() {
        return git_blame_file_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blame_file_from_buffer(git_blame **out, git_repository *repo, const char *path, const char *contents, size_t contents_len, git_blame_options *options)
     * }
     */
    public static MethodHandle git_blame_file_from_buffer$handle() {
        return git_blame_file_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blame_file_from_buffer(git_blame **out, git_repository *repo, const char *path, const char *contents, size_t contents_len, git_blame_options *options)
     * }
     */
    public static MemorySegment git_blame_file_from_buffer$address() {
        return git_blame_file_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blame_file_from_buffer(git_blame **out, git_repository *repo, const char *path, const char *contents, size_t contents_len, git_blame_options *options)
     * }
     */
    public static int git_blame_file_from_buffer(MemorySegment out, MemorySegment repo, MemorySegment path, MemorySegment contents, long contents_len, MemorySegment options) {
        var mh$ = git_blame_file_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_file_from_buffer", out, repo, path, contents, contents_len, options);
            }
            return (int)mh$.invokeExact(out, repo, path, contents, contents_len, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blame_buffer(git_blame **out, git_blame *base, const char *buffer, size_t buffer_len)
     * }
     */
    public static FunctionDescriptor git_blame_buffer$descriptor() {
        return git_blame_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blame_buffer(git_blame **out, git_blame *base, const char *buffer, size_t buffer_len)
     * }
     */
    public static MethodHandle git_blame_buffer$handle() {
        return git_blame_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blame_buffer(git_blame **out, git_blame *base, const char *buffer, size_t buffer_len)
     * }
     */
    public static MemorySegment git_blame_buffer$address() {
        return git_blame_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blame_buffer(git_blame **out, git_blame *base, const char *buffer, size_t buffer_len)
     * }
     */
    public static int git_blame_buffer(MemorySegment out, MemorySegment base, MemorySegment buffer, long buffer_len) {
        var mh$ = git_blame_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_buffer", out, base, buffer, buffer_len);
            }
            return (int)mh$.invokeExact(out, base, buffer, buffer_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_blame_free(git_blame *blame)
     * }
     */
    public static FunctionDescriptor git_blame_free$descriptor() {
        return git_blame_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_blame_free(git_blame *blame)
     * }
     */
    public static MethodHandle git_blame_free$handle() {
        return git_blame_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_blame_free(git_blame *blame)
     * }
     */
    public static MemorySegment git_blame_free$address() {
        return git_blame_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_blame_free(git_blame *blame)
     * }
     */
    public static void git_blame_free(MemorySegment blame) {
        var mh$ = git_blame_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_free", blame);
            }
            mh$.invokeExact(blame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_create(git_reference **out, git_repository *repo, const char *branch_name, const git_commit *target, int force)
     * }
     */
    public static FunctionDescriptor git_branch_create$descriptor() {
        return git_branch_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_create(git_reference **out, git_repository *repo, const char *branch_name, const git_commit *target, int force)
     * }
     */
    public static MethodHandle git_branch_create$handle() {
        return git_branch_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_create(git_reference **out, git_repository *repo, const char *branch_name, const git_commit *target, int force)
     * }
     */
    public static MemorySegment git_branch_create$address() {
        return git_branch_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_create(git_reference **out, git_repository *repo, const char *branch_name, const git_commit *target, int force)
     * }
     */
    public static int git_branch_create(MemorySegment out, MemorySegment repo, MemorySegment branch_name, MemorySegment target, int force) {
        var mh$ = git_branch_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_create", out, repo, branch_name, target, force);
            }
            return (int)mh$.invokeExact(out, repo, branch_name, target, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_create_from_annotated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_create_from_annotated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_create_from_annotated(git_reference **ref_out, git_repository *repo, const char *branch_name, const git_annotated_commit *target, int force)
     * }
     */
    public static FunctionDescriptor git_branch_create_from_annotated$descriptor() {
        return git_branch_create_from_annotated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_create_from_annotated(git_reference **ref_out, git_repository *repo, const char *branch_name, const git_annotated_commit *target, int force)
     * }
     */
    public static MethodHandle git_branch_create_from_annotated$handle() {
        return git_branch_create_from_annotated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_create_from_annotated(git_reference **ref_out, git_repository *repo, const char *branch_name, const git_annotated_commit *target, int force)
     * }
     */
    public static MemorySegment git_branch_create_from_annotated$address() {
        return git_branch_create_from_annotated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_create_from_annotated(git_reference **ref_out, git_repository *repo, const char *branch_name, const git_annotated_commit *target, int force)
     * }
     */
    public static int git_branch_create_from_annotated(MemorySegment ref_out, MemorySegment repo, MemorySegment branch_name, MemorySegment target, int force) {
        var mh$ = git_branch_create_from_annotated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_create_from_annotated", ref_out, repo, branch_name, target, force);
            }
            return (int)mh$.invokeExact(ref_out, repo, branch_name, target, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_delete(git_reference *branch)
     * }
     */
    public static FunctionDescriptor git_branch_delete$descriptor() {
        return git_branch_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_delete(git_reference *branch)
     * }
     */
    public static MethodHandle git_branch_delete$handle() {
        return git_branch_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_delete(git_reference *branch)
     * }
     */
    public static MemorySegment git_branch_delete$address() {
        return git_branch_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_delete(git_reference *branch)
     * }
     */
    public static int git_branch_delete(MemorySegment branch) {
        var mh$ = git_branch_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_delete", branch);
            }
            return (int)mh$.invokeExact(branch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_iterator_new(git_branch_iterator **out, git_repository *repo, git_branch_t list_flags)
     * }
     */
    public static FunctionDescriptor git_branch_iterator_new$descriptor() {
        return git_branch_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_iterator_new(git_branch_iterator **out, git_repository *repo, git_branch_t list_flags)
     * }
     */
    public static MethodHandle git_branch_iterator_new$handle() {
        return git_branch_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_iterator_new(git_branch_iterator **out, git_repository *repo, git_branch_t list_flags)
     * }
     */
    public static MemorySegment git_branch_iterator_new$address() {
        return git_branch_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_iterator_new(git_branch_iterator **out, git_repository *repo, git_branch_t list_flags)
     * }
     */
    public static int git_branch_iterator_new(MemorySegment out, MemorySegment repo, int list_flags) {
        var mh$ = git_branch_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_iterator_new", out, repo, list_flags);
            }
            return (int)mh$.invokeExact(out, repo, list_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_next(git_reference **out, git_branch_t *out_type, git_branch_iterator *iter)
     * }
     */
    public static FunctionDescriptor git_branch_next$descriptor() {
        return git_branch_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_next(git_reference **out, git_branch_t *out_type, git_branch_iterator *iter)
     * }
     */
    public static MethodHandle git_branch_next$handle() {
        return git_branch_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_next(git_reference **out, git_branch_t *out_type, git_branch_iterator *iter)
     * }
     */
    public static MemorySegment git_branch_next$address() {
        return git_branch_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_next(git_reference **out, git_branch_t *out_type, git_branch_iterator *iter)
     * }
     */
    public static int git_branch_next(MemorySegment out, MemorySegment out_type, MemorySegment iter) {
        var mh$ = git_branch_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_next", out, out_type, iter);
            }
            return (int)mh$.invokeExact(out, out_type, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_iterator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_iterator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_branch_iterator_free(git_branch_iterator *iter)
     * }
     */
    public static FunctionDescriptor git_branch_iterator_free$descriptor() {
        return git_branch_iterator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_branch_iterator_free(git_branch_iterator *iter)
     * }
     */
    public static MethodHandle git_branch_iterator_free$handle() {
        return git_branch_iterator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_branch_iterator_free(git_branch_iterator *iter)
     * }
     */
    public static MemorySegment git_branch_iterator_free$address() {
        return git_branch_iterator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_branch_iterator_free(git_branch_iterator *iter)
     * }
     */
    public static void git_branch_iterator_free(MemorySegment iter) {
        var mh$ = git_branch_iterator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_iterator_free", iter);
            }
            mh$.invokeExact(iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_move {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_move");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_move(git_reference **out, git_reference *branch, const char *new_branch_name, int force)
     * }
     */
    public static FunctionDescriptor git_branch_move$descriptor() {
        return git_branch_move.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_move(git_reference **out, git_reference *branch, const char *new_branch_name, int force)
     * }
     */
    public static MethodHandle git_branch_move$handle() {
        return git_branch_move.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_move(git_reference **out, git_reference *branch, const char *new_branch_name, int force)
     * }
     */
    public static MemorySegment git_branch_move$address() {
        return git_branch_move.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_move(git_reference **out, git_reference *branch, const char *new_branch_name, int force)
     * }
     */
    public static int git_branch_move(MemorySegment out, MemorySegment branch, MemorySegment new_branch_name, int force) {
        var mh$ = git_branch_move.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_move", out, branch, new_branch_name, force);
            }
            return (int)mh$.invokeExact(out, branch, new_branch_name, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_lookup(git_reference **out, git_repository *repo, const char *branch_name, git_branch_t branch_type)
     * }
     */
    public static FunctionDescriptor git_branch_lookup$descriptor() {
        return git_branch_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_lookup(git_reference **out, git_repository *repo, const char *branch_name, git_branch_t branch_type)
     * }
     */
    public static MethodHandle git_branch_lookup$handle() {
        return git_branch_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_lookup(git_reference **out, git_repository *repo, const char *branch_name, git_branch_t branch_type)
     * }
     */
    public static MemorySegment git_branch_lookup$address() {
        return git_branch_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_lookup(git_reference **out, git_repository *repo, const char *branch_name, git_branch_t branch_type)
     * }
     */
    public static int git_branch_lookup(MemorySegment out, MemorySegment repo, MemorySegment branch_name, int branch_type) {
        var mh$ = git_branch_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_lookup", out, repo, branch_name, branch_type);
            }
            return (int)mh$.invokeExact(out, repo, branch_name, branch_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_name(const char **out, const git_reference *ref)
     * }
     */
    public static FunctionDescriptor git_branch_name$descriptor() {
        return git_branch_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_name(const char **out, const git_reference *ref)
     * }
     */
    public static MethodHandle git_branch_name$handle() {
        return git_branch_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_name(const char **out, const git_reference *ref)
     * }
     */
    public static MemorySegment git_branch_name$address() {
        return git_branch_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_name(const char **out, const git_reference *ref)
     * }
     */
    public static int git_branch_name(MemorySegment out, MemorySegment ref) {
        var mh$ = git_branch_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_name", out, ref);
            }
            return (int)mh$.invokeExact(out, ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_upstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_upstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_upstream(git_reference **out, const git_reference *branch)
     * }
     */
    public static FunctionDescriptor git_branch_upstream$descriptor() {
        return git_branch_upstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_upstream(git_reference **out, const git_reference *branch)
     * }
     */
    public static MethodHandle git_branch_upstream$handle() {
        return git_branch_upstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_upstream(git_reference **out, const git_reference *branch)
     * }
     */
    public static MemorySegment git_branch_upstream$address() {
        return git_branch_upstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_upstream(git_reference **out, const git_reference *branch)
     * }
     */
    public static int git_branch_upstream(MemorySegment out, MemorySegment branch) {
        var mh$ = git_branch_upstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_upstream", out, branch);
            }
            return (int)mh$.invokeExact(out, branch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_set_upstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_set_upstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_set_upstream(git_reference *branch, const char *branch_name)
     * }
     */
    public static FunctionDescriptor git_branch_set_upstream$descriptor() {
        return git_branch_set_upstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_set_upstream(git_reference *branch, const char *branch_name)
     * }
     */
    public static MethodHandle git_branch_set_upstream$handle() {
        return git_branch_set_upstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_set_upstream(git_reference *branch, const char *branch_name)
     * }
     */
    public static MemorySegment git_branch_set_upstream$address() {
        return git_branch_set_upstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_set_upstream(git_reference *branch, const char *branch_name)
     * }
     */
    public static int git_branch_set_upstream(MemorySegment branch, MemorySegment branch_name) {
        var mh$ = git_branch_set_upstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_set_upstream", branch, branch_name);
            }
            return (int)mh$.invokeExact(branch, branch_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_upstream_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_upstream_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_upstream_name(git_buf *out, git_repository *repo, const char *refname)
     * }
     */
    public static FunctionDescriptor git_branch_upstream_name$descriptor() {
        return git_branch_upstream_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_upstream_name(git_buf *out, git_repository *repo, const char *refname)
     * }
     */
    public static MethodHandle git_branch_upstream_name$handle() {
        return git_branch_upstream_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_upstream_name(git_buf *out, git_repository *repo, const char *refname)
     * }
     */
    public static MemorySegment git_branch_upstream_name$address() {
        return git_branch_upstream_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_upstream_name(git_buf *out, git_repository *repo, const char *refname)
     * }
     */
    public static int git_branch_upstream_name(MemorySegment out, MemorySegment repo, MemorySegment refname) {
        var mh$ = git_branch_upstream_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_upstream_name", out, repo, refname);
            }
            return (int)mh$.invokeExact(out, repo, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_is_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_is_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_is_head(const git_reference *branch)
     * }
     */
    public static FunctionDescriptor git_branch_is_head$descriptor() {
        return git_branch_is_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_is_head(const git_reference *branch)
     * }
     */
    public static MethodHandle git_branch_is_head$handle() {
        return git_branch_is_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_is_head(const git_reference *branch)
     * }
     */
    public static MemorySegment git_branch_is_head$address() {
        return git_branch_is_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_is_head(const git_reference *branch)
     * }
     */
    public static int git_branch_is_head(MemorySegment branch) {
        var mh$ = git_branch_is_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_is_head", branch);
            }
            return (int)mh$.invokeExact(branch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_is_checked_out {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_is_checked_out");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_is_checked_out(const git_reference *branch)
     * }
     */
    public static FunctionDescriptor git_branch_is_checked_out$descriptor() {
        return git_branch_is_checked_out.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_is_checked_out(const git_reference *branch)
     * }
     */
    public static MethodHandle git_branch_is_checked_out$handle() {
        return git_branch_is_checked_out.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_is_checked_out(const git_reference *branch)
     * }
     */
    public static MemorySegment git_branch_is_checked_out$address() {
        return git_branch_is_checked_out.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_is_checked_out(const git_reference *branch)
     * }
     */
    public static int git_branch_is_checked_out(MemorySegment branch) {
        var mh$ = git_branch_is_checked_out.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_is_checked_out", branch);
            }
            return (int)mh$.invokeExact(branch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_remote_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_remote_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_remote_name(git_buf *out, git_repository *repo, const char *refname)
     * }
     */
    public static FunctionDescriptor git_branch_remote_name$descriptor() {
        return git_branch_remote_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_remote_name(git_buf *out, git_repository *repo, const char *refname)
     * }
     */
    public static MethodHandle git_branch_remote_name$handle() {
        return git_branch_remote_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_remote_name(git_buf *out, git_repository *repo, const char *refname)
     * }
     */
    public static MemorySegment git_branch_remote_name$address() {
        return git_branch_remote_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_remote_name(git_buf *out, git_repository *repo, const char *refname)
     * }
     */
    public static int git_branch_remote_name(MemorySegment out, MemorySegment repo, MemorySegment refname) {
        var mh$ = git_branch_remote_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_remote_name", out, repo, refname);
            }
            return (int)mh$.invokeExact(out, repo, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_upstream_remote {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_upstream_remote");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_upstream_remote(git_buf *buf, git_repository *repo, const char *refname)
     * }
     */
    public static FunctionDescriptor git_branch_upstream_remote$descriptor() {
        return git_branch_upstream_remote.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_upstream_remote(git_buf *buf, git_repository *repo, const char *refname)
     * }
     */
    public static MethodHandle git_branch_upstream_remote$handle() {
        return git_branch_upstream_remote.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_upstream_remote(git_buf *buf, git_repository *repo, const char *refname)
     * }
     */
    public static MemorySegment git_branch_upstream_remote$address() {
        return git_branch_upstream_remote.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_upstream_remote(git_buf *buf, git_repository *repo, const char *refname)
     * }
     */
    public static int git_branch_upstream_remote(MemorySegment buf, MemorySegment repo, MemorySegment refname) {
        var mh$ = git_branch_upstream_remote.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_upstream_remote", buf, repo, refname);
            }
            return (int)mh$.invokeExact(buf, repo, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_upstream_merge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_upstream_merge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_upstream_merge(git_buf *buf, git_repository *repo, const char *refname)
     * }
     */
    public static FunctionDescriptor git_branch_upstream_merge$descriptor() {
        return git_branch_upstream_merge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_upstream_merge(git_buf *buf, git_repository *repo, const char *refname)
     * }
     */
    public static MethodHandle git_branch_upstream_merge$handle() {
        return git_branch_upstream_merge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_upstream_merge(git_buf *buf, git_repository *repo, const char *refname)
     * }
     */
    public static MemorySegment git_branch_upstream_merge$address() {
        return git_branch_upstream_merge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_upstream_merge(git_buf *buf, git_repository *repo, const char *refname)
     * }
     */
    public static int git_branch_upstream_merge(MemorySegment buf, MemorySegment repo, MemorySegment refname) {
        var mh$ = git_branch_upstream_merge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_upstream_merge", buf, repo, refname);
            }
            return (int)mh$.invokeExact(buf, repo, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_branch_name_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_branch_name_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_branch_name_is_valid(int *valid, const char *name)
     * }
     */
    public static FunctionDescriptor git_branch_name_is_valid$descriptor() {
        return git_branch_name_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_branch_name_is_valid(int *valid, const char *name)
     * }
     */
    public static MethodHandle git_branch_name_is_valid$handle() {
        return git_branch_name_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_branch_name_is_valid(int *valid, const char *name)
     * }
     */
    public static MemorySegment git_branch_name_is_valid$address() {
        return git_branch_name_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_branch_name_is_valid(int *valid, const char *name)
     * }
     */
    public static int git_branch_name_is_valid(MemorySegment valid, MemorySegment name) {
        var mh$ = git_branch_name_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_branch_name_is_valid", valid, name);
            }
            return (int)mh$.invokeExact(valid, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_CERT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum git_cert_t.GIT_CERT_NONE = 0
     * }
     */
    public static int GIT_CERT_NONE() {
        return GIT_CERT_NONE;
    }
    private static final int GIT_CERT_X509 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum git_cert_t.GIT_CERT_X509 = 1
     * }
     */
    public static int GIT_CERT_X509() {
        return GIT_CERT_X509;
    }
    private static final int GIT_CERT_HOSTKEY_LIBSSH2 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum git_cert_t.GIT_CERT_HOSTKEY_LIBSSH2 = 2
     * }
     */
    public static int GIT_CERT_HOSTKEY_LIBSSH2() {
        return GIT_CERT_HOSTKEY_LIBSSH2;
    }
    private static final int GIT_CERT_STRARRAY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum git_cert_t.GIT_CERT_STRARRAY = 3
     * }
     */
    public static int GIT_CERT_STRARRAY() {
        return GIT_CERT_STRARRAY;
    }
    private static final int GIT_CERT_SSH_MD5 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_MD5 = 1
     * }
     */
    public static int GIT_CERT_SSH_MD5() {
        return GIT_CERT_SSH_MD5;
    }
    private static final int GIT_CERT_SSH_SHA1 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_SHA1 = 2
     * }
     */
    public static int GIT_CERT_SSH_SHA1() {
        return GIT_CERT_SSH_SHA1;
    }
    private static final int GIT_CERT_SSH_SHA256 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_SHA256 = 4
     * }
     */
    public static int GIT_CERT_SSH_SHA256() {
        return GIT_CERT_SSH_SHA256;
    }
    private static final int GIT_CERT_SSH_RAW = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_RAW = 8
     * }
     */
    public static int GIT_CERT_SSH_RAW() {
        return GIT_CERT_SSH_RAW;
    }
    private static final int GIT_CERT_SSH_RAW_TYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_RAW_TYPE_UNKNOWN = 0
     * }
     */
    public static int GIT_CERT_SSH_RAW_TYPE_UNKNOWN() {
        return GIT_CERT_SSH_RAW_TYPE_UNKNOWN;
    }
    private static final int GIT_CERT_SSH_RAW_TYPE_RSA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_RAW_TYPE_RSA = 1
     * }
     */
    public static int GIT_CERT_SSH_RAW_TYPE_RSA() {
        return GIT_CERT_SSH_RAW_TYPE_RSA;
    }
    private static final int GIT_CERT_SSH_RAW_TYPE_DSS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_RAW_TYPE_DSS = 2
     * }
     */
    public static int GIT_CERT_SSH_RAW_TYPE_DSS() {
        return GIT_CERT_SSH_RAW_TYPE_DSS;
    }
    private static final int GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256 = 3
     * }
     */
    public static int GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256() {
        return GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256;
    }
    private static final int GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384 = 4
     * }
     */
    public static int GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384() {
        return GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384;
    }
    private static final int GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521 = 5
     * }
     */
    public static int GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521() {
        return GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521;
    }
    private static final int GIT_CERT_SSH_RAW_TYPE_KEY_ED25519 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CERT_SSH_RAW_TYPE_KEY_ED25519 = 6
     * }
     */
    public static int GIT_CERT_SSH_RAW_TYPE_KEY_ED25519() {
        return GIT_CERT_SSH_RAW_TYPE_KEY_ED25519;
    }
    private static final int GIT_CHECKOUT_SAFE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_SAFE = 0
     * }
     */
    public static int GIT_CHECKOUT_SAFE() {
        return GIT_CHECKOUT_SAFE;
    }
    private static final int GIT_CHECKOUT_FORCE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_FORCE = 2
     * }
     */
    public static int GIT_CHECKOUT_FORCE() {
        return GIT_CHECKOUT_FORCE;
    }
    private static final int GIT_CHECKOUT_RECREATE_MISSING = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_RECREATE_MISSING = 4
     * }
     */
    public static int GIT_CHECKOUT_RECREATE_MISSING() {
        return GIT_CHECKOUT_RECREATE_MISSING;
    }
    private static final int GIT_CHECKOUT_ALLOW_CONFLICTS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_ALLOW_CONFLICTS = 16
     * }
     */
    public static int GIT_CHECKOUT_ALLOW_CONFLICTS() {
        return GIT_CHECKOUT_ALLOW_CONFLICTS;
    }
    private static final int GIT_CHECKOUT_REMOVE_UNTRACKED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_REMOVE_UNTRACKED = 32
     * }
     */
    public static int GIT_CHECKOUT_REMOVE_UNTRACKED() {
        return GIT_CHECKOUT_REMOVE_UNTRACKED;
    }
    private static final int GIT_CHECKOUT_REMOVE_IGNORED = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_REMOVE_IGNORED = 64
     * }
     */
    public static int GIT_CHECKOUT_REMOVE_IGNORED() {
        return GIT_CHECKOUT_REMOVE_IGNORED;
    }
    private static final int GIT_CHECKOUT_UPDATE_ONLY = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_UPDATE_ONLY = 128
     * }
     */
    public static int GIT_CHECKOUT_UPDATE_ONLY() {
        return GIT_CHECKOUT_UPDATE_ONLY;
    }
    private static final int GIT_CHECKOUT_DONT_UPDATE_INDEX = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_DONT_UPDATE_INDEX = 256
     * }
     */
    public static int GIT_CHECKOUT_DONT_UPDATE_INDEX() {
        return GIT_CHECKOUT_DONT_UPDATE_INDEX;
    }
    private static final int GIT_CHECKOUT_NO_REFRESH = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_NO_REFRESH = 512
     * }
     */
    public static int GIT_CHECKOUT_NO_REFRESH() {
        return GIT_CHECKOUT_NO_REFRESH;
    }
    private static final int GIT_CHECKOUT_SKIP_UNMERGED = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_SKIP_UNMERGED = 1024
     * }
     */
    public static int GIT_CHECKOUT_SKIP_UNMERGED() {
        return GIT_CHECKOUT_SKIP_UNMERGED;
    }
    private static final int GIT_CHECKOUT_USE_OURS = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_USE_OURS = 2048
     * }
     */
    public static int GIT_CHECKOUT_USE_OURS() {
        return GIT_CHECKOUT_USE_OURS;
    }
    private static final int GIT_CHECKOUT_USE_THEIRS = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_USE_THEIRS = 4096
     * }
     */
    public static int GIT_CHECKOUT_USE_THEIRS() {
        return GIT_CHECKOUT_USE_THEIRS;
    }
    private static final int GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = 8192
     * }
     */
    public static int GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH() {
        return GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH;
    }
    private static final int GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = 262144
     * }
     */
    public static int GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES() {
        return GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES;
    }
    private static final int GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = 524288
     * }
     */
    public static int GIT_CHECKOUT_DONT_OVERWRITE_IGNORED() {
        return GIT_CHECKOUT_DONT_OVERWRITE_IGNORED;
    }
    private static final int GIT_CHECKOUT_CONFLICT_STYLE_MERGE = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_CONFLICT_STYLE_MERGE = 1048576
     * }
     */
    public static int GIT_CHECKOUT_CONFLICT_STYLE_MERGE() {
        return GIT_CHECKOUT_CONFLICT_STYLE_MERGE;
    }
    private static final int GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = 2097152
     * }
     */
    public static int GIT_CHECKOUT_CONFLICT_STYLE_DIFF3() {
        return GIT_CHECKOUT_CONFLICT_STYLE_DIFF3;
    }
    private static final int GIT_CHECKOUT_DONT_REMOVE_EXISTING = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_DONT_REMOVE_EXISTING = 4194304
     * }
     */
    public static int GIT_CHECKOUT_DONT_REMOVE_EXISTING() {
        return GIT_CHECKOUT_DONT_REMOVE_EXISTING;
    }
    private static final int GIT_CHECKOUT_DONT_WRITE_INDEX = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_DONT_WRITE_INDEX = 8388608
     * }
     */
    public static int GIT_CHECKOUT_DONT_WRITE_INDEX() {
        return GIT_CHECKOUT_DONT_WRITE_INDEX;
    }
    private static final int GIT_CHECKOUT_DRY_RUN = (int)16777216L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_DRY_RUN = 16777216
     * }
     */
    public static int GIT_CHECKOUT_DRY_RUN() {
        return GIT_CHECKOUT_DRY_RUN;
    }
    private static final int GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3 = (int)33554432L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3 = 33554432
     * }
     */
    public static int GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3() {
        return GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3;
    }
    private static final int GIT_CHECKOUT_NONE = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_NONE = 1073741824
     * }
     */
    public static int GIT_CHECKOUT_NONE() {
        return GIT_CHECKOUT_NONE;
    }
    private static final int GIT_CHECKOUT_UPDATE_SUBMODULES = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_UPDATE_SUBMODULES = 65536
     * }
     */
    public static int GIT_CHECKOUT_UPDATE_SUBMODULES() {
        return GIT_CHECKOUT_UPDATE_SUBMODULES;
    }
    private static final int GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = 131072
     * }
     */
    public static int GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED() {
        return GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED;
    }
    private static final int GIT_CHECKOUT_NOTIFY_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_NOTIFY_NONE = 0
     * }
     */
    public static int GIT_CHECKOUT_NOTIFY_NONE() {
        return GIT_CHECKOUT_NOTIFY_NONE;
    }
    private static final int GIT_CHECKOUT_NOTIFY_CONFLICT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_NOTIFY_CONFLICT = 1
     * }
     */
    public static int GIT_CHECKOUT_NOTIFY_CONFLICT() {
        return GIT_CHECKOUT_NOTIFY_CONFLICT;
    }
    private static final int GIT_CHECKOUT_NOTIFY_DIRTY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_NOTIFY_DIRTY = 2
     * }
     */
    public static int GIT_CHECKOUT_NOTIFY_DIRTY() {
        return GIT_CHECKOUT_NOTIFY_DIRTY;
    }
    private static final int GIT_CHECKOUT_NOTIFY_UPDATED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_NOTIFY_UPDATED = 4
     * }
     */
    public static int GIT_CHECKOUT_NOTIFY_UPDATED() {
        return GIT_CHECKOUT_NOTIFY_UPDATED;
    }
    private static final int GIT_CHECKOUT_NOTIFY_UNTRACKED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_NOTIFY_UNTRACKED = 8
     * }
     */
    public static int GIT_CHECKOUT_NOTIFY_UNTRACKED() {
        return GIT_CHECKOUT_NOTIFY_UNTRACKED;
    }
    private static final int GIT_CHECKOUT_NOTIFY_IGNORED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_NOTIFY_IGNORED = 16
     * }
     */
    public static int GIT_CHECKOUT_NOTIFY_IGNORED() {
        return GIT_CHECKOUT_NOTIFY_IGNORED;
    }
    private static final int GIT_CHECKOUT_NOTIFY_ALL = (int)65535L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CHECKOUT_NOTIFY_ALL = 65535
     * }
     */
    public static int GIT_CHECKOUT_NOTIFY_ALL() {
        return GIT_CHECKOUT_NOTIFY_ALL;
    }

    private static class git_checkout_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_checkout_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_checkout_options_init(git_checkout_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_checkout_options_init$descriptor() {
        return git_checkout_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_checkout_options_init(git_checkout_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_checkout_options_init$handle() {
        return git_checkout_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_checkout_options_init(git_checkout_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_checkout_options_init$address() {
        return git_checkout_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_checkout_options_init(git_checkout_options *opts, unsigned int version)
     * }
     */
    public static int git_checkout_options_init(MemorySegment opts, int version) {
        var mh$ = git_checkout_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_checkout_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_checkout_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_checkout_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_checkout_head(git_repository *repo, const git_checkout_options *opts)
     * }
     */
    public static FunctionDescriptor git_checkout_head$descriptor() {
        return git_checkout_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_checkout_head(git_repository *repo, const git_checkout_options *opts)
     * }
     */
    public static MethodHandle git_checkout_head$handle() {
        return git_checkout_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_checkout_head(git_repository *repo, const git_checkout_options *opts)
     * }
     */
    public static MemorySegment git_checkout_head$address() {
        return git_checkout_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_checkout_head(git_repository *repo, const git_checkout_options *opts)
     * }
     */
    public static int git_checkout_head(MemorySegment repo, MemorySegment opts) {
        var mh$ = git_checkout_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_checkout_head", repo, opts);
            }
            return (int)mh$.invokeExact(repo, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_checkout_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_checkout_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_checkout_index(git_repository *repo, git_index *index, const git_checkout_options *opts)
     * }
     */
    public static FunctionDescriptor git_checkout_index$descriptor() {
        return git_checkout_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_checkout_index(git_repository *repo, git_index *index, const git_checkout_options *opts)
     * }
     */
    public static MethodHandle git_checkout_index$handle() {
        return git_checkout_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_checkout_index(git_repository *repo, git_index *index, const git_checkout_options *opts)
     * }
     */
    public static MemorySegment git_checkout_index$address() {
        return git_checkout_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_checkout_index(git_repository *repo, git_index *index, const git_checkout_options *opts)
     * }
     */
    public static int git_checkout_index(MemorySegment repo, MemorySegment index, MemorySegment opts) {
        var mh$ = git_checkout_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_checkout_index", repo, index, opts);
            }
            return (int)mh$.invokeExact(repo, index, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_checkout_tree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_checkout_tree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_checkout_tree(git_repository *repo, const git_object *treeish, const git_checkout_options *opts)
     * }
     */
    public static FunctionDescriptor git_checkout_tree$descriptor() {
        return git_checkout_tree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_checkout_tree(git_repository *repo, const git_object *treeish, const git_checkout_options *opts)
     * }
     */
    public static MethodHandle git_checkout_tree$handle() {
        return git_checkout_tree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_checkout_tree(git_repository *repo, const git_object *treeish, const git_checkout_options *opts)
     * }
     */
    public static MemorySegment git_checkout_tree$address() {
        return git_checkout_tree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_checkout_tree(git_repository *repo, const git_object *treeish, const git_checkout_options *opts)
     * }
     */
    public static int git_checkout_tree(MemorySegment repo, MemorySegment treeish, MemorySegment opts) {
        var mh$ = git_checkout_tree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_checkout_tree", repo, treeish, opts);
            }
            return (int)mh$.invokeExact(repo, treeish, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_INDEX_ENTRY_EXTENDED = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_ENTRY_EXTENDED = 16384
     * }
     */
    public static int GIT_INDEX_ENTRY_EXTENDED() {
        return GIT_INDEX_ENTRY_EXTENDED;
    }
    private static final int GIT_INDEX_ENTRY_VALID = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_ENTRY_VALID = 32768
     * }
     */
    public static int GIT_INDEX_ENTRY_VALID() {
        return GIT_INDEX_ENTRY_VALID;
    }
    private static final int GIT_INDEX_ENTRY_INTENT_TO_ADD = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_ENTRY_INTENT_TO_ADD = 8192
     * }
     */
    public static int GIT_INDEX_ENTRY_INTENT_TO_ADD() {
        return GIT_INDEX_ENTRY_INTENT_TO_ADD;
    }
    private static final int GIT_INDEX_ENTRY_SKIP_WORKTREE = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_ENTRY_SKIP_WORKTREE = 16384
     * }
     */
    public static int GIT_INDEX_ENTRY_SKIP_WORKTREE() {
        return GIT_INDEX_ENTRY_SKIP_WORKTREE;
    }
    private static final int GIT_INDEX_ENTRY_EXTENDED_FLAGS = (int)24576L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_ENTRY_EXTENDED_FLAGS = 24576
     * }
     */
    public static int GIT_INDEX_ENTRY_EXTENDED_FLAGS() {
        return GIT_INDEX_ENTRY_EXTENDED_FLAGS;
    }
    private static final int GIT_INDEX_ENTRY_UPTODATE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_ENTRY_UPTODATE = 4
     * }
     */
    public static int GIT_INDEX_ENTRY_UPTODATE() {
        return GIT_INDEX_ENTRY_UPTODATE;
    }
    private static final int GIT_INDEX_CAPABILITY_IGNORE_CASE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_CAPABILITY_IGNORE_CASE = 1
     * }
     */
    public static int GIT_INDEX_CAPABILITY_IGNORE_CASE() {
        return GIT_INDEX_CAPABILITY_IGNORE_CASE;
    }
    private static final int GIT_INDEX_CAPABILITY_NO_FILEMODE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_CAPABILITY_NO_FILEMODE = 2
     * }
     */
    public static int GIT_INDEX_CAPABILITY_NO_FILEMODE() {
        return GIT_INDEX_CAPABILITY_NO_FILEMODE;
    }
    private static final int GIT_INDEX_CAPABILITY_NO_SYMLINKS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_CAPABILITY_NO_SYMLINKS = 4
     * }
     */
    public static int GIT_INDEX_CAPABILITY_NO_SYMLINKS() {
        return GIT_INDEX_CAPABILITY_NO_SYMLINKS;
    }
    private static final int GIT_INDEX_CAPABILITY_FROM_OWNER = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_CAPABILITY_FROM_OWNER = -1
     * }
     */
    public static int GIT_INDEX_CAPABILITY_FROM_OWNER() {
        return GIT_INDEX_CAPABILITY_FROM_OWNER;
    }
    private static final int GIT_INDEX_ADD_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_ADD_DEFAULT = 0
     * }
     */
    public static int GIT_INDEX_ADD_DEFAULT() {
        return GIT_INDEX_ADD_DEFAULT;
    }
    private static final int GIT_INDEX_ADD_FORCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_ADD_FORCE = 1
     * }
     */
    public static int GIT_INDEX_ADD_FORCE() {
        return GIT_INDEX_ADD_FORCE;
    }
    private static final int GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH = 2
     * }
     */
    public static int GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH() {
        return GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH;
    }
    private static final int GIT_INDEX_ADD_CHECK_PATHSPEC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_ADD_CHECK_PATHSPEC = 4
     * }
     */
    public static int GIT_INDEX_ADD_CHECK_PATHSPEC() {
        return GIT_INDEX_ADD_CHECK_PATHSPEC;
    }
    private static final int GIT_INDEX_STAGE_ANY = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_STAGE_ANY = -1
     * }
     */
    public static int GIT_INDEX_STAGE_ANY() {
        return GIT_INDEX_STAGE_ANY;
    }
    private static final int GIT_INDEX_STAGE_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_STAGE_NORMAL = 0
     * }
     */
    public static int GIT_INDEX_STAGE_NORMAL() {
        return GIT_INDEX_STAGE_NORMAL;
    }
    private static final int GIT_INDEX_STAGE_ANCESTOR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_STAGE_ANCESTOR = 1
     * }
     */
    public static int GIT_INDEX_STAGE_ANCESTOR() {
        return GIT_INDEX_STAGE_ANCESTOR;
    }
    private static final int GIT_INDEX_STAGE_OURS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_STAGE_OURS = 2
     * }
     */
    public static int GIT_INDEX_STAGE_OURS() {
        return GIT_INDEX_STAGE_OURS;
    }
    private static final int GIT_INDEX_STAGE_THEIRS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_INDEX_STAGE_THEIRS = 3
     * }
     */
    public static int GIT_INDEX_STAGE_THEIRS() {
        return GIT_INDEX_STAGE_THEIRS;
    }

    private static class git_index_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_open(git_index **index_out, const char *index_path)
     * }
     */
    public static FunctionDescriptor git_index_open$descriptor() {
        return git_index_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_open(git_index **index_out, const char *index_path)
     * }
     */
    public static MethodHandle git_index_open$handle() {
        return git_index_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_open(git_index **index_out, const char *index_path)
     * }
     */
    public static MemorySegment git_index_open$address() {
        return git_index_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_open(git_index **index_out, const char *index_path)
     * }
     */
    public static int git_index_open(MemorySegment index_out, MemorySegment index_path) {
        var mh$ = git_index_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_open", index_out, index_path);
            }
            return (int)mh$.invokeExact(index_out, index_path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_new(git_index **index_out)
     * }
     */
    public static FunctionDescriptor git_index_new$descriptor() {
        return git_index_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_new(git_index **index_out)
     * }
     */
    public static MethodHandle git_index_new$handle() {
        return git_index_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_new(git_index **index_out)
     * }
     */
    public static MemorySegment git_index_new$address() {
        return git_index_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_new(git_index **index_out)
     * }
     */
    public static int git_index_new(MemorySegment index_out) {
        var mh$ = git_index_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_new", index_out);
            }
            return (int)mh$.invokeExact(index_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_index_free(git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_free$descriptor() {
        return git_index_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_index_free(git_index *index)
     * }
     */
    public static MethodHandle git_index_free$handle() {
        return git_index_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_index_free(git_index *index)
     * }
     */
    public static MemorySegment git_index_free$address() {
        return git_index_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_index_free(git_index *index)
     * }
     */
    public static void git_index_free(MemorySegment index) {
        var mh$ = git_index_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_free", index);
            }
            mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_index_owner(const git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_owner$descriptor() {
        return git_index_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_index_owner(const git_index *index)
     * }
     */
    public static MethodHandle git_index_owner$handle() {
        return git_index_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_index_owner(const git_index *index)
     * }
     */
    public static MemorySegment git_index_owner$address() {
        return git_index_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_index_owner(const git_index *index)
     * }
     */
    public static MemorySegment git_index_owner(MemorySegment index) {
        var mh$ = git_index_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_owner", index);
            }
            return (MemorySegment)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_caps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_caps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_caps(const git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_caps$descriptor() {
        return git_index_caps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_caps(const git_index *index)
     * }
     */
    public static MethodHandle git_index_caps$handle() {
        return git_index_caps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_caps(const git_index *index)
     * }
     */
    public static MemorySegment git_index_caps$address() {
        return git_index_caps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_caps(const git_index *index)
     * }
     */
    public static int git_index_caps(MemorySegment index) {
        var mh$ = git_index_caps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_caps", index);
            }
            return (int)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_set_caps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_set_caps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_set_caps(git_index *index, int caps)
     * }
     */
    public static FunctionDescriptor git_index_set_caps$descriptor() {
        return git_index_set_caps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_set_caps(git_index *index, int caps)
     * }
     */
    public static MethodHandle git_index_set_caps$handle() {
        return git_index_set_caps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_set_caps(git_index *index, int caps)
     * }
     */
    public static MemorySegment git_index_set_caps$address() {
        return git_index_set_caps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_set_caps(git_index *index, int caps)
     * }
     */
    public static int git_index_set_caps(MemorySegment index, int caps) {
        var mh$ = git_index_set_caps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_set_caps", index, caps);
            }
            return (int)mh$.invokeExact(index, caps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int git_index_version(git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_version$descriptor() {
        return git_index_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int git_index_version(git_index *index)
     * }
     */
    public static MethodHandle git_index_version$handle() {
        return git_index_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int git_index_version(git_index *index)
     * }
     */
    public static MemorySegment git_index_version$address() {
        return git_index_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int git_index_version(git_index *index)
     * }
     */
    public static int git_index_version(MemorySegment index) {
        var mh$ = git_index_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_version", index);
            }
            return (int)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_set_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_set_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_set_version(git_index *index, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_index_set_version$descriptor() {
        return git_index_set_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_set_version(git_index *index, unsigned int version)
     * }
     */
    public static MethodHandle git_index_set_version$handle() {
        return git_index_set_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_set_version(git_index *index, unsigned int version)
     * }
     */
    public static MemorySegment git_index_set_version$address() {
        return git_index_set_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_set_version(git_index *index, unsigned int version)
     * }
     */
    public static int git_index_set_version(MemorySegment index, int version) {
        var mh$ = git_index_set_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_set_version", index, version);
            }
            return (int)mh$.invokeExact(index, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_read(git_index *index, int force)
     * }
     */
    public static FunctionDescriptor git_index_read$descriptor() {
        return git_index_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_read(git_index *index, int force)
     * }
     */
    public static MethodHandle git_index_read$handle() {
        return git_index_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_read(git_index *index, int force)
     * }
     */
    public static MemorySegment git_index_read$address() {
        return git_index_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_read(git_index *index, int force)
     * }
     */
    public static int git_index_read(MemorySegment index, int force) {
        var mh$ = git_index_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_read", index, force);
            }
            return (int)mh$.invokeExact(index, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_write(git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_write$descriptor() {
        return git_index_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_write(git_index *index)
     * }
     */
    public static MethodHandle git_index_write$handle() {
        return git_index_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_write(git_index *index)
     * }
     */
    public static MemorySegment git_index_write$address() {
        return git_index_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_write(git_index *index)
     * }
     */
    public static int git_index_write(MemorySegment index) {
        var mh$ = git_index_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_write", index);
            }
            return (int)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_index_path(const git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_path$descriptor() {
        return git_index_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_index_path(const git_index *index)
     * }
     */
    public static MethodHandle git_index_path$handle() {
        return git_index_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_index_path(const git_index *index)
     * }
     */
    public static MemorySegment git_index_path$address() {
        return git_index_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_index_path(const git_index *index)
     * }
     */
    public static MemorySegment git_index_path(MemorySegment index) {
        var mh$ = git_index_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_path", index);
            }
            return (MemorySegment)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_checksum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_checksum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_index_checksum(git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_checksum$descriptor() {
        return git_index_checksum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_index_checksum(git_index *index)
     * }
     */
    public static MethodHandle git_index_checksum$handle() {
        return git_index_checksum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_index_checksum(git_index *index)
     * }
     */
    public static MemorySegment git_index_checksum$address() {
        return git_index_checksum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_index_checksum(git_index *index)
     * }
     */
    public static MemorySegment git_index_checksum(MemorySegment index) {
        var mh$ = git_index_checksum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_checksum", index);
            }
            return (MemorySegment)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_read_tree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_read_tree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_read_tree(git_index *index, const git_tree *tree)
     * }
     */
    public static FunctionDescriptor git_index_read_tree$descriptor() {
        return git_index_read_tree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_read_tree(git_index *index, const git_tree *tree)
     * }
     */
    public static MethodHandle git_index_read_tree$handle() {
        return git_index_read_tree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_read_tree(git_index *index, const git_tree *tree)
     * }
     */
    public static MemorySegment git_index_read_tree$address() {
        return git_index_read_tree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_read_tree(git_index *index, const git_tree *tree)
     * }
     */
    public static int git_index_read_tree(MemorySegment index, MemorySegment tree) {
        var mh$ = git_index_read_tree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_read_tree", index, tree);
            }
            return (int)mh$.invokeExact(index, tree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_write_tree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_write_tree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_write_tree(git_oid *out, git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_write_tree$descriptor() {
        return git_index_write_tree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_write_tree(git_oid *out, git_index *index)
     * }
     */
    public static MethodHandle git_index_write_tree$handle() {
        return git_index_write_tree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_write_tree(git_oid *out, git_index *index)
     * }
     */
    public static MemorySegment git_index_write_tree$address() {
        return git_index_write_tree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_write_tree(git_oid *out, git_index *index)
     * }
     */
    public static int git_index_write_tree(MemorySegment out, MemorySegment index) {
        var mh$ = git_index_write_tree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_write_tree", out, index);
            }
            return (int)mh$.invokeExact(out, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_write_tree_to {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_write_tree_to");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_write_tree_to(git_oid *out, git_index *index, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_index_write_tree_to$descriptor() {
        return git_index_write_tree_to.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_write_tree_to(git_oid *out, git_index *index, git_repository *repo)
     * }
     */
    public static MethodHandle git_index_write_tree_to$handle() {
        return git_index_write_tree_to.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_write_tree_to(git_oid *out, git_index *index, git_repository *repo)
     * }
     */
    public static MemorySegment git_index_write_tree_to$address() {
        return git_index_write_tree_to.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_write_tree_to(git_oid *out, git_index *index, git_repository *repo)
     * }
     */
    public static int git_index_write_tree_to(MemorySegment out, MemorySegment index, MemorySegment repo) {
        var mh$ = git_index_write_tree_to.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_write_tree_to", out, index, repo);
            }
            return (int)mh$.invokeExact(out, index, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_entrycount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_entrycount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_index_entrycount(const git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_entrycount$descriptor() {
        return git_index_entrycount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_index_entrycount(const git_index *index)
     * }
     */
    public static MethodHandle git_index_entrycount$handle() {
        return git_index_entrycount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_index_entrycount(const git_index *index)
     * }
     */
    public static MemorySegment git_index_entrycount$address() {
        return git_index_entrycount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_index_entrycount(const git_index *index)
     * }
     */
    public static long git_index_entrycount(MemorySegment index) {
        var mh$ = git_index_entrycount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_entrycount", index);
            }
            return (long)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_clear(git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_clear$descriptor() {
        return git_index_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_clear(git_index *index)
     * }
     */
    public static MethodHandle git_index_clear$handle() {
        return git_index_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_clear(git_index *index)
     * }
     */
    public static MemorySegment git_index_clear$address() {
        return git_index_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_clear(git_index *index)
     * }
     */
    public static int git_index_clear(MemorySegment index) {
        var mh$ = git_index_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_clear", index);
            }
            return (int)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_get_byindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_get_byindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_index_entry *git_index_get_byindex(git_index *index, size_t n)
     * }
     */
    public static FunctionDescriptor git_index_get_byindex$descriptor() {
        return git_index_get_byindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_index_entry *git_index_get_byindex(git_index *index, size_t n)
     * }
     */
    public static MethodHandle git_index_get_byindex$handle() {
        return git_index_get_byindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_index_entry *git_index_get_byindex(git_index *index, size_t n)
     * }
     */
    public static MemorySegment git_index_get_byindex$address() {
        return git_index_get_byindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_index_entry *git_index_get_byindex(git_index *index, size_t n)
     * }
     */
    public static MemorySegment git_index_get_byindex(MemorySegment index, long n) {
        var mh$ = git_index_get_byindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_get_byindex", index, n);
            }
            return (MemorySegment)mh$.invokeExact(index, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_get_bypath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_get_bypath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_index_entry *git_index_get_bypath(git_index *index, const char *path, int stage)
     * }
     */
    public static FunctionDescriptor git_index_get_bypath$descriptor() {
        return git_index_get_bypath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_index_entry *git_index_get_bypath(git_index *index, const char *path, int stage)
     * }
     */
    public static MethodHandle git_index_get_bypath$handle() {
        return git_index_get_bypath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_index_entry *git_index_get_bypath(git_index *index, const char *path, int stage)
     * }
     */
    public static MemorySegment git_index_get_bypath$address() {
        return git_index_get_bypath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_index_entry *git_index_get_bypath(git_index *index, const char *path, int stage)
     * }
     */
    public static MemorySegment git_index_get_bypath(MemorySegment index, MemorySegment path, int stage) {
        var mh$ = git_index_get_bypath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_get_bypath", index, path, stage);
            }
            return (MemorySegment)mh$.invokeExact(index, path, stage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_remove(git_index *index, const char *path, int stage)
     * }
     */
    public static FunctionDescriptor git_index_remove$descriptor() {
        return git_index_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_remove(git_index *index, const char *path, int stage)
     * }
     */
    public static MethodHandle git_index_remove$handle() {
        return git_index_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_remove(git_index *index, const char *path, int stage)
     * }
     */
    public static MemorySegment git_index_remove$address() {
        return git_index_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_remove(git_index *index, const char *path, int stage)
     * }
     */
    public static int git_index_remove(MemorySegment index, MemorySegment path, int stage) {
        var mh$ = git_index_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_remove", index, path, stage);
            }
            return (int)mh$.invokeExact(index, path, stage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_remove_directory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_remove_directory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_remove_directory(git_index *index, const char *dir, int stage)
     * }
     */
    public static FunctionDescriptor git_index_remove_directory$descriptor() {
        return git_index_remove_directory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_remove_directory(git_index *index, const char *dir, int stage)
     * }
     */
    public static MethodHandle git_index_remove_directory$handle() {
        return git_index_remove_directory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_remove_directory(git_index *index, const char *dir, int stage)
     * }
     */
    public static MemorySegment git_index_remove_directory$address() {
        return git_index_remove_directory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_remove_directory(git_index *index, const char *dir, int stage)
     * }
     */
    public static int git_index_remove_directory(MemorySegment index, MemorySegment dir, int stage) {
        var mh$ = git_index_remove_directory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_remove_directory", index, dir, stage);
            }
            return (int)mh$.invokeExact(index, dir, stage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_add(git_index *index, const git_index_entry *source_entry)
     * }
     */
    public static FunctionDescriptor git_index_add$descriptor() {
        return git_index_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_add(git_index *index, const git_index_entry *source_entry)
     * }
     */
    public static MethodHandle git_index_add$handle() {
        return git_index_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_add(git_index *index, const git_index_entry *source_entry)
     * }
     */
    public static MemorySegment git_index_add$address() {
        return git_index_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_add(git_index *index, const git_index_entry *source_entry)
     * }
     */
    public static int git_index_add(MemorySegment index, MemorySegment source_entry) {
        var mh$ = git_index_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_add", index, source_entry);
            }
            return (int)mh$.invokeExact(index, source_entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_entry_stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_entry_stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_entry_stage(const git_index_entry *entry)
     * }
     */
    public static FunctionDescriptor git_index_entry_stage$descriptor() {
        return git_index_entry_stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_entry_stage(const git_index_entry *entry)
     * }
     */
    public static MethodHandle git_index_entry_stage$handle() {
        return git_index_entry_stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_entry_stage(const git_index_entry *entry)
     * }
     */
    public static MemorySegment git_index_entry_stage$address() {
        return git_index_entry_stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_entry_stage(const git_index_entry *entry)
     * }
     */
    public static int git_index_entry_stage(MemorySegment entry) {
        var mh$ = git_index_entry_stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_entry_stage", entry);
            }
            return (int)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_entry_is_conflict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_entry_is_conflict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_entry_is_conflict(const git_index_entry *entry)
     * }
     */
    public static FunctionDescriptor git_index_entry_is_conflict$descriptor() {
        return git_index_entry_is_conflict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_entry_is_conflict(const git_index_entry *entry)
     * }
     */
    public static MethodHandle git_index_entry_is_conflict$handle() {
        return git_index_entry_is_conflict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_entry_is_conflict(const git_index_entry *entry)
     * }
     */
    public static MemorySegment git_index_entry_is_conflict$address() {
        return git_index_entry_is_conflict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_entry_is_conflict(const git_index_entry *entry)
     * }
     */
    public static int git_index_entry_is_conflict(MemorySegment entry) {
        var mh$ = git_index_entry_is_conflict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_entry_is_conflict", entry);
            }
            return (int)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_iterator_new(git_index_iterator **iterator_out, git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_iterator_new$descriptor() {
        return git_index_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_iterator_new(git_index_iterator **iterator_out, git_index *index)
     * }
     */
    public static MethodHandle git_index_iterator_new$handle() {
        return git_index_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_iterator_new(git_index_iterator **iterator_out, git_index *index)
     * }
     */
    public static MemorySegment git_index_iterator_new$address() {
        return git_index_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_iterator_new(git_index_iterator **iterator_out, git_index *index)
     * }
     */
    public static int git_index_iterator_new(MemorySegment iterator_out, MemorySegment index) {
        var mh$ = git_index_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_iterator_new", iterator_out, index);
            }
            return (int)mh$.invokeExact(iterator_out, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_iterator_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_iterator_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_iterator_next(const git_index_entry **out, git_index_iterator *iterator)
     * }
     */
    public static FunctionDescriptor git_index_iterator_next$descriptor() {
        return git_index_iterator_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_iterator_next(const git_index_entry **out, git_index_iterator *iterator)
     * }
     */
    public static MethodHandle git_index_iterator_next$handle() {
        return git_index_iterator_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_iterator_next(const git_index_entry **out, git_index_iterator *iterator)
     * }
     */
    public static MemorySegment git_index_iterator_next$address() {
        return git_index_iterator_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_iterator_next(const git_index_entry **out, git_index_iterator *iterator)
     * }
     */
    public static int git_index_iterator_next(MemorySegment out, MemorySegment iterator) {
        var mh$ = git_index_iterator_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_iterator_next", out, iterator);
            }
            return (int)mh$.invokeExact(out, iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_iterator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_iterator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_index_iterator_free(git_index_iterator *iterator)
     * }
     */
    public static FunctionDescriptor git_index_iterator_free$descriptor() {
        return git_index_iterator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_index_iterator_free(git_index_iterator *iterator)
     * }
     */
    public static MethodHandle git_index_iterator_free$handle() {
        return git_index_iterator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_index_iterator_free(git_index_iterator *iterator)
     * }
     */
    public static MemorySegment git_index_iterator_free$address() {
        return git_index_iterator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_index_iterator_free(git_index_iterator *iterator)
     * }
     */
    public static void git_index_iterator_free(MemorySegment iterator) {
        var mh$ = git_index_iterator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_iterator_free", iterator);
            }
            mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_add_bypath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_add_bypath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_add_bypath(git_index *index, const char *path)
     * }
     */
    public static FunctionDescriptor git_index_add_bypath$descriptor() {
        return git_index_add_bypath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_add_bypath(git_index *index, const char *path)
     * }
     */
    public static MethodHandle git_index_add_bypath$handle() {
        return git_index_add_bypath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_add_bypath(git_index *index, const char *path)
     * }
     */
    public static MemorySegment git_index_add_bypath$address() {
        return git_index_add_bypath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_add_bypath(git_index *index, const char *path)
     * }
     */
    public static int git_index_add_bypath(MemorySegment index, MemorySegment path) {
        var mh$ = git_index_add_bypath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_add_bypath", index, path);
            }
            return (int)mh$.invokeExact(index, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_add_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_add_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_add_from_buffer(git_index *index, const git_index_entry *entry, const void *buffer, size_t len)
     * }
     */
    public static FunctionDescriptor git_index_add_from_buffer$descriptor() {
        return git_index_add_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_add_from_buffer(git_index *index, const git_index_entry *entry, const void *buffer, size_t len)
     * }
     */
    public static MethodHandle git_index_add_from_buffer$handle() {
        return git_index_add_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_add_from_buffer(git_index *index, const git_index_entry *entry, const void *buffer, size_t len)
     * }
     */
    public static MemorySegment git_index_add_from_buffer$address() {
        return git_index_add_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_add_from_buffer(git_index *index, const git_index_entry *entry, const void *buffer, size_t len)
     * }
     */
    public static int git_index_add_from_buffer(MemorySegment index, MemorySegment entry, MemorySegment buffer, long len) {
        var mh$ = git_index_add_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_add_from_buffer", index, entry, buffer, len);
            }
            return (int)mh$.invokeExact(index, entry, buffer, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_remove_bypath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_remove_bypath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_remove_bypath(git_index *index, const char *path)
     * }
     */
    public static FunctionDescriptor git_index_remove_bypath$descriptor() {
        return git_index_remove_bypath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_remove_bypath(git_index *index, const char *path)
     * }
     */
    public static MethodHandle git_index_remove_bypath$handle() {
        return git_index_remove_bypath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_remove_bypath(git_index *index, const char *path)
     * }
     */
    public static MemorySegment git_index_remove_bypath$address() {
        return git_index_remove_bypath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_remove_bypath(git_index *index, const char *path)
     * }
     */
    public static int git_index_remove_bypath(MemorySegment index, MemorySegment path) {
        var mh$ = git_index_remove_bypath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_remove_bypath", index, path);
            }
            return (int)mh$.invokeExact(index, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_add_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_add_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_add_all(git_index *index, const git_strarray *pathspec, unsigned int flags, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_index_add_all$descriptor() {
        return git_index_add_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_add_all(git_index *index, const git_strarray *pathspec, unsigned int flags, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_index_add_all$handle() {
        return git_index_add_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_add_all(git_index *index, const git_strarray *pathspec, unsigned int flags, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_index_add_all$address() {
        return git_index_add_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_add_all(git_index *index, const git_strarray *pathspec, unsigned int flags, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static int git_index_add_all(MemorySegment index, MemorySegment pathspec, int flags, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_index_add_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_add_all", index, pathspec, flags, callback, payload);
            }
            return (int)mh$.invokeExact(index, pathspec, flags, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_remove_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_remove_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_remove_all(git_index *index, const git_strarray *pathspec, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_index_remove_all$descriptor() {
        return git_index_remove_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_remove_all(git_index *index, const git_strarray *pathspec, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_index_remove_all$handle() {
        return git_index_remove_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_remove_all(git_index *index, const git_strarray *pathspec, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_index_remove_all$address() {
        return git_index_remove_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_remove_all(git_index *index, const git_strarray *pathspec, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static int git_index_remove_all(MemorySegment index, MemorySegment pathspec, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_index_remove_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_remove_all", index, pathspec, callback, payload);
            }
            return (int)mh$.invokeExact(index, pathspec, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_update_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_update_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_update_all(git_index *index, const git_strarray *pathspec, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_index_update_all$descriptor() {
        return git_index_update_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_update_all(git_index *index, const git_strarray *pathspec, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_index_update_all$handle() {
        return git_index_update_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_update_all(git_index *index, const git_strarray *pathspec, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_index_update_all$address() {
        return git_index_update_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_update_all(git_index *index, const git_strarray *pathspec, git_index_matched_path_cb callback, void *payload)
     * }
     */
    public static int git_index_update_all(MemorySegment index, MemorySegment pathspec, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_index_update_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_update_all", index, pathspec, callback, payload);
            }
            return (int)mh$.invokeExact(index, pathspec, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_find(size_t *at_pos, git_index *index, const char *path)
     * }
     */
    public static FunctionDescriptor git_index_find$descriptor() {
        return git_index_find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_find(size_t *at_pos, git_index *index, const char *path)
     * }
     */
    public static MethodHandle git_index_find$handle() {
        return git_index_find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_find(size_t *at_pos, git_index *index, const char *path)
     * }
     */
    public static MemorySegment git_index_find$address() {
        return git_index_find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_find(size_t *at_pos, git_index *index, const char *path)
     * }
     */
    public static int git_index_find(MemorySegment at_pos, MemorySegment index, MemorySegment path) {
        var mh$ = git_index_find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_find", at_pos, index, path);
            }
            return (int)mh$.invokeExact(at_pos, index, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_find_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_find_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_find_prefix(size_t *at_pos, git_index *index, const char *prefix)
     * }
     */
    public static FunctionDescriptor git_index_find_prefix$descriptor() {
        return git_index_find_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_find_prefix(size_t *at_pos, git_index *index, const char *prefix)
     * }
     */
    public static MethodHandle git_index_find_prefix$handle() {
        return git_index_find_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_find_prefix(size_t *at_pos, git_index *index, const char *prefix)
     * }
     */
    public static MemorySegment git_index_find_prefix$address() {
        return git_index_find_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_find_prefix(size_t *at_pos, git_index *index, const char *prefix)
     * }
     */
    public static int git_index_find_prefix(MemorySegment at_pos, MemorySegment index, MemorySegment prefix) {
        var mh$ = git_index_find_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_find_prefix", at_pos, index, prefix);
            }
            return (int)mh$.invokeExact(at_pos, index, prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_conflict_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_conflict_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_conflict_add(git_index *index, const git_index_entry *ancestor_entry, const git_index_entry *our_entry, const git_index_entry *their_entry)
     * }
     */
    public static FunctionDescriptor git_index_conflict_add$descriptor() {
        return git_index_conflict_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_conflict_add(git_index *index, const git_index_entry *ancestor_entry, const git_index_entry *our_entry, const git_index_entry *their_entry)
     * }
     */
    public static MethodHandle git_index_conflict_add$handle() {
        return git_index_conflict_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_conflict_add(git_index *index, const git_index_entry *ancestor_entry, const git_index_entry *our_entry, const git_index_entry *their_entry)
     * }
     */
    public static MemorySegment git_index_conflict_add$address() {
        return git_index_conflict_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_conflict_add(git_index *index, const git_index_entry *ancestor_entry, const git_index_entry *our_entry, const git_index_entry *their_entry)
     * }
     */
    public static int git_index_conflict_add(MemorySegment index, MemorySegment ancestor_entry, MemorySegment our_entry, MemorySegment their_entry) {
        var mh$ = git_index_conflict_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_conflict_add", index, ancestor_entry, our_entry, their_entry);
            }
            return (int)mh$.invokeExact(index, ancestor_entry, our_entry, their_entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_conflict_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_conflict_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_conflict_get(const git_index_entry **ancestor_out, const git_index_entry **our_out, const git_index_entry **their_out, git_index *index, const char *path)
     * }
     */
    public static FunctionDescriptor git_index_conflict_get$descriptor() {
        return git_index_conflict_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_conflict_get(const git_index_entry **ancestor_out, const git_index_entry **our_out, const git_index_entry **their_out, git_index *index, const char *path)
     * }
     */
    public static MethodHandle git_index_conflict_get$handle() {
        return git_index_conflict_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_conflict_get(const git_index_entry **ancestor_out, const git_index_entry **our_out, const git_index_entry **their_out, git_index *index, const char *path)
     * }
     */
    public static MemorySegment git_index_conflict_get$address() {
        return git_index_conflict_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_conflict_get(const git_index_entry **ancestor_out, const git_index_entry **our_out, const git_index_entry **their_out, git_index *index, const char *path)
     * }
     */
    public static int git_index_conflict_get(MemorySegment ancestor_out, MemorySegment our_out, MemorySegment their_out, MemorySegment index, MemorySegment path) {
        var mh$ = git_index_conflict_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_conflict_get", ancestor_out, our_out, their_out, index, path);
            }
            return (int)mh$.invokeExact(ancestor_out, our_out, their_out, index, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_conflict_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_conflict_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_conflict_remove(git_index *index, const char *path)
     * }
     */
    public static FunctionDescriptor git_index_conflict_remove$descriptor() {
        return git_index_conflict_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_conflict_remove(git_index *index, const char *path)
     * }
     */
    public static MethodHandle git_index_conflict_remove$handle() {
        return git_index_conflict_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_conflict_remove(git_index *index, const char *path)
     * }
     */
    public static MemorySegment git_index_conflict_remove$address() {
        return git_index_conflict_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_conflict_remove(git_index *index, const char *path)
     * }
     */
    public static int git_index_conflict_remove(MemorySegment index, MemorySegment path) {
        var mh$ = git_index_conflict_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_conflict_remove", index, path);
            }
            return (int)mh$.invokeExact(index, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_conflict_cleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_conflict_cleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_conflict_cleanup(git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_conflict_cleanup$descriptor() {
        return git_index_conflict_cleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_conflict_cleanup(git_index *index)
     * }
     */
    public static MethodHandle git_index_conflict_cleanup$handle() {
        return git_index_conflict_cleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_conflict_cleanup(git_index *index)
     * }
     */
    public static MemorySegment git_index_conflict_cleanup$address() {
        return git_index_conflict_cleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_conflict_cleanup(git_index *index)
     * }
     */
    public static int git_index_conflict_cleanup(MemorySegment index) {
        var mh$ = git_index_conflict_cleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_conflict_cleanup", index);
            }
            return (int)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_has_conflicts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_has_conflicts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_has_conflicts(const git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_has_conflicts$descriptor() {
        return git_index_has_conflicts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_has_conflicts(const git_index *index)
     * }
     */
    public static MethodHandle git_index_has_conflicts$handle() {
        return git_index_has_conflicts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_has_conflicts(const git_index *index)
     * }
     */
    public static MemorySegment git_index_has_conflicts$address() {
        return git_index_has_conflicts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_has_conflicts(const git_index *index)
     * }
     */
    public static int git_index_has_conflicts(MemorySegment index) {
        var mh$ = git_index_has_conflicts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_has_conflicts", index);
            }
            return (int)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_conflict_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_conflict_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_conflict_iterator_new(git_index_conflict_iterator **iterator_out, git_index *index)
     * }
     */
    public static FunctionDescriptor git_index_conflict_iterator_new$descriptor() {
        return git_index_conflict_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_conflict_iterator_new(git_index_conflict_iterator **iterator_out, git_index *index)
     * }
     */
    public static MethodHandle git_index_conflict_iterator_new$handle() {
        return git_index_conflict_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_conflict_iterator_new(git_index_conflict_iterator **iterator_out, git_index *index)
     * }
     */
    public static MemorySegment git_index_conflict_iterator_new$address() {
        return git_index_conflict_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_conflict_iterator_new(git_index_conflict_iterator **iterator_out, git_index *index)
     * }
     */
    public static int git_index_conflict_iterator_new(MemorySegment iterator_out, MemorySegment index) {
        var mh$ = git_index_conflict_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_conflict_iterator_new", iterator_out, index);
            }
            return (int)mh$.invokeExact(iterator_out, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_conflict_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_conflict_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_conflict_next(const git_index_entry **ancestor_out, const git_index_entry **our_out, const git_index_entry **their_out, git_index_conflict_iterator *iterator)
     * }
     */
    public static FunctionDescriptor git_index_conflict_next$descriptor() {
        return git_index_conflict_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_conflict_next(const git_index_entry **ancestor_out, const git_index_entry **our_out, const git_index_entry **their_out, git_index_conflict_iterator *iterator)
     * }
     */
    public static MethodHandle git_index_conflict_next$handle() {
        return git_index_conflict_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_conflict_next(const git_index_entry **ancestor_out, const git_index_entry **our_out, const git_index_entry **their_out, git_index_conflict_iterator *iterator)
     * }
     */
    public static MemorySegment git_index_conflict_next$address() {
        return git_index_conflict_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_conflict_next(const git_index_entry **ancestor_out, const git_index_entry **our_out, const git_index_entry **their_out, git_index_conflict_iterator *iterator)
     * }
     */
    public static int git_index_conflict_next(MemorySegment ancestor_out, MemorySegment our_out, MemorySegment their_out, MemorySegment iterator) {
        var mh$ = git_index_conflict_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_conflict_next", ancestor_out, our_out, their_out, iterator);
            }
            return (int)mh$.invokeExact(ancestor_out, our_out, their_out, iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_conflict_iterator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_conflict_iterator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_index_conflict_iterator_free(git_index_conflict_iterator *iterator)
     * }
     */
    public static FunctionDescriptor git_index_conflict_iterator_free$descriptor() {
        return git_index_conflict_iterator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_index_conflict_iterator_free(git_index_conflict_iterator *iterator)
     * }
     */
    public static MethodHandle git_index_conflict_iterator_free$handle() {
        return git_index_conflict_iterator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_index_conflict_iterator_free(git_index_conflict_iterator *iterator)
     * }
     */
    public static MemorySegment git_index_conflict_iterator_free$address() {
        return git_index_conflict_iterator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_index_conflict_iterator_free(git_index_conflict_iterator *iterator)
     * }
     */
    public static void git_index_conflict_iterator_free(MemorySegment iterator) {
        var mh$ = git_index_conflict_iterator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_conflict_iterator_free", iterator);
            }
            mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_file_input_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_file_input_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_file_input_init(git_merge_file_input *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_merge_file_input_init$descriptor() {
        return git_merge_file_input_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_file_input_init(git_merge_file_input *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_merge_file_input_init$handle() {
        return git_merge_file_input_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_file_input_init(git_merge_file_input *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_merge_file_input_init$address() {
        return git_merge_file_input_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_file_input_init(git_merge_file_input *opts, unsigned int version)
     * }
     */
    public static int git_merge_file_input_init(MemorySegment opts, int version) {
        var mh$ = git_merge_file_input_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_file_input_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_MERGE_FIND_RENAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FIND_RENAMES = 1
     * }
     */
    public static int GIT_MERGE_FIND_RENAMES() {
        return GIT_MERGE_FIND_RENAMES;
    }
    private static final int GIT_MERGE_FAIL_ON_CONFLICT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FAIL_ON_CONFLICT = 2
     * }
     */
    public static int GIT_MERGE_FAIL_ON_CONFLICT() {
        return GIT_MERGE_FAIL_ON_CONFLICT;
    }
    private static final int GIT_MERGE_SKIP_REUC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_SKIP_REUC = 4
     * }
     */
    public static int GIT_MERGE_SKIP_REUC() {
        return GIT_MERGE_SKIP_REUC;
    }
    private static final int GIT_MERGE_NO_RECURSIVE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_NO_RECURSIVE = 8
     * }
     */
    public static int GIT_MERGE_NO_RECURSIVE() {
        return GIT_MERGE_NO_RECURSIVE;
    }
    private static final int GIT_MERGE_VIRTUAL_BASE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_VIRTUAL_BASE = 16
     * }
     */
    public static int GIT_MERGE_VIRTUAL_BASE() {
        return GIT_MERGE_VIRTUAL_BASE;
    }
    private static final int GIT_MERGE_FILE_FAVOR_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_FAVOR_NORMAL = 0
     * }
     */
    public static int GIT_MERGE_FILE_FAVOR_NORMAL() {
        return GIT_MERGE_FILE_FAVOR_NORMAL;
    }
    private static final int GIT_MERGE_FILE_FAVOR_OURS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_FAVOR_OURS = 1
     * }
     */
    public static int GIT_MERGE_FILE_FAVOR_OURS() {
        return GIT_MERGE_FILE_FAVOR_OURS;
    }
    private static final int GIT_MERGE_FILE_FAVOR_THEIRS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_FAVOR_THEIRS = 2
     * }
     */
    public static int GIT_MERGE_FILE_FAVOR_THEIRS() {
        return GIT_MERGE_FILE_FAVOR_THEIRS;
    }
    private static final int GIT_MERGE_FILE_FAVOR_UNION = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_FAVOR_UNION = 3
     * }
     */
    public static int GIT_MERGE_FILE_FAVOR_UNION() {
        return GIT_MERGE_FILE_FAVOR_UNION;
    }
    private static final int GIT_MERGE_FILE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_DEFAULT = 0
     * }
     */
    public static int GIT_MERGE_FILE_DEFAULT() {
        return GIT_MERGE_FILE_DEFAULT;
    }
    private static final int GIT_MERGE_FILE_STYLE_MERGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_STYLE_MERGE = 1
     * }
     */
    public static int GIT_MERGE_FILE_STYLE_MERGE() {
        return GIT_MERGE_FILE_STYLE_MERGE;
    }
    private static final int GIT_MERGE_FILE_STYLE_DIFF3 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_STYLE_DIFF3 = 2
     * }
     */
    public static int GIT_MERGE_FILE_STYLE_DIFF3() {
        return GIT_MERGE_FILE_STYLE_DIFF3;
    }
    private static final int GIT_MERGE_FILE_SIMPLIFY_ALNUM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_SIMPLIFY_ALNUM = 4
     * }
     */
    public static int GIT_MERGE_FILE_SIMPLIFY_ALNUM() {
        return GIT_MERGE_FILE_SIMPLIFY_ALNUM;
    }
    private static final int GIT_MERGE_FILE_IGNORE_WHITESPACE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_IGNORE_WHITESPACE = 8
     * }
     */
    public static int GIT_MERGE_FILE_IGNORE_WHITESPACE() {
        return GIT_MERGE_FILE_IGNORE_WHITESPACE;
    }
    private static final int GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE = 16
     * }
     */
    public static int GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE() {
        return GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE;
    }
    private static final int GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL = 32
     * }
     */
    public static int GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL() {
        return GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL;
    }
    private static final int GIT_MERGE_FILE_DIFF_PATIENCE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_DIFF_PATIENCE = 64
     * }
     */
    public static int GIT_MERGE_FILE_DIFF_PATIENCE() {
        return GIT_MERGE_FILE_DIFF_PATIENCE;
    }
    private static final int GIT_MERGE_FILE_DIFF_MINIMAL = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_DIFF_MINIMAL = 128
     * }
     */
    public static int GIT_MERGE_FILE_DIFF_MINIMAL() {
        return GIT_MERGE_FILE_DIFF_MINIMAL;
    }
    private static final int GIT_MERGE_FILE_STYLE_ZDIFF3 = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_STYLE_ZDIFF3 = 256
     * }
     */
    public static int GIT_MERGE_FILE_STYLE_ZDIFF3() {
        return GIT_MERGE_FILE_STYLE_ZDIFF3;
    }
    private static final int GIT_MERGE_FILE_ACCEPT_CONFLICTS = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_FILE_ACCEPT_CONFLICTS = 512
     * }
     */
    public static int GIT_MERGE_FILE_ACCEPT_CONFLICTS() {
        return GIT_MERGE_FILE_ACCEPT_CONFLICTS;
    }

    private static class git_merge_file_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_file_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_file_options_init(git_merge_file_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_merge_file_options_init$descriptor() {
        return git_merge_file_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_file_options_init(git_merge_file_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_merge_file_options_init$handle() {
        return git_merge_file_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_file_options_init(git_merge_file_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_merge_file_options_init$address() {
        return git_merge_file_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_file_options_init(git_merge_file_options *opts, unsigned int version)
     * }
     */
    public static int git_merge_file_options_init(MemorySegment opts, int version) {
        var mh$ = git_merge_file_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_file_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_options_init(git_merge_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_merge_options_init$descriptor() {
        return git_merge_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_options_init(git_merge_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_merge_options_init$handle() {
        return git_merge_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_options_init(git_merge_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_merge_options_init$address() {
        return git_merge_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_options_init(git_merge_options *opts, unsigned int version)
     * }
     */
    public static int git_merge_options_init(MemorySegment opts, int version) {
        var mh$ = git_merge_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_MERGE_ANALYSIS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_ANALYSIS_NONE = 0
     * }
     */
    public static int GIT_MERGE_ANALYSIS_NONE() {
        return GIT_MERGE_ANALYSIS_NONE;
    }
    private static final int GIT_MERGE_ANALYSIS_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_ANALYSIS_NORMAL = 1
     * }
     */
    public static int GIT_MERGE_ANALYSIS_NORMAL() {
        return GIT_MERGE_ANALYSIS_NORMAL;
    }
    private static final int GIT_MERGE_ANALYSIS_UP_TO_DATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_ANALYSIS_UP_TO_DATE = 2
     * }
     */
    public static int GIT_MERGE_ANALYSIS_UP_TO_DATE() {
        return GIT_MERGE_ANALYSIS_UP_TO_DATE;
    }
    private static final int GIT_MERGE_ANALYSIS_FASTFORWARD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_ANALYSIS_FASTFORWARD = 4
     * }
     */
    public static int GIT_MERGE_ANALYSIS_FASTFORWARD() {
        return GIT_MERGE_ANALYSIS_FASTFORWARD;
    }
    private static final int GIT_MERGE_ANALYSIS_UNBORN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_ANALYSIS_UNBORN = 8
     * }
     */
    public static int GIT_MERGE_ANALYSIS_UNBORN() {
        return GIT_MERGE_ANALYSIS_UNBORN;
    }
    private static final int GIT_MERGE_PREFERENCE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_PREFERENCE_NONE = 0
     * }
     */
    public static int GIT_MERGE_PREFERENCE_NONE() {
        return GIT_MERGE_PREFERENCE_NONE;
    }
    private static final int GIT_MERGE_PREFERENCE_NO_FASTFORWARD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_PREFERENCE_NO_FASTFORWARD = 1
     * }
     */
    public static int GIT_MERGE_PREFERENCE_NO_FASTFORWARD() {
        return GIT_MERGE_PREFERENCE_NO_FASTFORWARD;
    }
    private static final int GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY = 2
     * }
     */
    public static int GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY() {
        return GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY;
    }

    private static class git_merge_analysis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_analysis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_analysis(git_merge_analysis_t *analysis_out, git_merge_preference_t *preference_out, git_repository *repo, const git_annotated_commit **their_heads, size_t their_heads_len)
     * }
     */
    public static FunctionDescriptor git_merge_analysis$descriptor() {
        return git_merge_analysis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_analysis(git_merge_analysis_t *analysis_out, git_merge_preference_t *preference_out, git_repository *repo, const git_annotated_commit **their_heads, size_t their_heads_len)
     * }
     */
    public static MethodHandle git_merge_analysis$handle() {
        return git_merge_analysis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_analysis(git_merge_analysis_t *analysis_out, git_merge_preference_t *preference_out, git_repository *repo, const git_annotated_commit **their_heads, size_t their_heads_len)
     * }
     */
    public static MemorySegment git_merge_analysis$address() {
        return git_merge_analysis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_analysis(git_merge_analysis_t *analysis_out, git_merge_preference_t *preference_out, git_repository *repo, const git_annotated_commit **their_heads, size_t their_heads_len)
     * }
     */
    public static int git_merge_analysis(MemorySegment analysis_out, MemorySegment preference_out, MemorySegment repo, MemorySegment their_heads, long their_heads_len) {
        var mh$ = git_merge_analysis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_analysis", analysis_out, preference_out, repo, their_heads, their_heads_len);
            }
            return (int)mh$.invokeExact(analysis_out, preference_out, repo, their_heads, their_heads_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_analysis_for_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_analysis_for_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_analysis_for_ref(git_merge_analysis_t *analysis_out, git_merge_preference_t *preference_out, git_repository *repo, git_reference *our_ref, const git_annotated_commit **their_heads, size_t their_heads_len)
     * }
     */
    public static FunctionDescriptor git_merge_analysis_for_ref$descriptor() {
        return git_merge_analysis_for_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_analysis_for_ref(git_merge_analysis_t *analysis_out, git_merge_preference_t *preference_out, git_repository *repo, git_reference *our_ref, const git_annotated_commit **their_heads, size_t their_heads_len)
     * }
     */
    public static MethodHandle git_merge_analysis_for_ref$handle() {
        return git_merge_analysis_for_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_analysis_for_ref(git_merge_analysis_t *analysis_out, git_merge_preference_t *preference_out, git_repository *repo, git_reference *our_ref, const git_annotated_commit **their_heads, size_t their_heads_len)
     * }
     */
    public static MemorySegment git_merge_analysis_for_ref$address() {
        return git_merge_analysis_for_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_analysis_for_ref(git_merge_analysis_t *analysis_out, git_merge_preference_t *preference_out, git_repository *repo, git_reference *our_ref, const git_annotated_commit **their_heads, size_t their_heads_len)
     * }
     */
    public static int git_merge_analysis_for_ref(MemorySegment analysis_out, MemorySegment preference_out, MemorySegment repo, MemorySegment our_ref, MemorySegment their_heads, long their_heads_len) {
        var mh$ = git_merge_analysis_for_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_analysis_for_ref", analysis_out, preference_out, repo, our_ref, their_heads, their_heads_len);
            }
            return (int)mh$.invokeExact(analysis_out, preference_out, repo, our_ref, their_heads, their_heads_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_base(git_oid *out, git_repository *repo, const git_oid *one, const git_oid *two)
     * }
     */
    public static FunctionDescriptor git_merge_base$descriptor() {
        return git_merge_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_base(git_oid *out, git_repository *repo, const git_oid *one, const git_oid *two)
     * }
     */
    public static MethodHandle git_merge_base$handle() {
        return git_merge_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_base(git_oid *out, git_repository *repo, const git_oid *one, const git_oid *two)
     * }
     */
    public static MemorySegment git_merge_base$address() {
        return git_merge_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_base(git_oid *out, git_repository *repo, const git_oid *one, const git_oid *two)
     * }
     */
    public static int git_merge_base(MemorySegment out, MemorySegment repo, MemorySegment one, MemorySegment two) {
        var mh$ = git_merge_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_base", out, repo, one, two);
            }
            return (int)mh$.invokeExact(out, repo, one, two);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_bases {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_bases");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)
     * }
     */
    public static FunctionDescriptor git_merge_bases$descriptor() {
        return git_merge_bases.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)
     * }
     */
    public static MethodHandle git_merge_bases$handle() {
        return git_merge_bases.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)
     * }
     */
    public static MemorySegment git_merge_bases$address() {
        return git_merge_bases.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_bases(git_oidarray *out, git_repository *repo, const git_oid *one, const git_oid *two)
     * }
     */
    public static int git_merge_bases(MemorySegment out, MemorySegment repo, MemorySegment one, MemorySegment two) {
        var mh$ = git_merge_bases.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_bases", out, repo, one, two);
            }
            return (int)mh$.invokeExact(out, repo, one, two);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_base_many {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_base_many");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_base_many(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static FunctionDescriptor git_merge_base_many$descriptor() {
        return git_merge_base_many.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_base_many(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static MethodHandle git_merge_base_many$handle() {
        return git_merge_base_many.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_base_many(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static MemorySegment git_merge_base_many$address() {
        return git_merge_base_many.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_base_many(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static int git_merge_base_many(MemorySegment out, MemorySegment repo, long length, MemorySegment input_array) {
        var mh$ = git_merge_base_many.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_base_many", out, repo, length, input_array);
            }
            return (int)mh$.invokeExact(out, repo, length, input_array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_bases_many {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_bases_many");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_bases_many(git_oidarray *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static FunctionDescriptor git_merge_bases_many$descriptor() {
        return git_merge_bases_many.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_bases_many(git_oidarray *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static MethodHandle git_merge_bases_many$handle() {
        return git_merge_bases_many.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_bases_many(git_oidarray *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static MemorySegment git_merge_bases_many$address() {
        return git_merge_bases_many.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_bases_many(git_oidarray *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static int git_merge_bases_many(MemorySegment out, MemorySegment repo, long length, MemorySegment input_array) {
        var mh$ = git_merge_bases_many.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_bases_many", out, repo, length, input_array);
            }
            return (int)mh$.invokeExact(out, repo, length, input_array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_base_octopus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_base_octopus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_base_octopus(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static FunctionDescriptor git_merge_base_octopus$descriptor() {
        return git_merge_base_octopus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_base_octopus(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static MethodHandle git_merge_base_octopus$handle() {
        return git_merge_base_octopus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_base_octopus(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static MemorySegment git_merge_base_octopus$address() {
        return git_merge_base_octopus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_base_octopus(git_oid *out, git_repository *repo, size_t length, const git_oid input_array[])
     * }
     */
    public static int git_merge_base_octopus(MemorySegment out, MemorySegment repo, long length, MemorySegment input_array) {
        var mh$ = git_merge_base_octopus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_base_octopus", out, repo, length, input_array);
            }
            return (int)mh$.invokeExact(out, repo, length, input_array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_file(git_merge_file_result *out, const git_merge_file_input *ancestor, const git_merge_file_input *ours, const git_merge_file_input *theirs, const git_merge_file_options *opts)
     * }
     */
    public static FunctionDescriptor git_merge_file$descriptor() {
        return git_merge_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_file(git_merge_file_result *out, const git_merge_file_input *ancestor, const git_merge_file_input *ours, const git_merge_file_input *theirs, const git_merge_file_options *opts)
     * }
     */
    public static MethodHandle git_merge_file$handle() {
        return git_merge_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_file(git_merge_file_result *out, const git_merge_file_input *ancestor, const git_merge_file_input *ours, const git_merge_file_input *theirs, const git_merge_file_options *opts)
     * }
     */
    public static MemorySegment git_merge_file$address() {
        return git_merge_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_file(git_merge_file_result *out, const git_merge_file_input *ancestor, const git_merge_file_input *ours, const git_merge_file_input *theirs, const git_merge_file_options *opts)
     * }
     */
    public static int git_merge_file(MemorySegment out, MemorySegment ancestor, MemorySegment ours, MemorySegment theirs, MemorySegment opts) {
        var mh$ = git_merge_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_file", out, ancestor, ours, theirs, opts);
            }
            return (int)mh$.invokeExact(out, ancestor, ours, theirs, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_file_from_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_file_from_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_file_from_index(git_merge_file_result *out, git_repository *repo, const git_index_entry *ancestor, const git_index_entry *ours, const git_index_entry *theirs, const git_merge_file_options *opts)
     * }
     */
    public static FunctionDescriptor git_merge_file_from_index$descriptor() {
        return git_merge_file_from_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_file_from_index(git_merge_file_result *out, git_repository *repo, const git_index_entry *ancestor, const git_index_entry *ours, const git_index_entry *theirs, const git_merge_file_options *opts)
     * }
     */
    public static MethodHandle git_merge_file_from_index$handle() {
        return git_merge_file_from_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_file_from_index(git_merge_file_result *out, git_repository *repo, const git_index_entry *ancestor, const git_index_entry *ours, const git_index_entry *theirs, const git_merge_file_options *opts)
     * }
     */
    public static MemorySegment git_merge_file_from_index$address() {
        return git_merge_file_from_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_file_from_index(git_merge_file_result *out, git_repository *repo, const git_index_entry *ancestor, const git_index_entry *ours, const git_index_entry *theirs, const git_merge_file_options *opts)
     * }
     */
    public static int git_merge_file_from_index(MemorySegment out, MemorySegment repo, MemorySegment ancestor, MemorySegment ours, MemorySegment theirs, MemorySegment opts) {
        var mh$ = git_merge_file_from_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_file_from_index", out, repo, ancestor, ours, theirs, opts);
            }
            return (int)mh$.invokeExact(out, repo, ancestor, ours, theirs, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_file_result_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_file_result_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_merge_file_result_free(git_merge_file_result *result)
     * }
     */
    public static FunctionDescriptor git_merge_file_result_free$descriptor() {
        return git_merge_file_result_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_merge_file_result_free(git_merge_file_result *result)
     * }
     */
    public static MethodHandle git_merge_file_result_free$handle() {
        return git_merge_file_result_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_merge_file_result_free(git_merge_file_result *result)
     * }
     */
    public static MemorySegment git_merge_file_result_free$address() {
        return git_merge_file_result_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_merge_file_result_free(git_merge_file_result *result)
     * }
     */
    public static void git_merge_file_result_free(MemorySegment result) {
        var mh$ = git_merge_file_result_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_file_result_free", result);
            }
            mh$.invokeExact(result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_trees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_trees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_trees(git_index **out, git_repository *repo, const git_tree *ancestor_tree, const git_tree *our_tree, const git_tree *their_tree, const git_merge_options *opts)
     * }
     */
    public static FunctionDescriptor git_merge_trees$descriptor() {
        return git_merge_trees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_trees(git_index **out, git_repository *repo, const git_tree *ancestor_tree, const git_tree *our_tree, const git_tree *their_tree, const git_merge_options *opts)
     * }
     */
    public static MethodHandle git_merge_trees$handle() {
        return git_merge_trees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_trees(git_index **out, git_repository *repo, const git_tree *ancestor_tree, const git_tree *our_tree, const git_tree *their_tree, const git_merge_options *opts)
     * }
     */
    public static MemorySegment git_merge_trees$address() {
        return git_merge_trees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_trees(git_index **out, git_repository *repo, const git_tree *ancestor_tree, const git_tree *our_tree, const git_tree *their_tree, const git_merge_options *opts)
     * }
     */
    public static int git_merge_trees(MemorySegment out, MemorySegment repo, MemorySegment ancestor_tree, MemorySegment our_tree, MemorySegment their_tree, MemorySegment opts) {
        var mh$ = git_merge_trees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_trees", out, repo, ancestor_tree, our_tree, their_tree, opts);
            }
            return (int)mh$.invokeExact(out, repo, ancestor_tree, our_tree, their_tree, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_commits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_commits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_commits(git_index **out, git_repository *repo, const git_commit *our_commit, const git_commit *their_commit, const git_merge_options *opts)
     * }
     */
    public static FunctionDescriptor git_merge_commits$descriptor() {
        return git_merge_commits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_commits(git_index **out, git_repository *repo, const git_commit *our_commit, const git_commit *their_commit, const git_merge_options *opts)
     * }
     */
    public static MethodHandle git_merge_commits$handle() {
        return git_merge_commits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_commits(git_index **out, git_repository *repo, const git_commit *our_commit, const git_commit *their_commit, const git_merge_options *opts)
     * }
     */
    public static MemorySegment git_merge_commits$address() {
        return git_merge_commits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_commits(git_index **out, git_repository *repo, const git_commit *our_commit, const git_commit *their_commit, const git_merge_options *opts)
     * }
     */
    public static int git_merge_commits(MemorySegment out, MemorySegment repo, MemorySegment our_commit, MemorySegment their_commit, MemorySegment opts) {
        var mh$ = git_merge_commits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_commits", out, repo, our_commit, their_commit, opts);
            }
            return (int)mh$.invokeExact(out, repo, our_commit, their_commit, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge(git_repository *repo, const git_annotated_commit **their_heads, size_t their_heads_len, const git_merge_options *merge_opts, const git_checkout_options *checkout_opts)
     * }
     */
    public static FunctionDescriptor git_merge$descriptor() {
        return git_merge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge(git_repository *repo, const git_annotated_commit **their_heads, size_t their_heads_len, const git_merge_options *merge_opts, const git_checkout_options *checkout_opts)
     * }
     */
    public static MethodHandle git_merge$handle() {
        return git_merge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge(git_repository *repo, const git_annotated_commit **their_heads, size_t their_heads_len, const git_merge_options *merge_opts, const git_checkout_options *checkout_opts)
     * }
     */
    public static MemorySegment git_merge$address() {
        return git_merge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge(git_repository *repo, const git_annotated_commit **their_heads, size_t their_heads_len, const git_merge_options *merge_opts, const git_checkout_options *checkout_opts)
     * }
     */
    public static int git_merge(MemorySegment repo, MemorySegment their_heads, long their_heads_len, MemorySegment merge_opts, MemorySegment checkout_opts) {
        var mh$ = git_merge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge", repo, their_heads, their_heads_len, merge_opts, checkout_opts);
            }
            return (int)mh$.invokeExact(repo, their_heads, their_heads_len, merge_opts, checkout_opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cherrypick_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cherrypick_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cherrypick_options_init(git_cherrypick_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_cherrypick_options_init$descriptor() {
        return git_cherrypick_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cherrypick_options_init(git_cherrypick_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_cherrypick_options_init$handle() {
        return git_cherrypick_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cherrypick_options_init(git_cherrypick_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_cherrypick_options_init$address() {
        return git_cherrypick_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cherrypick_options_init(git_cherrypick_options *opts, unsigned int version)
     * }
     */
    public static int git_cherrypick_options_init(MemorySegment opts, int version) {
        var mh$ = git_cherrypick_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cherrypick_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cherrypick_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cherrypick_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cherrypick_commit(git_index **out, git_repository *repo, git_commit *cherrypick_commit, git_commit *our_commit, unsigned int mainline, const git_merge_options *merge_options)
     * }
     */
    public static FunctionDescriptor git_cherrypick_commit$descriptor() {
        return git_cherrypick_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cherrypick_commit(git_index **out, git_repository *repo, git_commit *cherrypick_commit, git_commit *our_commit, unsigned int mainline, const git_merge_options *merge_options)
     * }
     */
    public static MethodHandle git_cherrypick_commit$handle() {
        return git_cherrypick_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cherrypick_commit(git_index **out, git_repository *repo, git_commit *cherrypick_commit, git_commit *our_commit, unsigned int mainline, const git_merge_options *merge_options)
     * }
     */
    public static MemorySegment git_cherrypick_commit$address() {
        return git_cherrypick_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cherrypick_commit(git_index **out, git_repository *repo, git_commit *cherrypick_commit, git_commit *our_commit, unsigned int mainline, const git_merge_options *merge_options)
     * }
     */
    public static int git_cherrypick_commit(MemorySegment out, MemorySegment repo, MemorySegment cherrypick_commit, MemorySegment our_commit, int mainline, MemorySegment merge_options) {
        var mh$ = git_cherrypick_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cherrypick_commit", out, repo, cherrypick_commit, our_commit, mainline, merge_options);
            }
            return (int)mh$.invokeExact(out, repo, cherrypick_commit, our_commit, mainline, merge_options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cherrypick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cherrypick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cherrypick(git_repository *repo, git_commit *commit, const git_cherrypick_options *cherrypick_options)
     * }
     */
    public static FunctionDescriptor git_cherrypick$descriptor() {
        return git_cherrypick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cherrypick(git_repository *repo, git_commit *commit, const git_cherrypick_options *cherrypick_options)
     * }
     */
    public static MethodHandle git_cherrypick$handle() {
        return git_cherrypick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cherrypick(git_repository *repo, git_commit *commit, const git_cherrypick_options *cherrypick_options)
     * }
     */
    public static MemorySegment git_cherrypick$address() {
        return git_cherrypick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cherrypick(git_repository *repo, git_commit *commit, const git_cherrypick_options *cherrypick_options)
     * }
     */
    public static int git_cherrypick(MemorySegment repo, MemorySegment commit, MemorySegment cherrypick_options) {
        var mh$ = git_cherrypick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cherrypick", repo, commit, cherrypick_options);
            }
            return (int)mh$.invokeExact(repo, commit, cherrypick_options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_DIRECTION_FETCH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIRECTION_FETCH = 0
     * }
     */
    public static int GIT_DIRECTION_FETCH() {
        return GIT_DIRECTION_FETCH;
    }
    private static final int GIT_DIRECTION_PUSH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIRECTION_PUSH = 1
     * }
     */
    public static int GIT_DIRECTION_PUSH() {
        return GIT_DIRECTION_PUSH;
    }

    private static class git_refspec_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_refspec_parse(git_refspec **refspec, const char *input, int is_fetch)
     * }
     */
    public static FunctionDescriptor git_refspec_parse$descriptor() {
        return git_refspec_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_refspec_parse(git_refspec **refspec, const char *input, int is_fetch)
     * }
     */
    public static MethodHandle git_refspec_parse$handle() {
        return git_refspec_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_refspec_parse(git_refspec **refspec, const char *input, int is_fetch)
     * }
     */
    public static MemorySegment git_refspec_parse$address() {
        return git_refspec_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_refspec_parse(git_refspec **refspec, const char *input, int is_fetch)
     * }
     */
    public static int git_refspec_parse(MemorySegment refspec, MemorySegment input, int is_fetch) {
        var mh$ = git_refspec_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_parse", refspec, input, is_fetch);
            }
            return (int)mh$.invokeExact(refspec, input, is_fetch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_refspec_free(git_refspec *refspec)
     * }
     */
    public static FunctionDescriptor git_refspec_free$descriptor() {
        return git_refspec_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_refspec_free(git_refspec *refspec)
     * }
     */
    public static MethodHandle git_refspec_free$handle() {
        return git_refspec_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_refspec_free(git_refspec *refspec)
     * }
     */
    public static MemorySegment git_refspec_free$address() {
        return git_refspec_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_refspec_free(git_refspec *refspec)
     * }
     */
    public static void git_refspec_free(MemorySegment refspec) {
        var mh$ = git_refspec_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_free", refspec);
            }
            mh$.invokeExact(refspec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_src {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_src");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_refspec_src(const git_refspec *refspec)
     * }
     */
    public static FunctionDescriptor git_refspec_src$descriptor() {
        return git_refspec_src.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_refspec_src(const git_refspec *refspec)
     * }
     */
    public static MethodHandle git_refspec_src$handle() {
        return git_refspec_src.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_refspec_src(const git_refspec *refspec)
     * }
     */
    public static MemorySegment git_refspec_src$address() {
        return git_refspec_src.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_refspec_src(const git_refspec *refspec)
     * }
     */
    public static MemorySegment git_refspec_src(MemorySegment refspec) {
        var mh$ = git_refspec_src.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_src", refspec);
            }
            return (MemorySegment)mh$.invokeExact(refspec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_dst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_dst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_refspec_dst(const git_refspec *refspec)
     * }
     */
    public static FunctionDescriptor git_refspec_dst$descriptor() {
        return git_refspec_dst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_refspec_dst(const git_refspec *refspec)
     * }
     */
    public static MethodHandle git_refspec_dst$handle() {
        return git_refspec_dst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_refspec_dst(const git_refspec *refspec)
     * }
     */
    public static MemorySegment git_refspec_dst$address() {
        return git_refspec_dst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_refspec_dst(const git_refspec *refspec)
     * }
     */
    public static MemorySegment git_refspec_dst(MemorySegment refspec) {
        var mh$ = git_refspec_dst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_dst", refspec);
            }
            return (MemorySegment)mh$.invokeExact(refspec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_refspec_string(const git_refspec *refspec)
     * }
     */
    public static FunctionDescriptor git_refspec_string$descriptor() {
        return git_refspec_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_refspec_string(const git_refspec *refspec)
     * }
     */
    public static MethodHandle git_refspec_string$handle() {
        return git_refspec_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_refspec_string(const git_refspec *refspec)
     * }
     */
    public static MemorySegment git_refspec_string$address() {
        return git_refspec_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_refspec_string(const git_refspec *refspec)
     * }
     */
    public static MemorySegment git_refspec_string(MemorySegment refspec) {
        var mh$ = git_refspec_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_string", refspec);
            }
            return (MemorySegment)mh$.invokeExact(refspec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_force {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_force");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_refspec_force(const git_refspec *refspec)
     * }
     */
    public static FunctionDescriptor git_refspec_force$descriptor() {
        return git_refspec_force.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_refspec_force(const git_refspec *refspec)
     * }
     */
    public static MethodHandle git_refspec_force$handle() {
        return git_refspec_force.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_refspec_force(const git_refspec *refspec)
     * }
     */
    public static MemorySegment git_refspec_force$address() {
        return git_refspec_force.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_refspec_force(const git_refspec *refspec)
     * }
     */
    public static int git_refspec_force(MemorySegment refspec) {
        var mh$ = git_refspec_force.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_force", refspec);
            }
            return (int)mh$.invokeExact(refspec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_direction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_direction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_direction git_refspec_direction(const git_refspec *spec)
     * }
     */
    public static FunctionDescriptor git_refspec_direction$descriptor() {
        return git_refspec_direction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_direction git_refspec_direction(const git_refspec *spec)
     * }
     */
    public static MethodHandle git_refspec_direction$handle() {
        return git_refspec_direction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_direction git_refspec_direction(const git_refspec *spec)
     * }
     */
    public static MemorySegment git_refspec_direction$address() {
        return git_refspec_direction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_direction git_refspec_direction(const git_refspec *spec)
     * }
     */
    public static int git_refspec_direction(MemorySegment spec) {
        var mh$ = git_refspec_direction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_direction", spec);
            }
            return (int)mh$.invokeExact(spec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_src_matches_negative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_src_matches_negative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_refspec_src_matches_negative(const git_refspec *refspec, const char *refname)
     * }
     */
    public static FunctionDescriptor git_refspec_src_matches_negative$descriptor() {
        return git_refspec_src_matches_negative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_refspec_src_matches_negative(const git_refspec *refspec, const char *refname)
     * }
     */
    public static MethodHandle git_refspec_src_matches_negative$handle() {
        return git_refspec_src_matches_negative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_refspec_src_matches_negative(const git_refspec *refspec, const char *refname)
     * }
     */
    public static MemorySegment git_refspec_src_matches_negative$address() {
        return git_refspec_src_matches_negative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_refspec_src_matches_negative(const git_refspec *refspec, const char *refname)
     * }
     */
    public static int git_refspec_src_matches_negative(MemorySegment refspec, MemorySegment refname) {
        var mh$ = git_refspec_src_matches_negative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_src_matches_negative", refspec, refname);
            }
            return (int)mh$.invokeExact(refspec, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_src_matches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_src_matches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_refspec_src_matches(const git_refspec *refspec, const char *refname)
     * }
     */
    public static FunctionDescriptor git_refspec_src_matches$descriptor() {
        return git_refspec_src_matches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_refspec_src_matches(const git_refspec *refspec, const char *refname)
     * }
     */
    public static MethodHandle git_refspec_src_matches$handle() {
        return git_refspec_src_matches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_refspec_src_matches(const git_refspec *refspec, const char *refname)
     * }
     */
    public static MemorySegment git_refspec_src_matches$address() {
        return git_refspec_src_matches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_refspec_src_matches(const git_refspec *refspec, const char *refname)
     * }
     */
    public static int git_refspec_src_matches(MemorySegment refspec, MemorySegment refname) {
        var mh$ = git_refspec_src_matches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_src_matches", refspec, refname);
            }
            return (int)mh$.invokeExact(refspec, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_dst_matches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_dst_matches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_refspec_dst_matches(const git_refspec *refspec, const char *refname)
     * }
     */
    public static FunctionDescriptor git_refspec_dst_matches$descriptor() {
        return git_refspec_dst_matches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_refspec_dst_matches(const git_refspec *refspec, const char *refname)
     * }
     */
    public static MethodHandle git_refspec_dst_matches$handle() {
        return git_refspec_dst_matches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_refspec_dst_matches(const git_refspec *refspec, const char *refname)
     * }
     */
    public static MemorySegment git_refspec_dst_matches$address() {
        return git_refspec_dst_matches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_refspec_dst_matches(const git_refspec *refspec, const char *refname)
     * }
     */
    public static int git_refspec_dst_matches(MemorySegment refspec, MemorySegment refname) {
        var mh$ = git_refspec_dst_matches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_dst_matches", refspec, refname);
            }
            return (int)mh$.invokeExact(refspec, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_transform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_transform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)
     * }
     */
    public static FunctionDescriptor git_refspec_transform$descriptor() {
        return git_refspec_transform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)
     * }
     */
    public static MethodHandle git_refspec_transform$handle() {
        return git_refspec_transform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)
     * }
     */
    public static MemorySegment git_refspec_transform$address() {
        return git_refspec_transform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_refspec_transform(git_buf *out, const git_refspec *spec, const char *name)
     * }
     */
    public static int git_refspec_transform(MemorySegment out, MemorySegment spec, MemorySegment name) {
        var mh$ = git_refspec_transform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_transform", out, spec, name);
            }
            return (int)mh$.invokeExact(out, spec, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refspec_rtransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refspec_rtransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)
     * }
     */
    public static FunctionDescriptor git_refspec_rtransform$descriptor() {
        return git_refspec_rtransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)
     * }
     */
    public static MethodHandle git_refspec_rtransform$handle() {
        return git_refspec_rtransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)
     * }
     */
    public static MemorySegment git_refspec_rtransform$address() {
        return git_refspec_rtransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_refspec_rtransform(git_buf *out, const git_refspec *spec, const char *name)
     * }
     */
    public static int git_refspec_rtransform(MemorySegment out, MemorySegment spec, MemorySegment name) {
        var mh$ = git_refspec_rtransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refspec_rtransform", out, spec, name);
            }
            return (int)mh$.invokeExact(out, spec, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_CREDENTIAL_USERPASS_PLAINTEXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CREDENTIAL_USERPASS_PLAINTEXT = 1
     * }
     */
    public static int GIT_CREDENTIAL_USERPASS_PLAINTEXT() {
        return GIT_CREDENTIAL_USERPASS_PLAINTEXT;
    }
    private static final int GIT_CREDENTIAL_SSH_KEY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CREDENTIAL_SSH_KEY = 2
     * }
     */
    public static int GIT_CREDENTIAL_SSH_KEY() {
        return GIT_CREDENTIAL_SSH_KEY;
    }
    private static final int GIT_CREDENTIAL_SSH_CUSTOM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CREDENTIAL_SSH_CUSTOM = 4
     * }
     */
    public static int GIT_CREDENTIAL_SSH_CUSTOM() {
        return GIT_CREDENTIAL_SSH_CUSTOM;
    }
    private static final int GIT_CREDENTIAL_DEFAULT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CREDENTIAL_DEFAULT = 8
     * }
     */
    public static int GIT_CREDENTIAL_DEFAULT() {
        return GIT_CREDENTIAL_DEFAULT;
    }
    private static final int GIT_CREDENTIAL_SSH_INTERACTIVE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CREDENTIAL_SSH_INTERACTIVE = 16
     * }
     */
    public static int GIT_CREDENTIAL_SSH_INTERACTIVE() {
        return GIT_CREDENTIAL_SSH_INTERACTIVE;
    }
    private static final int GIT_CREDENTIAL_USERNAME = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CREDENTIAL_USERNAME = 32
     * }
     */
    public static int GIT_CREDENTIAL_USERNAME() {
        return GIT_CREDENTIAL_USERNAME;
    }
    private static final int GIT_CREDENTIAL_SSH_MEMORY = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CREDENTIAL_SSH_MEMORY = 64
     * }
     */
    public static int GIT_CREDENTIAL_SSH_MEMORY() {
        return GIT_CREDENTIAL_SSH_MEMORY;
    }

    private static class git_credential_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_credential_free(git_credential *cred)
     * }
     */
    public static FunctionDescriptor git_credential_free$descriptor() {
        return git_credential_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_credential_free(git_credential *cred)
     * }
     */
    public static MethodHandle git_credential_free$handle() {
        return git_credential_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_credential_free(git_credential *cred)
     * }
     */
    public static MemorySegment git_credential_free$address() {
        return git_credential_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_credential_free(git_credential *cred)
     * }
     */
    public static void git_credential_free(MemorySegment cred) {
        var mh$ = git_credential_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_free", cred);
            }
            mh$.invokeExact(cred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_has_username {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_has_username");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_credential_has_username(git_credential *cred)
     * }
     */
    public static FunctionDescriptor git_credential_has_username$descriptor() {
        return git_credential_has_username.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_credential_has_username(git_credential *cred)
     * }
     */
    public static MethodHandle git_credential_has_username$handle() {
        return git_credential_has_username.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_credential_has_username(git_credential *cred)
     * }
     */
    public static MemorySegment git_credential_has_username$address() {
        return git_credential_has_username.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_credential_has_username(git_credential *cred)
     * }
     */
    public static int git_credential_has_username(MemorySegment cred) {
        var mh$ = git_credential_has_username.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_has_username", cred);
            }
            return (int)mh$.invokeExact(cred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_get_username {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_get_username");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_credential_get_username(git_credential *cred)
     * }
     */
    public static FunctionDescriptor git_credential_get_username$descriptor() {
        return git_credential_get_username.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_credential_get_username(git_credential *cred)
     * }
     */
    public static MethodHandle git_credential_get_username$handle() {
        return git_credential_get_username.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_credential_get_username(git_credential *cred)
     * }
     */
    public static MemorySegment git_credential_get_username$address() {
        return git_credential_get_username.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_credential_get_username(git_credential *cred)
     * }
     */
    public static MemorySegment git_credential_get_username(MemorySegment cred) {
        var mh$ = git_credential_get_username.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_get_username", cred);
            }
            return (MemorySegment)mh$.invokeExact(cred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_userpass_plaintext_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_userpass_plaintext_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_credential_userpass_plaintext_new(git_credential **out, const char *username, const char *password)
     * }
     */
    public static FunctionDescriptor git_credential_userpass_plaintext_new$descriptor() {
        return git_credential_userpass_plaintext_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_credential_userpass_plaintext_new(git_credential **out, const char *username, const char *password)
     * }
     */
    public static MethodHandle git_credential_userpass_plaintext_new$handle() {
        return git_credential_userpass_plaintext_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_credential_userpass_plaintext_new(git_credential **out, const char *username, const char *password)
     * }
     */
    public static MemorySegment git_credential_userpass_plaintext_new$address() {
        return git_credential_userpass_plaintext_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_credential_userpass_plaintext_new(git_credential **out, const char *username, const char *password)
     * }
     */
    public static int git_credential_userpass_plaintext_new(MemorySegment out, MemorySegment username, MemorySegment password) {
        var mh$ = git_credential_userpass_plaintext_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_userpass_plaintext_new", out, username, password);
            }
            return (int)mh$.invokeExact(out, username, password);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_default_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_default_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_credential_default_new(git_credential **out)
     * }
     */
    public static FunctionDescriptor git_credential_default_new$descriptor() {
        return git_credential_default_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_credential_default_new(git_credential **out)
     * }
     */
    public static MethodHandle git_credential_default_new$handle() {
        return git_credential_default_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_credential_default_new(git_credential **out)
     * }
     */
    public static MemorySegment git_credential_default_new$address() {
        return git_credential_default_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_credential_default_new(git_credential **out)
     * }
     */
    public static int git_credential_default_new(MemorySegment out) {
        var mh$ = git_credential_default_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_default_new", out);
            }
            return (int)mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_username_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_username_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_credential_username_new(git_credential **out, const char *username)
     * }
     */
    public static FunctionDescriptor git_credential_username_new$descriptor() {
        return git_credential_username_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_credential_username_new(git_credential **out, const char *username)
     * }
     */
    public static MethodHandle git_credential_username_new$handle() {
        return git_credential_username_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_credential_username_new(git_credential **out, const char *username)
     * }
     */
    public static MemorySegment git_credential_username_new$address() {
        return git_credential_username_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_credential_username_new(git_credential **out, const char *username)
     * }
     */
    public static int git_credential_username_new(MemorySegment out, MemorySegment username) {
        var mh$ = git_credential_username_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_username_new", out, username);
            }
            return (int)mh$.invokeExact(out, username);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_ssh_key_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_ssh_key_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static FunctionDescriptor git_credential_ssh_key_new$descriptor() {
        return git_credential_ssh_key_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static MethodHandle git_credential_ssh_key_new$handle() {
        return git_credential_ssh_key_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static MemorySegment git_credential_ssh_key_new$address() {
        return git_credential_ssh_key_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static int git_credential_ssh_key_new(MemorySegment out, MemorySegment username, MemorySegment publickey, MemorySegment privatekey, MemorySegment passphrase) {
        var mh$ = git_credential_ssh_key_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_ssh_key_new", out, username, publickey, privatekey, passphrase);
            }
            return (int)mh$.invokeExact(out, username, publickey, privatekey, passphrase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_ssh_key_memory_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_ssh_key_memory_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_memory_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static FunctionDescriptor git_credential_ssh_key_memory_new$descriptor() {
        return git_credential_ssh_key_memory_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_memory_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static MethodHandle git_credential_ssh_key_memory_new$handle() {
        return git_credential_ssh_key_memory_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_memory_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static MemorySegment git_credential_ssh_key_memory_new$address() {
        return git_credential_ssh_key_memory_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_memory_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static int git_credential_ssh_key_memory_new(MemorySegment out, MemorySegment username, MemorySegment publickey, MemorySegment privatekey, MemorySegment passphrase) {
        var mh$ = git_credential_ssh_key_memory_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_ssh_key_memory_new", out, username, publickey, privatekey, passphrase);
            }
            return (int)mh$.invokeExact(out, username, publickey, privatekey, passphrase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_ssh_interactive_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_ssh_interactive_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_interactive_new(git_credential **out, const char *username, git_credential_ssh_interactive_cb prompt_callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_credential_ssh_interactive_new$descriptor() {
        return git_credential_ssh_interactive_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_interactive_new(git_credential **out, const char *username, git_credential_ssh_interactive_cb prompt_callback, void *payload)
     * }
     */
    public static MethodHandle git_credential_ssh_interactive_new$handle() {
        return git_credential_ssh_interactive_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_interactive_new(git_credential **out, const char *username, git_credential_ssh_interactive_cb prompt_callback, void *payload)
     * }
     */
    public static MemorySegment git_credential_ssh_interactive_new$address() {
        return git_credential_ssh_interactive_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_credential_ssh_interactive_new(git_credential **out, const char *username, git_credential_ssh_interactive_cb prompt_callback, void *payload)
     * }
     */
    public static int git_credential_ssh_interactive_new(MemorySegment out, MemorySegment username, MemorySegment prompt_callback, MemorySegment payload) {
        var mh$ = git_credential_ssh_interactive_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_ssh_interactive_new", out, username, prompt_callback, payload);
            }
            return (int)mh$.invokeExact(out, username, prompt_callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_ssh_key_from_agent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_ssh_key_from_agent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_from_agent(git_credential **out, const char *username)
     * }
     */
    public static FunctionDescriptor git_credential_ssh_key_from_agent$descriptor() {
        return git_credential_ssh_key_from_agent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_from_agent(git_credential **out, const char *username)
     * }
     */
    public static MethodHandle git_credential_ssh_key_from_agent$handle() {
        return git_credential_ssh_key_from_agent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_from_agent(git_credential **out, const char *username)
     * }
     */
    public static MemorySegment git_credential_ssh_key_from_agent$address() {
        return git_credential_ssh_key_from_agent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_credential_ssh_key_from_agent(git_credential **out, const char *username)
     * }
     */
    public static int git_credential_ssh_key_from_agent(MemorySegment out, MemorySegment username) {
        var mh$ = git_credential_ssh_key_from_agent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_ssh_key_from_agent", out, username);
            }
            return (int)mh$.invokeExact(out, username);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_ssh_custom_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_ssh_custom_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_custom_new(git_credential **out, const char *username, const char *publickey, size_t publickey_len, git_credential_sign_cb sign_callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_credential_ssh_custom_new$descriptor() {
        return git_credential_ssh_custom_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_custom_new(git_credential **out, const char *username, const char *publickey, size_t publickey_len, git_credential_sign_cb sign_callback, void *payload)
     * }
     */
    public static MethodHandle git_credential_ssh_custom_new$handle() {
        return git_credential_ssh_custom_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_credential_ssh_custom_new(git_credential **out, const char *username, const char *publickey, size_t publickey_len, git_credential_sign_cb sign_callback, void *payload)
     * }
     */
    public static MemorySegment git_credential_ssh_custom_new$address() {
        return git_credential_ssh_custom_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_credential_ssh_custom_new(git_credential **out, const char *username, const char *publickey, size_t publickey_len, git_credential_sign_cb sign_callback, void *payload)
     * }
     */
    public static int git_credential_ssh_custom_new(MemorySegment out, MemorySegment username, MemorySegment publickey, long publickey_len, MemorySegment sign_callback, MemorySegment payload) {
        var mh$ = git_credential_ssh_custom_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_ssh_custom_new", out, username, publickey, publickey_len, sign_callback, payload);
            }
            return (int)mh$.invokeExact(out, username, publickey, publickey_len, sign_callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_PACKBUILDER_ADDING_OBJECTS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PACKBUILDER_ADDING_OBJECTS = 0
     * }
     */
    public static int GIT_PACKBUILDER_ADDING_OBJECTS() {
        return GIT_PACKBUILDER_ADDING_OBJECTS;
    }
    private static final int GIT_PACKBUILDER_DELTAFICATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PACKBUILDER_DELTAFICATION = 1
     * }
     */
    public static int GIT_PACKBUILDER_DELTAFICATION() {
        return GIT_PACKBUILDER_DELTAFICATION;
    }

    private static class git_packbuilder_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_packbuilder_new(git_packbuilder **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_packbuilder_new$descriptor() {
        return git_packbuilder_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_packbuilder_new(git_packbuilder **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_packbuilder_new$handle() {
        return git_packbuilder_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_packbuilder_new(git_packbuilder **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_packbuilder_new$address() {
        return git_packbuilder_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_packbuilder_new(git_packbuilder **out, git_repository *repo)
     * }
     */
    public static int git_packbuilder_new(MemorySegment out, MemorySegment repo) {
        var mh$ = git_packbuilder_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_new", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_set_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_set_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int git_packbuilder_set_threads(git_packbuilder *pb, unsigned int n)
     * }
     */
    public static FunctionDescriptor git_packbuilder_set_threads$descriptor() {
        return git_packbuilder_set_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int git_packbuilder_set_threads(git_packbuilder *pb, unsigned int n)
     * }
     */
    public static MethodHandle git_packbuilder_set_threads$handle() {
        return git_packbuilder_set_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int git_packbuilder_set_threads(git_packbuilder *pb, unsigned int n)
     * }
     */
    public static MemorySegment git_packbuilder_set_threads$address() {
        return git_packbuilder_set_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int git_packbuilder_set_threads(git_packbuilder *pb, unsigned int n)
     * }
     */
    public static int git_packbuilder_set_threads(MemorySegment pb, int n) {
        var mh$ = git_packbuilder_set_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_set_threads", pb, n);
            }
            return (int)mh$.invokeExact(pb, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert(git_packbuilder *pb, const git_oid *id, const char *name)
     * }
     */
    public static FunctionDescriptor git_packbuilder_insert$descriptor() {
        return git_packbuilder_insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert(git_packbuilder *pb, const git_oid *id, const char *name)
     * }
     */
    public static MethodHandle git_packbuilder_insert$handle() {
        return git_packbuilder_insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert(git_packbuilder *pb, const git_oid *id, const char *name)
     * }
     */
    public static MemorySegment git_packbuilder_insert$address() {
        return git_packbuilder_insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_packbuilder_insert(git_packbuilder *pb, const git_oid *id, const char *name)
     * }
     */
    public static int git_packbuilder_insert(MemorySegment pb, MemorySegment id, MemorySegment name) {
        var mh$ = git_packbuilder_insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_insert", pb, id, name);
            }
            return (int)mh$.invokeExact(pb, id, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_insert_tree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_insert_tree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_tree(git_packbuilder *pb, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_packbuilder_insert_tree$descriptor() {
        return git_packbuilder_insert_tree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_tree(git_packbuilder *pb, const git_oid *id)
     * }
     */
    public static MethodHandle git_packbuilder_insert_tree$handle() {
        return git_packbuilder_insert_tree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_tree(git_packbuilder *pb, const git_oid *id)
     * }
     */
    public static MemorySegment git_packbuilder_insert_tree$address() {
        return git_packbuilder_insert_tree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_tree(git_packbuilder *pb, const git_oid *id)
     * }
     */
    public static int git_packbuilder_insert_tree(MemorySegment pb, MemorySegment id) {
        var mh$ = git_packbuilder_insert_tree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_insert_tree", pb, id);
            }
            return (int)mh$.invokeExact(pb, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_insert_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_insert_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_commit(git_packbuilder *pb, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_packbuilder_insert_commit$descriptor() {
        return git_packbuilder_insert_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_commit(git_packbuilder *pb, const git_oid *id)
     * }
     */
    public static MethodHandle git_packbuilder_insert_commit$handle() {
        return git_packbuilder_insert_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_commit(git_packbuilder *pb, const git_oid *id)
     * }
     */
    public static MemorySegment git_packbuilder_insert_commit$address() {
        return git_packbuilder_insert_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_commit(git_packbuilder *pb, const git_oid *id)
     * }
     */
    public static int git_packbuilder_insert_commit(MemorySegment pb, MemorySegment id) {
        var mh$ = git_packbuilder_insert_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_insert_commit", pb, id);
            }
            return (int)mh$.invokeExact(pb, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_insert_walk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_insert_walk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_walk(git_packbuilder *pb, git_revwalk *walk)
     * }
     */
    public static FunctionDescriptor git_packbuilder_insert_walk$descriptor() {
        return git_packbuilder_insert_walk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_walk(git_packbuilder *pb, git_revwalk *walk)
     * }
     */
    public static MethodHandle git_packbuilder_insert_walk$handle() {
        return git_packbuilder_insert_walk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_walk(git_packbuilder *pb, git_revwalk *walk)
     * }
     */
    public static MemorySegment git_packbuilder_insert_walk$address() {
        return git_packbuilder_insert_walk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_walk(git_packbuilder *pb, git_revwalk *walk)
     * }
     */
    public static int git_packbuilder_insert_walk(MemorySegment pb, MemorySegment walk) {
        var mh$ = git_packbuilder_insert_walk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_insert_walk", pb, walk);
            }
            return (int)mh$.invokeExact(pb, walk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_insert_recur {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_insert_recur");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)
     * }
     */
    public static FunctionDescriptor git_packbuilder_insert_recur$descriptor() {
        return git_packbuilder_insert_recur.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)
     * }
     */
    public static MethodHandle git_packbuilder_insert_recur$handle() {
        return git_packbuilder_insert_recur.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)
     * }
     */
    public static MemorySegment git_packbuilder_insert_recur$address() {
        return git_packbuilder_insert_recur.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_packbuilder_insert_recur(git_packbuilder *pb, const git_oid *id, const char *name)
     * }
     */
    public static int git_packbuilder_insert_recur(MemorySegment pb, MemorySegment id, MemorySegment name) {
        var mh$ = git_packbuilder_insert_recur.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_insert_recur", pb, id, name);
            }
            return (int)mh$.invokeExact(pb, id, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_write_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_write_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_packbuilder_write_buf(git_buf *buf, git_packbuilder *pb)
     * }
     */
    public static FunctionDescriptor git_packbuilder_write_buf$descriptor() {
        return git_packbuilder_write_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_packbuilder_write_buf(git_buf *buf, git_packbuilder *pb)
     * }
     */
    public static MethodHandle git_packbuilder_write_buf$handle() {
        return git_packbuilder_write_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_packbuilder_write_buf(git_buf *buf, git_packbuilder *pb)
     * }
     */
    public static MemorySegment git_packbuilder_write_buf$address() {
        return git_packbuilder_write_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_packbuilder_write_buf(git_buf *buf, git_packbuilder *pb)
     * }
     */
    public static int git_packbuilder_write_buf(MemorySegment buf, MemorySegment pb) {
        var mh$ = git_packbuilder_write_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_write_buf", buf, pb);
            }
            return (int)mh$.invokeExact(buf, pb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_packbuilder_write(git_packbuilder *pb, const char *path, unsigned int mode, git_indexer_progress_cb progress_cb, void *progress_cb_payload)
     * }
     */
    public static FunctionDescriptor git_packbuilder_write$descriptor() {
        return git_packbuilder_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_packbuilder_write(git_packbuilder *pb, const char *path, unsigned int mode, git_indexer_progress_cb progress_cb, void *progress_cb_payload)
     * }
     */
    public static MethodHandle git_packbuilder_write$handle() {
        return git_packbuilder_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_packbuilder_write(git_packbuilder *pb, const char *path, unsigned int mode, git_indexer_progress_cb progress_cb, void *progress_cb_payload)
     * }
     */
    public static MemorySegment git_packbuilder_write$address() {
        return git_packbuilder_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_packbuilder_write(git_packbuilder *pb, const char *path, unsigned int mode, git_indexer_progress_cb progress_cb, void *progress_cb_payload)
     * }
     */
    public static int git_packbuilder_write(MemorySegment pb, MemorySegment path, int mode, MemorySegment progress_cb, MemorySegment progress_cb_payload) {
        var mh$ = git_packbuilder_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_write", pb, path, mode, progress_cb, progress_cb_payload);
            }
            return (int)mh$.invokeExact(pb, path, mode, progress_cb, progress_cb_payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_packbuilder_hash(git_packbuilder *pb)
     * }
     */
    public static FunctionDescriptor git_packbuilder_hash$descriptor() {
        return git_packbuilder_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_packbuilder_hash(git_packbuilder *pb)
     * }
     */
    public static MethodHandle git_packbuilder_hash$handle() {
        return git_packbuilder_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_packbuilder_hash(git_packbuilder *pb)
     * }
     */
    public static MemorySegment git_packbuilder_hash$address() {
        return git_packbuilder_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_packbuilder_hash(git_packbuilder *pb)
     * }
     */
    public static MemorySegment git_packbuilder_hash(MemorySegment pb) {
        var mh$ = git_packbuilder_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_hash", pb);
            }
            return (MemorySegment)mh$.invokeExact(pb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_packbuilder_name(git_packbuilder *pb)
     * }
     */
    public static FunctionDescriptor git_packbuilder_name$descriptor() {
        return git_packbuilder_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_packbuilder_name(git_packbuilder *pb)
     * }
     */
    public static MethodHandle git_packbuilder_name$handle() {
        return git_packbuilder_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_packbuilder_name(git_packbuilder *pb)
     * }
     */
    public static MemorySegment git_packbuilder_name$address() {
        return git_packbuilder_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_packbuilder_name(git_packbuilder *pb)
     * }
     */
    public static MemorySegment git_packbuilder_name(MemorySegment pb) {
        var mh$ = git_packbuilder_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_name", pb);
            }
            return (MemorySegment)mh$.invokeExact(pb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_packbuilder_foreach(git_packbuilder *pb, git_packbuilder_foreach_cb cb, void *payload)
     * }
     */
    public static FunctionDescriptor git_packbuilder_foreach$descriptor() {
        return git_packbuilder_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_packbuilder_foreach(git_packbuilder *pb, git_packbuilder_foreach_cb cb, void *payload)
     * }
     */
    public static MethodHandle git_packbuilder_foreach$handle() {
        return git_packbuilder_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_packbuilder_foreach(git_packbuilder *pb, git_packbuilder_foreach_cb cb, void *payload)
     * }
     */
    public static MemorySegment git_packbuilder_foreach$address() {
        return git_packbuilder_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_packbuilder_foreach(git_packbuilder *pb, git_packbuilder_foreach_cb cb, void *payload)
     * }
     */
    public static int git_packbuilder_foreach(MemorySegment pb, MemorySegment cb, MemorySegment payload) {
        var mh$ = git_packbuilder_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_foreach", pb, cb, payload);
            }
            return (int)mh$.invokeExact(pb, cb, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_object_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_object_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_packbuilder_object_count(git_packbuilder *pb)
     * }
     */
    public static FunctionDescriptor git_packbuilder_object_count$descriptor() {
        return git_packbuilder_object_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_packbuilder_object_count(git_packbuilder *pb)
     * }
     */
    public static MethodHandle git_packbuilder_object_count$handle() {
        return git_packbuilder_object_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_packbuilder_object_count(git_packbuilder *pb)
     * }
     */
    public static MemorySegment git_packbuilder_object_count$address() {
        return git_packbuilder_object_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_packbuilder_object_count(git_packbuilder *pb)
     * }
     */
    public static long git_packbuilder_object_count(MemorySegment pb) {
        var mh$ = git_packbuilder_object_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_object_count", pb);
            }
            return (long)mh$.invokeExact(pb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_written {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_written");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_packbuilder_written(git_packbuilder *pb)
     * }
     */
    public static FunctionDescriptor git_packbuilder_written$descriptor() {
        return git_packbuilder_written.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_packbuilder_written(git_packbuilder *pb)
     * }
     */
    public static MethodHandle git_packbuilder_written$handle() {
        return git_packbuilder_written.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_packbuilder_written(git_packbuilder *pb)
     * }
     */
    public static MemorySegment git_packbuilder_written$address() {
        return git_packbuilder_written.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_packbuilder_written(git_packbuilder *pb)
     * }
     */
    public static long git_packbuilder_written(MemorySegment pb) {
        var mh$ = git_packbuilder_written.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_written", pb);
            }
            return (long)mh$.invokeExact(pb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_set_callbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_set_callbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_packbuilder_set_callbacks(git_packbuilder *pb, git_packbuilder_progress progress_cb, void *progress_cb_payload)
     * }
     */
    public static FunctionDescriptor git_packbuilder_set_callbacks$descriptor() {
        return git_packbuilder_set_callbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_packbuilder_set_callbacks(git_packbuilder *pb, git_packbuilder_progress progress_cb, void *progress_cb_payload)
     * }
     */
    public static MethodHandle git_packbuilder_set_callbacks$handle() {
        return git_packbuilder_set_callbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_packbuilder_set_callbacks(git_packbuilder *pb, git_packbuilder_progress progress_cb, void *progress_cb_payload)
     * }
     */
    public static MemorySegment git_packbuilder_set_callbacks$address() {
        return git_packbuilder_set_callbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_packbuilder_set_callbacks(git_packbuilder *pb, git_packbuilder_progress progress_cb, void *progress_cb_payload)
     * }
     */
    public static int git_packbuilder_set_callbacks(MemorySegment pb, MemorySegment progress_cb, MemorySegment progress_cb_payload) {
        var mh$ = git_packbuilder_set_callbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_set_callbacks", pb, progress_cb, progress_cb_payload);
            }
            return (int)mh$.invokeExact(pb, progress_cb, progress_cb_payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_packbuilder_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_packbuilder_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_packbuilder_free(git_packbuilder *pb)
     * }
     */
    public static FunctionDescriptor git_packbuilder_free$descriptor() {
        return git_packbuilder_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_packbuilder_free(git_packbuilder *pb)
     * }
     */
    public static MethodHandle git_packbuilder_free$handle() {
        return git_packbuilder_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_packbuilder_free(git_packbuilder *pb)
     * }
     */
    public static MemorySegment git_packbuilder_free$address() {
        return git_packbuilder_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_packbuilder_free(git_packbuilder *pb)
     * }
     */
    public static void git_packbuilder_free(MemorySegment pb) {
        var mh$ = git_packbuilder_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_packbuilder_free", pb);
            }
            mh$.invokeExact(pb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_PROXY_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PROXY_NONE = 0
     * }
     */
    public static int GIT_PROXY_NONE() {
        return GIT_PROXY_NONE;
    }
    private static final int GIT_PROXY_AUTO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PROXY_AUTO = 1
     * }
     */
    public static int GIT_PROXY_AUTO() {
        return GIT_PROXY_AUTO;
    }
    private static final int GIT_PROXY_SPECIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PROXY_SPECIFIED = 2
     * }
     */
    public static int GIT_PROXY_SPECIFIED() {
        return GIT_PROXY_SPECIFIED;
    }

    private static class git_proxy_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_proxy_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_proxy_options_init(git_proxy_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_proxy_options_init$descriptor() {
        return git_proxy_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_proxy_options_init(git_proxy_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_proxy_options_init$handle() {
        return git_proxy_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_proxy_options_init(git_proxy_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_proxy_options_init$address() {
        return git_proxy_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_proxy_options_init(git_proxy_options *opts, unsigned int version)
     * }
     */
    public static int git_proxy_options_init(MemorySegment opts, int version) {
        var mh$ = git_proxy_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_proxy_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_create(git_remote **out, git_repository *repo, const char *name, const char *url)
     * }
     */
    public static FunctionDescriptor git_remote_create$descriptor() {
        return git_remote_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_create(git_remote **out, git_repository *repo, const char *name, const char *url)
     * }
     */
    public static MethodHandle git_remote_create$handle() {
        return git_remote_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_create(git_remote **out, git_repository *repo, const char *name, const char *url)
     * }
     */
    public static MemorySegment git_remote_create$address() {
        return git_remote_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_create(git_remote **out, git_repository *repo, const char *name, const char *url)
     * }
     */
    public static int git_remote_create(MemorySegment out, MemorySegment repo, MemorySegment name, MemorySegment url) {
        var mh$ = git_remote_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_create", out, repo, name, url);
            }
            return (int)mh$.invokeExact(out, repo, name, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_REMOTE_REDIRECT_NONE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_REDIRECT_NONE = 1
     * }
     */
    public static int GIT_REMOTE_REDIRECT_NONE() {
        return GIT_REMOTE_REDIRECT_NONE;
    }
    private static final int GIT_REMOTE_REDIRECT_INITIAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_REDIRECT_INITIAL = 2
     * }
     */
    public static int GIT_REMOTE_REDIRECT_INITIAL() {
        return GIT_REMOTE_REDIRECT_INITIAL;
    }
    private static final int GIT_REMOTE_REDIRECT_ALL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_REDIRECT_ALL = 4
     * }
     */
    public static int GIT_REMOTE_REDIRECT_ALL() {
        return GIT_REMOTE_REDIRECT_ALL;
    }
    private static final int GIT_REMOTE_CREATE_SKIP_INSTEADOF = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_CREATE_SKIP_INSTEADOF = 1
     * }
     */
    public static int GIT_REMOTE_CREATE_SKIP_INSTEADOF() {
        return GIT_REMOTE_CREATE_SKIP_INSTEADOF;
    }
    private static final int GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC = 2
     * }
     */
    public static int GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC() {
        return GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC;
    }
    private static final int GIT_REMOTE_UPDATE_FETCHHEAD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_UPDATE_FETCHHEAD = 1
     * }
     */
    public static int GIT_REMOTE_UPDATE_FETCHHEAD() {
        return GIT_REMOTE_UPDATE_FETCHHEAD;
    }
    private static final int GIT_REMOTE_UPDATE_REPORT_UNCHANGED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_UPDATE_REPORT_UNCHANGED = 2
     * }
     */
    public static int GIT_REMOTE_UPDATE_REPORT_UNCHANGED() {
        return GIT_REMOTE_UPDATE_REPORT_UNCHANGED;
    }

    private static class git_remote_create_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_create_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_create_options_init(git_remote_create_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_remote_create_options_init$descriptor() {
        return git_remote_create_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_create_options_init(git_remote_create_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_remote_create_options_init$handle() {
        return git_remote_create_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_create_options_init(git_remote_create_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_remote_create_options_init$address() {
        return git_remote_create_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_create_options_init(git_remote_create_options *opts, unsigned int version)
     * }
     */
    public static int git_remote_create_options_init(MemorySegment opts, int version) {
        var mh$ = git_remote_create_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_create_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_create_with_opts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_create_with_opts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_create_with_opts(git_remote **out, const char *url, const git_remote_create_options *opts)
     * }
     */
    public static FunctionDescriptor git_remote_create_with_opts$descriptor() {
        return git_remote_create_with_opts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_create_with_opts(git_remote **out, const char *url, const git_remote_create_options *opts)
     * }
     */
    public static MethodHandle git_remote_create_with_opts$handle() {
        return git_remote_create_with_opts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_create_with_opts(git_remote **out, const char *url, const git_remote_create_options *opts)
     * }
     */
    public static MemorySegment git_remote_create_with_opts$address() {
        return git_remote_create_with_opts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_create_with_opts(git_remote **out, const char *url, const git_remote_create_options *opts)
     * }
     */
    public static int git_remote_create_with_opts(MemorySegment out, MemorySegment url, MemorySegment opts) {
        var mh$ = git_remote_create_with_opts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_create_with_opts", out, url, opts);
            }
            return (int)mh$.invokeExact(out, url, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_create_with_fetchspec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_create_with_fetchspec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_create_with_fetchspec(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)
     * }
     */
    public static FunctionDescriptor git_remote_create_with_fetchspec$descriptor() {
        return git_remote_create_with_fetchspec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_create_with_fetchspec(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)
     * }
     */
    public static MethodHandle git_remote_create_with_fetchspec$handle() {
        return git_remote_create_with_fetchspec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_create_with_fetchspec(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)
     * }
     */
    public static MemorySegment git_remote_create_with_fetchspec$address() {
        return git_remote_create_with_fetchspec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_create_with_fetchspec(git_remote **out, git_repository *repo, const char *name, const char *url, const char *fetch)
     * }
     */
    public static int git_remote_create_with_fetchspec(MemorySegment out, MemorySegment repo, MemorySegment name, MemorySegment url, MemorySegment fetch) {
        var mh$ = git_remote_create_with_fetchspec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_create_with_fetchspec", out, repo, name, url, fetch);
            }
            return (int)mh$.invokeExact(out, repo, name, url, fetch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_create_anonymous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_create_anonymous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_create_anonymous(git_remote **out, git_repository *repo, const char *url)
     * }
     */
    public static FunctionDescriptor git_remote_create_anonymous$descriptor() {
        return git_remote_create_anonymous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_create_anonymous(git_remote **out, git_repository *repo, const char *url)
     * }
     */
    public static MethodHandle git_remote_create_anonymous$handle() {
        return git_remote_create_anonymous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_create_anonymous(git_remote **out, git_repository *repo, const char *url)
     * }
     */
    public static MemorySegment git_remote_create_anonymous$address() {
        return git_remote_create_anonymous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_create_anonymous(git_remote **out, git_repository *repo, const char *url)
     * }
     */
    public static int git_remote_create_anonymous(MemorySegment out, MemorySegment repo, MemorySegment url) {
        var mh$ = git_remote_create_anonymous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_create_anonymous", out, repo, url);
            }
            return (int)mh$.invokeExact(out, repo, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_create_detached {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_create_detached");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_create_detached(git_remote **out, const char *url)
     * }
     */
    public static FunctionDescriptor git_remote_create_detached$descriptor() {
        return git_remote_create_detached.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_create_detached(git_remote **out, const char *url)
     * }
     */
    public static MethodHandle git_remote_create_detached$handle() {
        return git_remote_create_detached.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_create_detached(git_remote **out, const char *url)
     * }
     */
    public static MemorySegment git_remote_create_detached$address() {
        return git_remote_create_detached.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_create_detached(git_remote **out, const char *url)
     * }
     */
    public static int git_remote_create_detached(MemorySegment out, MemorySegment url) {
        var mh$ = git_remote_create_detached.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_create_detached", out, url);
            }
            return (int)mh$.invokeExact(out, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_remote_lookup$descriptor() {
        return git_remote_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_remote_lookup$handle() {
        return git_remote_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_remote_lookup$address() {
        return git_remote_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)
     * }
     */
    public static int git_remote_lookup(MemorySegment out, MemorySegment repo, MemorySegment name) {
        var mh$ = git_remote_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_lookup", out, repo, name);
            }
            return (int)mh$.invokeExact(out, repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_dup(git_remote **dest, git_remote *source)
     * }
     */
    public static FunctionDescriptor git_remote_dup$descriptor() {
        return git_remote_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_dup(git_remote **dest, git_remote *source)
     * }
     */
    public static MethodHandle git_remote_dup$handle() {
        return git_remote_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_dup(git_remote **dest, git_remote *source)
     * }
     */
    public static MemorySegment git_remote_dup$address() {
        return git_remote_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_dup(git_remote **dest, git_remote *source)
     * }
     */
    public static int git_remote_dup(MemorySegment dest, MemorySegment source) {
        var mh$ = git_remote_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_dup", dest, source);
            }
            return (int)mh$.invokeExact(dest, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_remote_owner(const git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_owner$descriptor() {
        return git_remote_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_remote_owner(const git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_owner$handle() {
        return git_remote_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_remote_owner(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_owner$address() {
        return git_remote_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_remote_owner(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_owner(MemorySegment remote) {
        var mh$ = git_remote_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_owner", remote);
            }
            return (MemorySegment)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_remote_name(const git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_name$descriptor() {
        return git_remote_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_remote_name(const git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_name$handle() {
        return git_remote_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_remote_name(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_name$address() {
        return git_remote_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_remote_name(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_name(MemorySegment remote) {
        var mh$ = git_remote_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_name", remote);
            }
            return (MemorySegment)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_url {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_url");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_remote_url(const git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_url$descriptor() {
        return git_remote_url.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_remote_url(const git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_url$handle() {
        return git_remote_url.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_remote_url(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_url$address() {
        return git_remote_url.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_remote_url(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_url(MemorySegment remote) {
        var mh$ = git_remote_url.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_url", remote);
            }
            return (MemorySegment)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_pushurl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_pushurl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_remote_pushurl(const git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_pushurl$descriptor() {
        return git_remote_pushurl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_remote_pushurl(const git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_pushurl$handle() {
        return git_remote_pushurl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_remote_pushurl(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_pushurl$address() {
        return git_remote_pushurl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_remote_pushurl(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_pushurl(MemorySegment remote) {
        var mh$ = git_remote_pushurl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_pushurl", remote);
            }
            return (MemorySegment)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_set_url {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_set_url");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_set_url(git_repository *repo, const char *remote, const char *url)
     * }
     */
    public static FunctionDescriptor git_remote_set_url$descriptor() {
        return git_remote_set_url.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_set_url(git_repository *repo, const char *remote, const char *url)
     * }
     */
    public static MethodHandle git_remote_set_url$handle() {
        return git_remote_set_url.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_set_url(git_repository *repo, const char *remote, const char *url)
     * }
     */
    public static MemorySegment git_remote_set_url$address() {
        return git_remote_set_url.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_set_url(git_repository *repo, const char *remote, const char *url)
     * }
     */
    public static int git_remote_set_url(MemorySegment repo, MemorySegment remote, MemorySegment url) {
        var mh$ = git_remote_set_url.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_set_url", repo, remote, url);
            }
            return (int)mh$.invokeExact(repo, remote, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_set_pushurl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_set_pushurl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_set_pushurl(git_repository *repo, const char *remote, const char *url)
     * }
     */
    public static FunctionDescriptor git_remote_set_pushurl$descriptor() {
        return git_remote_set_pushurl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_set_pushurl(git_repository *repo, const char *remote, const char *url)
     * }
     */
    public static MethodHandle git_remote_set_pushurl$handle() {
        return git_remote_set_pushurl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_set_pushurl(git_repository *repo, const char *remote, const char *url)
     * }
     */
    public static MemorySegment git_remote_set_pushurl$address() {
        return git_remote_set_pushurl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_set_pushurl(git_repository *repo, const char *remote, const char *url)
     * }
     */
    public static int git_remote_set_pushurl(MemorySegment repo, MemorySegment remote, MemorySegment url) {
        var mh$ = git_remote_set_pushurl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_set_pushurl", repo, remote, url);
            }
            return (int)mh$.invokeExact(repo, remote, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_set_instance_url {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_set_instance_url");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_set_instance_url(git_remote *remote, const char *url)
     * }
     */
    public static FunctionDescriptor git_remote_set_instance_url$descriptor() {
        return git_remote_set_instance_url.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_set_instance_url(git_remote *remote, const char *url)
     * }
     */
    public static MethodHandle git_remote_set_instance_url$handle() {
        return git_remote_set_instance_url.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_set_instance_url(git_remote *remote, const char *url)
     * }
     */
    public static MemorySegment git_remote_set_instance_url$address() {
        return git_remote_set_instance_url.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_set_instance_url(git_remote *remote, const char *url)
     * }
     */
    public static int git_remote_set_instance_url(MemorySegment remote, MemorySegment url) {
        var mh$ = git_remote_set_instance_url.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_set_instance_url", remote, url);
            }
            return (int)mh$.invokeExact(remote, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_set_instance_pushurl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_set_instance_pushurl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_set_instance_pushurl(git_remote *remote, const char *url)
     * }
     */
    public static FunctionDescriptor git_remote_set_instance_pushurl$descriptor() {
        return git_remote_set_instance_pushurl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_set_instance_pushurl(git_remote *remote, const char *url)
     * }
     */
    public static MethodHandle git_remote_set_instance_pushurl$handle() {
        return git_remote_set_instance_pushurl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_set_instance_pushurl(git_remote *remote, const char *url)
     * }
     */
    public static MemorySegment git_remote_set_instance_pushurl$address() {
        return git_remote_set_instance_pushurl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_set_instance_pushurl(git_remote *remote, const char *url)
     * }
     */
    public static int git_remote_set_instance_pushurl(MemorySegment remote, MemorySegment url) {
        var mh$ = git_remote_set_instance_pushurl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_set_instance_pushurl", remote, url);
            }
            return (int)mh$.invokeExact(remote, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_add_fetch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_add_fetch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_add_fetch(git_repository *repo, const char *remote, const char *refspec)
     * }
     */
    public static FunctionDescriptor git_remote_add_fetch$descriptor() {
        return git_remote_add_fetch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_add_fetch(git_repository *repo, const char *remote, const char *refspec)
     * }
     */
    public static MethodHandle git_remote_add_fetch$handle() {
        return git_remote_add_fetch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_add_fetch(git_repository *repo, const char *remote, const char *refspec)
     * }
     */
    public static MemorySegment git_remote_add_fetch$address() {
        return git_remote_add_fetch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_add_fetch(git_repository *repo, const char *remote, const char *refspec)
     * }
     */
    public static int git_remote_add_fetch(MemorySegment repo, MemorySegment remote, MemorySegment refspec) {
        var mh$ = git_remote_add_fetch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_add_fetch", repo, remote, refspec);
            }
            return (int)mh$.invokeExact(repo, remote, refspec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_get_fetch_refspecs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_get_fetch_refspecs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_get_fetch_refspecs(git_strarray *array, const git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_get_fetch_refspecs$descriptor() {
        return git_remote_get_fetch_refspecs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_get_fetch_refspecs(git_strarray *array, const git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_get_fetch_refspecs$handle() {
        return git_remote_get_fetch_refspecs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_get_fetch_refspecs(git_strarray *array, const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_get_fetch_refspecs$address() {
        return git_remote_get_fetch_refspecs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_get_fetch_refspecs(git_strarray *array, const git_remote *remote)
     * }
     */
    public static int git_remote_get_fetch_refspecs(MemorySegment array, MemorySegment remote) {
        var mh$ = git_remote_get_fetch_refspecs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_get_fetch_refspecs", array, remote);
            }
            return (int)mh$.invokeExact(array, remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_add_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_add_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_add_push(git_repository *repo, const char *remote, const char *refspec)
     * }
     */
    public static FunctionDescriptor git_remote_add_push$descriptor() {
        return git_remote_add_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_add_push(git_repository *repo, const char *remote, const char *refspec)
     * }
     */
    public static MethodHandle git_remote_add_push$handle() {
        return git_remote_add_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_add_push(git_repository *repo, const char *remote, const char *refspec)
     * }
     */
    public static MemorySegment git_remote_add_push$address() {
        return git_remote_add_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_add_push(git_repository *repo, const char *remote, const char *refspec)
     * }
     */
    public static int git_remote_add_push(MemorySegment repo, MemorySegment remote, MemorySegment refspec) {
        var mh$ = git_remote_add_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_add_push", repo, remote, refspec);
            }
            return (int)mh$.invokeExact(repo, remote, refspec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_get_push_refspecs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_get_push_refspecs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_get_push_refspecs(git_strarray *array, const git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_get_push_refspecs$descriptor() {
        return git_remote_get_push_refspecs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_get_push_refspecs(git_strarray *array, const git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_get_push_refspecs$handle() {
        return git_remote_get_push_refspecs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_get_push_refspecs(git_strarray *array, const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_get_push_refspecs$address() {
        return git_remote_get_push_refspecs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_get_push_refspecs(git_strarray *array, const git_remote *remote)
     * }
     */
    public static int git_remote_get_push_refspecs(MemorySegment array, MemorySegment remote) {
        var mh$ = git_remote_get_push_refspecs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_get_push_refspecs", array, remote);
            }
            return (int)mh$.invokeExact(array, remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_refspec_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_refspec_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_remote_refspec_count(const git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_refspec_count$descriptor() {
        return git_remote_refspec_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_remote_refspec_count(const git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_refspec_count$handle() {
        return git_remote_refspec_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_remote_refspec_count(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_refspec_count$address() {
        return git_remote_refspec_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_remote_refspec_count(const git_remote *remote)
     * }
     */
    public static long git_remote_refspec_count(MemorySegment remote) {
        var mh$ = git_remote_refspec_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_refspec_count", remote);
            }
            return (long)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_get_refspec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_get_refspec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_refspec *git_remote_get_refspec(const git_remote *remote, size_t n)
     * }
     */
    public static FunctionDescriptor git_remote_get_refspec$descriptor() {
        return git_remote_get_refspec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_refspec *git_remote_get_refspec(const git_remote *remote, size_t n)
     * }
     */
    public static MethodHandle git_remote_get_refspec$handle() {
        return git_remote_get_refspec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_refspec *git_remote_get_refspec(const git_remote *remote, size_t n)
     * }
     */
    public static MemorySegment git_remote_get_refspec$address() {
        return git_remote_get_refspec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_refspec *git_remote_get_refspec(const git_remote *remote, size_t n)
     * }
     */
    public static MemorySegment git_remote_get_refspec(MemorySegment remote, long n) {
        var mh$ = git_remote_get_refspec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_get_refspec", remote, n);
            }
            return (MemorySegment)mh$.invokeExact(remote, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_ls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_ls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_ls$descriptor() {
        return git_remote_ls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_ls$handle() {
        return git_remote_ls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_ls$address() {
        return git_remote_ls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)
     * }
     */
    public static int git_remote_ls(MemorySegment out, MemorySegment size, MemorySegment remote) {
        var mh$ = git_remote_ls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_ls", out, size, remote);
            }
            return (int)mh$.invokeExact(out, size, remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_connected {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_connected");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_connected(const git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_connected$descriptor() {
        return git_remote_connected.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_connected(const git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_connected$handle() {
        return git_remote_connected.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_connected(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_connected$address() {
        return git_remote_connected.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_connected(const git_remote *remote)
     * }
     */
    public static int git_remote_connected(MemorySegment remote) {
        var mh$ = git_remote_connected.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_connected", remote);
            }
            return (int)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_stop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_stop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_stop(git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_stop$descriptor() {
        return git_remote_stop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_stop(git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_stop$handle() {
        return git_remote_stop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_stop(git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_stop$address() {
        return git_remote_stop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_stop(git_remote *remote)
     * }
     */
    public static int git_remote_stop(MemorySegment remote) {
        var mh$ = git_remote_stop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_stop", remote);
            }
            return (int)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_disconnect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_disconnect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_disconnect(git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_disconnect$descriptor() {
        return git_remote_disconnect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_disconnect(git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_disconnect$handle() {
        return git_remote_disconnect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_disconnect(git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_disconnect$address() {
        return git_remote_disconnect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_disconnect(git_remote *remote)
     * }
     */
    public static int git_remote_disconnect(MemorySegment remote) {
        var mh$ = git_remote_disconnect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_disconnect", remote);
            }
            return (int)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_remote_free(git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_free$descriptor() {
        return git_remote_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_remote_free(git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_free$handle() {
        return git_remote_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_remote_free(git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_free$address() {
        return git_remote_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_remote_free(git_remote *remote)
     * }
     */
    public static void git_remote_free(MemorySegment remote) {
        var mh$ = git_remote_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_free", remote);
            }
            mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_list(git_strarray *out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_remote_list$descriptor() {
        return git_remote_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_list(git_strarray *out, git_repository *repo)
     * }
     */
    public static MethodHandle git_remote_list$handle() {
        return git_remote_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_list(git_strarray *out, git_repository *repo)
     * }
     */
    public static MemorySegment git_remote_list$address() {
        return git_remote_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_list(git_strarray *out, git_repository *repo)
     * }
     */
    public static int git_remote_list(MemorySegment out, MemorySegment repo) {
        var mh$ = git_remote_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_list", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_REMOTE_COMPLETION_DOWNLOAD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum git_remote_completion_t.GIT_REMOTE_COMPLETION_DOWNLOAD = 0
     * }
     */
    public static int GIT_REMOTE_COMPLETION_DOWNLOAD() {
        return GIT_REMOTE_COMPLETION_DOWNLOAD;
    }
    private static final int GIT_REMOTE_COMPLETION_INDEXING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum git_remote_completion_t.GIT_REMOTE_COMPLETION_INDEXING = 1
     * }
     */
    public static int GIT_REMOTE_COMPLETION_INDEXING() {
        return GIT_REMOTE_COMPLETION_INDEXING;
    }
    private static final int GIT_REMOTE_COMPLETION_ERROR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum git_remote_completion_t.GIT_REMOTE_COMPLETION_ERROR = 2
     * }
     */
    public static int GIT_REMOTE_COMPLETION_ERROR() {
        return GIT_REMOTE_COMPLETION_ERROR;
    }

    private static class git_remote_init_callbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_init_callbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_init_callbacks(git_remote_callbacks *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_remote_init_callbacks$descriptor() {
        return git_remote_init_callbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_init_callbacks(git_remote_callbacks *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_remote_init_callbacks$handle() {
        return git_remote_init_callbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_init_callbacks(git_remote_callbacks *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_remote_init_callbacks$address() {
        return git_remote_init_callbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_init_callbacks(git_remote_callbacks *opts, unsigned int version)
     * }
     */
    public static int git_remote_init_callbacks(MemorySegment opts, int version) {
        var mh$ = git_remote_init_callbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_init_callbacks", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_FETCH_PRUNE_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FETCH_PRUNE_UNSPECIFIED = 0
     * }
     */
    public static int GIT_FETCH_PRUNE_UNSPECIFIED() {
        return GIT_FETCH_PRUNE_UNSPECIFIED;
    }
    private static final int GIT_FETCH_PRUNE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FETCH_PRUNE = 1
     * }
     */
    public static int GIT_FETCH_PRUNE() {
        return GIT_FETCH_PRUNE;
    }
    private static final int GIT_FETCH_NO_PRUNE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FETCH_NO_PRUNE = 2
     * }
     */
    public static int GIT_FETCH_NO_PRUNE() {
        return GIT_FETCH_NO_PRUNE;
    }
    private static final int GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED = 0
     * }
     */
    public static int GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED() {
        return GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED;
    }
    private static final int GIT_REMOTE_DOWNLOAD_TAGS_AUTO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_DOWNLOAD_TAGS_AUTO = 1
     * }
     */
    public static int GIT_REMOTE_DOWNLOAD_TAGS_AUTO() {
        return GIT_REMOTE_DOWNLOAD_TAGS_AUTO;
    }
    private static final int GIT_REMOTE_DOWNLOAD_TAGS_NONE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_DOWNLOAD_TAGS_NONE = 2
     * }
     */
    public static int GIT_REMOTE_DOWNLOAD_TAGS_NONE() {
        return GIT_REMOTE_DOWNLOAD_TAGS_NONE;
    }
    private static final int GIT_REMOTE_DOWNLOAD_TAGS_ALL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REMOTE_DOWNLOAD_TAGS_ALL = 3
     * }
     */
    public static int GIT_REMOTE_DOWNLOAD_TAGS_ALL() {
        return GIT_REMOTE_DOWNLOAD_TAGS_ALL;
    }
    private static final int GIT_FETCH_DEPTH_FULL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FETCH_DEPTH_FULL = 0
     * }
     */
    public static int GIT_FETCH_DEPTH_FULL() {
        return GIT_FETCH_DEPTH_FULL;
    }
    private static final int GIT_FETCH_DEPTH_UNSHALLOW = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FETCH_DEPTH_UNSHALLOW = 2147483647
     * }
     */
    public static int GIT_FETCH_DEPTH_UNSHALLOW() {
        return GIT_FETCH_DEPTH_UNSHALLOW;
    }

    private static class git_fetch_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_fetch_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_fetch_options_init(git_fetch_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_fetch_options_init$descriptor() {
        return git_fetch_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_fetch_options_init(git_fetch_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_fetch_options_init$handle() {
        return git_fetch_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_fetch_options_init(git_fetch_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_fetch_options_init$address() {
        return git_fetch_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_fetch_options_init(git_fetch_options *opts, unsigned int version)
     * }
     */
    public static int git_fetch_options_init(MemorySegment opts, int version) {
        var mh$ = git_fetch_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_fetch_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_push_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_push_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_push_options_init(git_push_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_push_options_init$descriptor() {
        return git_push_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_push_options_init(git_push_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_push_options_init$handle() {
        return git_push_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_push_options_init(git_push_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_push_options_init$address() {
        return git_push_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_push_options_init(git_push_options *opts, unsigned int version)
     * }
     */
    public static int git_push_options_init(MemorySegment opts, int version) {
        var mh$ = git_push_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_push_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_connect_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_connect_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_connect_options_init(git_remote_connect_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_remote_connect_options_init$descriptor() {
        return git_remote_connect_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_connect_options_init(git_remote_connect_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_remote_connect_options_init$handle() {
        return git_remote_connect_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_connect_options_init(git_remote_connect_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_remote_connect_options_init$address() {
        return git_remote_connect_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_connect_options_init(git_remote_connect_options *opts, unsigned int version)
     * }
     */
    public static int git_remote_connect_options_init(MemorySegment opts, int version) {
        var mh$ = git_remote_connect_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_connect_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_connect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_proxy_options *proxy_opts, const git_strarray *custom_headers)
     * }
     */
    public static FunctionDescriptor git_remote_connect$descriptor() {
        return git_remote_connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_proxy_options *proxy_opts, const git_strarray *custom_headers)
     * }
     */
    public static MethodHandle git_remote_connect$handle() {
        return git_remote_connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_proxy_options *proxy_opts, const git_strarray *custom_headers)
     * }
     */
    public static MemorySegment git_remote_connect$address() {
        return git_remote_connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_connect(git_remote *remote, git_direction direction, const git_remote_callbacks *callbacks, const git_proxy_options *proxy_opts, const git_strarray *custom_headers)
     * }
     */
    public static int git_remote_connect(MemorySegment remote, int direction, MemorySegment callbacks, MemorySegment proxy_opts, MemorySegment custom_headers) {
        var mh$ = git_remote_connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_connect", remote, direction, callbacks, proxy_opts, custom_headers);
            }
            return (int)mh$.invokeExact(remote, direction, callbacks, proxy_opts, custom_headers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_connect_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_connect_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_connect_ext(git_remote *remote, git_direction direction, const git_remote_connect_options *opts)
     * }
     */
    public static FunctionDescriptor git_remote_connect_ext$descriptor() {
        return git_remote_connect_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_connect_ext(git_remote *remote, git_direction direction, const git_remote_connect_options *opts)
     * }
     */
    public static MethodHandle git_remote_connect_ext$handle() {
        return git_remote_connect_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_connect_ext(git_remote *remote, git_direction direction, const git_remote_connect_options *opts)
     * }
     */
    public static MemorySegment git_remote_connect_ext$address() {
        return git_remote_connect_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_connect_ext(git_remote *remote, git_direction direction, const git_remote_connect_options *opts)
     * }
     */
    public static int git_remote_connect_ext(MemorySegment remote, int direction, MemorySegment opts) {
        var mh$ = git_remote_connect_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_connect_ext", remote, direction, opts);
            }
            return (int)mh$.invokeExact(remote, direction, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_download {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_download");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_download(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts)
     * }
     */
    public static FunctionDescriptor git_remote_download$descriptor() {
        return git_remote_download.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_download(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts)
     * }
     */
    public static MethodHandle git_remote_download$handle() {
        return git_remote_download.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_download(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts)
     * }
     */
    public static MemorySegment git_remote_download$address() {
        return git_remote_download.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_download(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts)
     * }
     */
    public static int git_remote_download(MemorySegment remote, MemorySegment refspecs, MemorySegment opts) {
        var mh$ = git_remote_download.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_download", remote, refspecs, opts);
            }
            return (int)mh$.invokeExact(remote, refspecs, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_upload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_upload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_upload(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)
     * }
     */
    public static FunctionDescriptor git_remote_upload$descriptor() {
        return git_remote_upload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_upload(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)
     * }
     */
    public static MethodHandle git_remote_upload$handle() {
        return git_remote_upload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_upload(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)
     * }
     */
    public static MemorySegment git_remote_upload$address() {
        return git_remote_upload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_upload(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)
     * }
     */
    public static int git_remote_upload(MemorySegment remote, MemorySegment refspecs, MemorySegment opts) {
        var mh$ = git_remote_upload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_upload", remote, refspecs, opts);
            }
            return (int)mh$.invokeExact(remote, refspecs, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_update_tips {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_update_tips");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_update_tips(git_remote *remote, const git_remote_callbacks *callbacks, unsigned int update_flags, git_remote_autotag_option_t download_tags, const char *reflog_message)
     * }
     */
    public static FunctionDescriptor git_remote_update_tips$descriptor() {
        return git_remote_update_tips.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_update_tips(git_remote *remote, const git_remote_callbacks *callbacks, unsigned int update_flags, git_remote_autotag_option_t download_tags, const char *reflog_message)
     * }
     */
    public static MethodHandle git_remote_update_tips$handle() {
        return git_remote_update_tips.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_update_tips(git_remote *remote, const git_remote_callbacks *callbacks, unsigned int update_flags, git_remote_autotag_option_t download_tags, const char *reflog_message)
     * }
     */
    public static MemorySegment git_remote_update_tips$address() {
        return git_remote_update_tips.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_update_tips(git_remote *remote, const git_remote_callbacks *callbacks, unsigned int update_flags, git_remote_autotag_option_t download_tags, const char *reflog_message)
     * }
     */
    public static int git_remote_update_tips(MemorySegment remote, MemorySegment callbacks, int update_flags, int download_tags, MemorySegment reflog_message) {
        var mh$ = git_remote_update_tips.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_update_tips", remote, callbacks, update_flags, download_tags, reflog_message);
            }
            return (int)mh$.invokeExact(remote, callbacks, update_flags, download_tags, reflog_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_fetch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_fetch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_fetch(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts, const char *reflog_message)
     * }
     */
    public static FunctionDescriptor git_remote_fetch$descriptor() {
        return git_remote_fetch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_fetch(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts, const char *reflog_message)
     * }
     */
    public static MethodHandle git_remote_fetch$handle() {
        return git_remote_fetch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_fetch(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts, const char *reflog_message)
     * }
     */
    public static MemorySegment git_remote_fetch$address() {
        return git_remote_fetch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_fetch(git_remote *remote, const git_strarray *refspecs, const git_fetch_options *opts, const char *reflog_message)
     * }
     */
    public static int git_remote_fetch(MemorySegment remote, MemorySegment refspecs, MemorySegment opts, MemorySegment reflog_message) {
        var mh$ = git_remote_fetch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_fetch", remote, refspecs, opts, reflog_message);
            }
            return (int)mh$.invokeExact(remote, refspecs, opts, reflog_message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_prune {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_prune");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_prune(git_remote *remote, const git_remote_callbacks *callbacks)
     * }
     */
    public static FunctionDescriptor git_remote_prune$descriptor() {
        return git_remote_prune.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_prune(git_remote *remote, const git_remote_callbacks *callbacks)
     * }
     */
    public static MethodHandle git_remote_prune$handle() {
        return git_remote_prune.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_prune(git_remote *remote, const git_remote_callbacks *callbacks)
     * }
     */
    public static MemorySegment git_remote_prune$address() {
        return git_remote_prune.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_prune(git_remote *remote, const git_remote_callbacks *callbacks)
     * }
     */
    public static int git_remote_prune(MemorySegment remote, MemorySegment callbacks) {
        var mh$ = git_remote_prune.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_prune", remote, callbacks);
            }
            return (int)mh$.invokeExact(remote, callbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_push(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)
     * }
     */
    public static FunctionDescriptor git_remote_push$descriptor() {
        return git_remote_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_push(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)
     * }
     */
    public static MethodHandle git_remote_push$handle() {
        return git_remote_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_push(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)
     * }
     */
    public static MemorySegment git_remote_push$address() {
        return git_remote_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_push(git_remote *remote, const git_strarray *refspecs, const git_push_options *opts)
     * }
     */
    public static int git_remote_push(MemorySegment remote, MemorySegment refspecs, MemorySegment opts) {
        var mh$ = git_remote_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_push", remote, refspecs, opts);
            }
            return (int)mh$.invokeExact(remote, refspecs, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_stats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_stats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_indexer_progress *git_remote_stats(git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_stats$descriptor() {
        return git_remote_stats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_indexer_progress *git_remote_stats(git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_stats$handle() {
        return git_remote_stats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_indexer_progress *git_remote_stats(git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_stats$address() {
        return git_remote_stats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_indexer_progress *git_remote_stats(git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_stats(MemorySegment remote) {
        var mh$ = git_remote_stats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_stats", remote);
            }
            return (MemorySegment)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_autotag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_autotag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_remote_autotag_option_t git_remote_autotag(const git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_autotag$descriptor() {
        return git_remote_autotag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_remote_autotag_option_t git_remote_autotag(const git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_autotag$handle() {
        return git_remote_autotag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_remote_autotag_option_t git_remote_autotag(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_autotag$address() {
        return git_remote_autotag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_remote_autotag_option_t git_remote_autotag(const git_remote *remote)
     * }
     */
    public static int git_remote_autotag(MemorySegment remote) {
        var mh$ = git_remote_autotag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_autotag", remote);
            }
            return (int)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_set_autotag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_set_autotag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_set_autotag(git_repository *repo, const char *remote, git_remote_autotag_option_t value)
     * }
     */
    public static FunctionDescriptor git_remote_set_autotag$descriptor() {
        return git_remote_set_autotag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_set_autotag(git_repository *repo, const char *remote, git_remote_autotag_option_t value)
     * }
     */
    public static MethodHandle git_remote_set_autotag$handle() {
        return git_remote_set_autotag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_set_autotag(git_repository *repo, const char *remote, git_remote_autotag_option_t value)
     * }
     */
    public static MemorySegment git_remote_set_autotag$address() {
        return git_remote_set_autotag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_set_autotag(git_repository *repo, const char *remote, git_remote_autotag_option_t value)
     * }
     */
    public static int git_remote_set_autotag(MemorySegment repo, MemorySegment remote, int value) {
        var mh$ = git_remote_set_autotag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_set_autotag", repo, remote, value);
            }
            return (int)mh$.invokeExact(repo, remote, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_prune_refs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_prune_refs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_prune_refs(const git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_prune_refs$descriptor() {
        return git_remote_prune_refs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_prune_refs(const git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_prune_refs$handle() {
        return git_remote_prune_refs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_prune_refs(const git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_prune_refs$address() {
        return git_remote_prune_refs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_prune_refs(const git_remote *remote)
     * }
     */
    public static int git_remote_prune_refs(MemorySegment remote) {
        var mh$ = git_remote_prune_refs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_prune_refs", remote);
            }
            return (int)mh$.invokeExact(remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_rename(git_strarray *problems, git_repository *repo, const char *name, const char *new_name)
     * }
     */
    public static FunctionDescriptor git_remote_rename$descriptor() {
        return git_remote_rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_rename(git_strarray *problems, git_repository *repo, const char *name, const char *new_name)
     * }
     */
    public static MethodHandle git_remote_rename$handle() {
        return git_remote_rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_rename(git_strarray *problems, git_repository *repo, const char *name, const char *new_name)
     * }
     */
    public static MemorySegment git_remote_rename$address() {
        return git_remote_rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_rename(git_strarray *problems, git_repository *repo, const char *name, const char *new_name)
     * }
     */
    public static int git_remote_rename(MemorySegment problems, MemorySegment repo, MemorySegment name, MemorySegment new_name) {
        var mh$ = git_remote_rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_rename", problems, repo, name, new_name);
            }
            return (int)mh$.invokeExact(problems, repo, name, new_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_name_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_name_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_name_is_valid(int *valid, const char *remote_name)
     * }
     */
    public static FunctionDescriptor git_remote_name_is_valid$descriptor() {
        return git_remote_name_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_name_is_valid(int *valid, const char *remote_name)
     * }
     */
    public static MethodHandle git_remote_name_is_valid$handle() {
        return git_remote_name_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_name_is_valid(int *valid, const char *remote_name)
     * }
     */
    public static MemorySegment git_remote_name_is_valid$address() {
        return git_remote_name_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_name_is_valid(int *valid, const char *remote_name)
     * }
     */
    public static int git_remote_name_is_valid(MemorySegment valid, MemorySegment remote_name) {
        var mh$ = git_remote_name_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_name_is_valid", valid, remote_name);
            }
            return (int)mh$.invokeExact(valid, remote_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_delete(git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_remote_delete$descriptor() {
        return git_remote_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_delete(git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_remote_delete$handle() {
        return git_remote_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_delete(git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_remote_delete$address() {
        return git_remote_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_delete(git_repository *repo, const char *name)
     * }
     */
    public static int git_remote_delete(MemorySegment repo, MemorySegment name) {
        var mh$ = git_remote_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_delete", repo, name);
            }
            return (int)mh$.invokeExact(repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_default_branch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_default_branch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_default_branch(git_buf *out, git_remote *remote)
     * }
     */
    public static FunctionDescriptor git_remote_default_branch$descriptor() {
        return git_remote_default_branch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_default_branch(git_buf *out, git_remote *remote)
     * }
     */
    public static MethodHandle git_remote_default_branch$handle() {
        return git_remote_default_branch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_default_branch(git_buf *out, git_remote *remote)
     * }
     */
    public static MemorySegment git_remote_default_branch$address() {
        return git_remote_default_branch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_default_branch(git_buf *out, git_remote *remote)
     * }
     */
    public static int git_remote_default_branch(MemorySegment out, MemorySegment remote) {
        var mh$ = git_remote_default_branch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_default_branch", out, remote);
            }
            return (int)mh$.invokeExact(out, remote);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_CLONE_LOCAL_AUTO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CLONE_LOCAL_AUTO = 0
     * }
     */
    public static int GIT_CLONE_LOCAL_AUTO() {
        return GIT_CLONE_LOCAL_AUTO;
    }
    private static final int GIT_CLONE_LOCAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CLONE_LOCAL = 1
     * }
     */
    public static int GIT_CLONE_LOCAL() {
        return GIT_CLONE_LOCAL;
    }
    private static final int GIT_CLONE_NO_LOCAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CLONE_NO_LOCAL = 2
     * }
     */
    public static int GIT_CLONE_NO_LOCAL() {
        return GIT_CLONE_NO_LOCAL;
    }
    private static final int GIT_CLONE_LOCAL_NO_LINKS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CLONE_LOCAL_NO_LINKS = 3
     * }
     */
    public static int GIT_CLONE_LOCAL_NO_LINKS() {
        return GIT_CLONE_LOCAL_NO_LINKS;
    }

    private static class git_clone_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_clone_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_clone_options_init(git_clone_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_clone_options_init$descriptor() {
        return git_clone_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_clone_options_init(git_clone_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_clone_options_init$handle() {
        return git_clone_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_clone_options_init(git_clone_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_clone_options_init$address() {
        return git_clone_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_clone_options_init(git_clone_options *opts, unsigned int version)
     * }
     */
    public static int git_clone_options_init(MemorySegment opts, int version) {
        var mh$ = git_clone_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_clone_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_clone(git_repository **out, const char *url, const char *local_path, const git_clone_options *options)
     * }
     */
    public static FunctionDescriptor git_clone$descriptor() {
        return git_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_clone(git_repository **out, const char *url, const char *local_path, const git_clone_options *options)
     * }
     */
    public static MethodHandle git_clone$handle() {
        return git_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_clone(git_repository **out, const char *url, const char *local_path, const git_clone_options *options)
     * }
     */
    public static MemorySegment git_clone$address() {
        return git_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_clone(git_repository **out, const char *url, const char *local_path, const git_clone_options *options)
     * }
     */
    public static int git_clone(MemorySegment out, MemorySegment url, MemorySegment local_path, MemorySegment options) {
        var mh$ = git_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_clone", out, url, local_path, options);
            }
            return (int)mh$.invokeExact(out, url, local_path, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_CONFIG_LEVEL_PROGRAMDATA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIG_LEVEL_PROGRAMDATA = 1
     * }
     */
    public static int GIT_CONFIG_LEVEL_PROGRAMDATA() {
        return GIT_CONFIG_LEVEL_PROGRAMDATA;
    }
    private static final int GIT_CONFIG_LEVEL_SYSTEM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIG_LEVEL_SYSTEM = 2
     * }
     */
    public static int GIT_CONFIG_LEVEL_SYSTEM() {
        return GIT_CONFIG_LEVEL_SYSTEM;
    }
    private static final int GIT_CONFIG_LEVEL_XDG = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIG_LEVEL_XDG = 3
     * }
     */
    public static int GIT_CONFIG_LEVEL_XDG() {
        return GIT_CONFIG_LEVEL_XDG;
    }
    private static final int GIT_CONFIG_LEVEL_GLOBAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIG_LEVEL_GLOBAL = 4
     * }
     */
    public static int GIT_CONFIG_LEVEL_GLOBAL() {
        return GIT_CONFIG_LEVEL_GLOBAL;
    }
    private static final int GIT_CONFIG_LEVEL_LOCAL = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIG_LEVEL_LOCAL = 5
     * }
     */
    public static int GIT_CONFIG_LEVEL_LOCAL() {
        return GIT_CONFIG_LEVEL_LOCAL;
    }
    private static final int GIT_CONFIG_LEVEL_WORKTREE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIG_LEVEL_WORKTREE = 6
     * }
     */
    public static int GIT_CONFIG_LEVEL_WORKTREE() {
        return GIT_CONFIG_LEVEL_WORKTREE;
    }
    private static final int GIT_CONFIG_LEVEL_APP = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIG_LEVEL_APP = 7
     * }
     */
    public static int GIT_CONFIG_LEVEL_APP() {
        return GIT_CONFIG_LEVEL_APP;
    }
    private static final int GIT_CONFIG_HIGHEST_LEVEL = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIG_HIGHEST_LEVEL = -1
     * }
     */
    public static int GIT_CONFIG_HIGHEST_LEVEL() {
        return GIT_CONFIG_HIGHEST_LEVEL;
    }

    private static class git_config_entry_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_entry_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_config_entry_free(git_config_entry *entry)
     * }
     */
    public static FunctionDescriptor git_config_entry_free$descriptor() {
        return git_config_entry_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_config_entry_free(git_config_entry *entry)
     * }
     */
    public static MethodHandle git_config_entry_free$handle() {
        return git_config_entry_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_config_entry_free(git_config_entry *entry)
     * }
     */
    public static MemorySegment git_config_entry_free$address() {
        return git_config_entry_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_config_entry_free(git_config_entry *entry)
     * }
     */
    public static void git_config_entry_free(MemorySegment entry) {
        var mh$ = git_config_entry_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_entry_free", entry);
            }
            mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_CONFIGMAP_FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIGMAP_FALSE = 0
     * }
     */
    public static int GIT_CONFIGMAP_FALSE() {
        return GIT_CONFIGMAP_FALSE;
    }
    private static final int GIT_CONFIGMAP_TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIGMAP_TRUE = 1
     * }
     */
    public static int GIT_CONFIGMAP_TRUE() {
        return GIT_CONFIGMAP_TRUE;
    }
    private static final int GIT_CONFIGMAP_INT32 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIGMAP_INT32 = 2
     * }
     */
    public static int GIT_CONFIGMAP_INT32() {
        return GIT_CONFIGMAP_INT32;
    }
    private static final int GIT_CONFIGMAP_STRING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_CONFIGMAP_STRING = 3
     * }
     */
    public static int GIT_CONFIGMAP_STRING() {
        return GIT_CONFIGMAP_STRING;
    }

    private static class git_config_find_global {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_find_global");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_find_global(git_buf *out)
     * }
     */
    public static FunctionDescriptor git_config_find_global$descriptor() {
        return git_config_find_global.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_find_global(git_buf *out)
     * }
     */
    public static MethodHandle git_config_find_global$handle() {
        return git_config_find_global.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_find_global(git_buf *out)
     * }
     */
    public static MemorySegment git_config_find_global$address() {
        return git_config_find_global.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_find_global(git_buf *out)
     * }
     */
    public static int git_config_find_global(MemorySegment out) {
        var mh$ = git_config_find_global.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_find_global", out);
            }
            return (int)mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_find_xdg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_find_xdg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_find_xdg(git_buf *out)
     * }
     */
    public static FunctionDescriptor git_config_find_xdg$descriptor() {
        return git_config_find_xdg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_find_xdg(git_buf *out)
     * }
     */
    public static MethodHandle git_config_find_xdg$handle() {
        return git_config_find_xdg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_find_xdg(git_buf *out)
     * }
     */
    public static MemorySegment git_config_find_xdg$address() {
        return git_config_find_xdg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_find_xdg(git_buf *out)
     * }
     */
    public static int git_config_find_xdg(MemorySegment out) {
        var mh$ = git_config_find_xdg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_find_xdg", out);
            }
            return (int)mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_find_system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_find_system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_find_system(git_buf *out)
     * }
     */
    public static FunctionDescriptor git_config_find_system$descriptor() {
        return git_config_find_system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_find_system(git_buf *out)
     * }
     */
    public static MethodHandle git_config_find_system$handle() {
        return git_config_find_system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_find_system(git_buf *out)
     * }
     */
    public static MemorySegment git_config_find_system$address() {
        return git_config_find_system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_find_system(git_buf *out)
     * }
     */
    public static int git_config_find_system(MemorySegment out) {
        var mh$ = git_config_find_system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_find_system", out);
            }
            return (int)mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_find_programdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_find_programdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_find_programdata(git_buf *out)
     * }
     */
    public static FunctionDescriptor git_config_find_programdata$descriptor() {
        return git_config_find_programdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_find_programdata(git_buf *out)
     * }
     */
    public static MethodHandle git_config_find_programdata$handle() {
        return git_config_find_programdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_find_programdata(git_buf *out)
     * }
     */
    public static MemorySegment git_config_find_programdata$address() {
        return git_config_find_programdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_find_programdata(git_buf *out)
     * }
     */
    public static int git_config_find_programdata(MemorySegment out) {
        var mh$ = git_config_find_programdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_find_programdata", out);
            }
            return (int)mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_open_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_open_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_open_default(git_config **out)
     * }
     */
    public static FunctionDescriptor git_config_open_default$descriptor() {
        return git_config_open_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_open_default(git_config **out)
     * }
     */
    public static MethodHandle git_config_open_default$handle() {
        return git_config_open_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_open_default(git_config **out)
     * }
     */
    public static MemorySegment git_config_open_default$address() {
        return git_config_open_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_open_default(git_config **out)
     * }
     */
    public static int git_config_open_default(MemorySegment out) {
        var mh$ = git_config_open_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_open_default", out);
            }
            return (int)mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_new(git_config **out)
     * }
     */
    public static FunctionDescriptor git_config_new$descriptor() {
        return git_config_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_new(git_config **out)
     * }
     */
    public static MethodHandle git_config_new$handle() {
        return git_config_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_new(git_config **out)
     * }
     */
    public static MemorySegment git_config_new$address() {
        return git_config_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_new(git_config **out)
     * }
     */
    public static int git_config_new(MemorySegment out) {
        var mh$ = git_config_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_new", out);
            }
            return (int)mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_add_file_ondisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_add_file_ondisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_add_file_ondisk(git_config *cfg, const char *path, git_config_level_t level, const git_repository *repo, int force)
     * }
     */
    public static FunctionDescriptor git_config_add_file_ondisk$descriptor() {
        return git_config_add_file_ondisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_add_file_ondisk(git_config *cfg, const char *path, git_config_level_t level, const git_repository *repo, int force)
     * }
     */
    public static MethodHandle git_config_add_file_ondisk$handle() {
        return git_config_add_file_ondisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_add_file_ondisk(git_config *cfg, const char *path, git_config_level_t level, const git_repository *repo, int force)
     * }
     */
    public static MemorySegment git_config_add_file_ondisk$address() {
        return git_config_add_file_ondisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_add_file_ondisk(git_config *cfg, const char *path, git_config_level_t level, const git_repository *repo, int force)
     * }
     */
    public static int git_config_add_file_ondisk(MemorySegment cfg, MemorySegment path, int level, MemorySegment repo, int force) {
        var mh$ = git_config_add_file_ondisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_add_file_ondisk", cfg, path, level, repo, force);
            }
            return (int)mh$.invokeExact(cfg, path, level, repo, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_open_ondisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_open_ondisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_open_ondisk(git_config **out, const char *path)
     * }
     */
    public static FunctionDescriptor git_config_open_ondisk$descriptor() {
        return git_config_open_ondisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_open_ondisk(git_config **out, const char *path)
     * }
     */
    public static MethodHandle git_config_open_ondisk$handle() {
        return git_config_open_ondisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_open_ondisk(git_config **out, const char *path)
     * }
     */
    public static MemorySegment git_config_open_ondisk$address() {
        return git_config_open_ondisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_open_ondisk(git_config **out, const char *path)
     * }
     */
    public static int git_config_open_ondisk(MemorySegment out, MemorySegment path) {
        var mh$ = git_config_open_ondisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_open_ondisk", out, path);
            }
            return (int)mh$.invokeExact(out, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_open_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_open_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_open_level(git_config **out, const git_config *parent, git_config_level_t level)
     * }
     */
    public static FunctionDescriptor git_config_open_level$descriptor() {
        return git_config_open_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_open_level(git_config **out, const git_config *parent, git_config_level_t level)
     * }
     */
    public static MethodHandle git_config_open_level$handle() {
        return git_config_open_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_open_level(git_config **out, const git_config *parent, git_config_level_t level)
     * }
     */
    public static MemorySegment git_config_open_level$address() {
        return git_config_open_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_open_level(git_config **out, const git_config *parent, git_config_level_t level)
     * }
     */
    public static int git_config_open_level(MemorySegment out, MemorySegment parent, int level) {
        var mh$ = git_config_open_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_open_level", out, parent, level);
            }
            return (int)mh$.invokeExact(out, parent, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_open_global {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_open_global");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_open_global(git_config **out, git_config *config)
     * }
     */
    public static FunctionDescriptor git_config_open_global$descriptor() {
        return git_config_open_global.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_open_global(git_config **out, git_config *config)
     * }
     */
    public static MethodHandle git_config_open_global$handle() {
        return git_config_open_global.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_open_global(git_config **out, git_config *config)
     * }
     */
    public static MemorySegment git_config_open_global$address() {
        return git_config_open_global.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_open_global(git_config **out, git_config *config)
     * }
     */
    public static int git_config_open_global(MemorySegment out, MemorySegment config) {
        var mh$ = git_config_open_global.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_open_global", out, config);
            }
            return (int)mh$.invokeExact(out, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_set_writeorder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_set_writeorder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_set_writeorder(git_config *cfg, git_config_level_t *levels, size_t len)
     * }
     */
    public static FunctionDescriptor git_config_set_writeorder$descriptor() {
        return git_config_set_writeorder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_set_writeorder(git_config *cfg, git_config_level_t *levels, size_t len)
     * }
     */
    public static MethodHandle git_config_set_writeorder$handle() {
        return git_config_set_writeorder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_set_writeorder(git_config *cfg, git_config_level_t *levels, size_t len)
     * }
     */
    public static MemorySegment git_config_set_writeorder$address() {
        return git_config_set_writeorder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_set_writeorder(git_config *cfg, git_config_level_t *levels, size_t len)
     * }
     */
    public static int git_config_set_writeorder(MemorySegment cfg, MemorySegment levels, long len) {
        var mh$ = git_config_set_writeorder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_set_writeorder", cfg, levels, len);
            }
            return (int)mh$.invokeExact(cfg, levels, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_snapshot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_snapshot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_snapshot(git_config **out, git_config *config)
     * }
     */
    public static FunctionDescriptor git_config_snapshot$descriptor() {
        return git_config_snapshot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_snapshot(git_config **out, git_config *config)
     * }
     */
    public static MethodHandle git_config_snapshot$handle() {
        return git_config_snapshot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_snapshot(git_config **out, git_config *config)
     * }
     */
    public static MemorySegment git_config_snapshot$address() {
        return git_config_snapshot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_snapshot(git_config **out, git_config *config)
     * }
     */
    public static int git_config_snapshot(MemorySegment out, MemorySegment config) {
        var mh$ = git_config_snapshot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_snapshot", out, config);
            }
            return (int)mh$.invokeExact(out, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_config_free(git_config *cfg)
     * }
     */
    public static FunctionDescriptor git_config_free$descriptor() {
        return git_config_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_config_free(git_config *cfg)
     * }
     */
    public static MethodHandle git_config_free$handle() {
        return git_config_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_config_free(git_config *cfg)
     * }
     */
    public static MemorySegment git_config_free$address() {
        return git_config_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_config_free(git_config *cfg)
     * }
     */
    public static void git_config_free(MemorySegment cfg) {
        var mh$ = git_config_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_free", cfg);
            }
            mh$.invokeExact(cfg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_get_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_get_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_get_entry(git_config_entry **out, const git_config *cfg, const char *name)
     * }
     */
    public static FunctionDescriptor git_config_get_entry$descriptor() {
        return git_config_get_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_get_entry(git_config_entry **out, const git_config *cfg, const char *name)
     * }
     */
    public static MethodHandle git_config_get_entry$handle() {
        return git_config_get_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_get_entry(git_config_entry **out, const git_config *cfg, const char *name)
     * }
     */
    public static MemorySegment git_config_get_entry$address() {
        return git_config_get_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_get_entry(git_config_entry **out, const git_config *cfg, const char *name)
     * }
     */
    public static int git_config_get_entry(MemorySegment out, MemorySegment cfg, MemorySegment name) {
        var mh$ = git_config_get_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_get_entry", out, cfg, name);
            }
            return (int)mh$.invokeExact(out, cfg, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_get_int32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_get_int32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_get_int32(int32_t *out, const git_config *cfg, const char *name)
     * }
     */
    public static FunctionDescriptor git_config_get_int32$descriptor() {
        return git_config_get_int32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_get_int32(int32_t *out, const git_config *cfg, const char *name)
     * }
     */
    public static MethodHandle git_config_get_int32$handle() {
        return git_config_get_int32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_get_int32(int32_t *out, const git_config *cfg, const char *name)
     * }
     */
    public static MemorySegment git_config_get_int32$address() {
        return git_config_get_int32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_get_int32(int32_t *out, const git_config *cfg, const char *name)
     * }
     */
    public static int git_config_get_int32(MemorySegment out, MemorySegment cfg, MemorySegment name) {
        var mh$ = git_config_get_int32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_get_int32", out, cfg, name);
            }
            return (int)mh$.invokeExact(out, cfg, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_get_int64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_get_int64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_get_int64(int64_t *out, const git_config *cfg, const char *name)
     * }
     */
    public static FunctionDescriptor git_config_get_int64$descriptor() {
        return git_config_get_int64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_get_int64(int64_t *out, const git_config *cfg, const char *name)
     * }
     */
    public static MethodHandle git_config_get_int64$handle() {
        return git_config_get_int64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_get_int64(int64_t *out, const git_config *cfg, const char *name)
     * }
     */
    public static MemorySegment git_config_get_int64$address() {
        return git_config_get_int64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_get_int64(int64_t *out, const git_config *cfg, const char *name)
     * }
     */
    public static int git_config_get_int64(MemorySegment out, MemorySegment cfg, MemorySegment name) {
        var mh$ = git_config_get_int64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_get_int64", out, cfg, name);
            }
            return (int)mh$.invokeExact(out, cfg, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_get_bool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_get_bool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_get_bool(int *out, const git_config *cfg, const char *name)
     * }
     */
    public static FunctionDescriptor git_config_get_bool$descriptor() {
        return git_config_get_bool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_get_bool(int *out, const git_config *cfg, const char *name)
     * }
     */
    public static MethodHandle git_config_get_bool$handle() {
        return git_config_get_bool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_get_bool(int *out, const git_config *cfg, const char *name)
     * }
     */
    public static MemorySegment git_config_get_bool$address() {
        return git_config_get_bool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_get_bool(int *out, const git_config *cfg, const char *name)
     * }
     */
    public static int git_config_get_bool(MemorySegment out, MemorySegment cfg, MemorySegment name) {
        var mh$ = git_config_get_bool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_get_bool", out, cfg, name);
            }
            return (int)mh$.invokeExact(out, cfg, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_get_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_get_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_get_path(git_buf *out, const git_config *cfg, const char *name)
     * }
     */
    public static FunctionDescriptor git_config_get_path$descriptor() {
        return git_config_get_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_get_path(git_buf *out, const git_config *cfg, const char *name)
     * }
     */
    public static MethodHandle git_config_get_path$handle() {
        return git_config_get_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_get_path(git_buf *out, const git_config *cfg, const char *name)
     * }
     */
    public static MemorySegment git_config_get_path$address() {
        return git_config_get_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_get_path(git_buf *out, const git_config *cfg, const char *name)
     * }
     */
    public static int git_config_get_path(MemorySegment out, MemorySegment cfg, MemorySegment name) {
        var mh$ = git_config_get_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_get_path", out, cfg, name);
            }
            return (int)mh$.invokeExact(out, cfg, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_get_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_get_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_get_string(const char **out, const git_config *cfg, const char *name)
     * }
     */
    public static FunctionDescriptor git_config_get_string$descriptor() {
        return git_config_get_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_get_string(const char **out, const git_config *cfg, const char *name)
     * }
     */
    public static MethodHandle git_config_get_string$handle() {
        return git_config_get_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_get_string(const char **out, const git_config *cfg, const char *name)
     * }
     */
    public static MemorySegment git_config_get_string$address() {
        return git_config_get_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_get_string(const char **out, const git_config *cfg, const char *name)
     * }
     */
    public static int git_config_get_string(MemorySegment out, MemorySegment cfg, MemorySegment name) {
        var mh$ = git_config_get_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_get_string", out, cfg, name);
            }
            return (int)mh$.invokeExact(out, cfg, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_get_string_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_get_string_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_get_string_buf(git_buf *out, const git_config *cfg, const char *name)
     * }
     */
    public static FunctionDescriptor git_config_get_string_buf$descriptor() {
        return git_config_get_string_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_get_string_buf(git_buf *out, const git_config *cfg, const char *name)
     * }
     */
    public static MethodHandle git_config_get_string_buf$handle() {
        return git_config_get_string_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_get_string_buf(git_buf *out, const git_config *cfg, const char *name)
     * }
     */
    public static MemorySegment git_config_get_string_buf$address() {
        return git_config_get_string_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_get_string_buf(git_buf *out, const git_config *cfg, const char *name)
     * }
     */
    public static int git_config_get_string_buf(MemorySegment out, MemorySegment cfg, MemorySegment name) {
        var mh$ = git_config_get_string_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_get_string_buf", out, cfg, name);
            }
            return (int)mh$.invokeExact(out, cfg, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_get_multivar_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_get_multivar_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_get_multivar_foreach(const git_config *cfg, const char *name, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_config_get_multivar_foreach$descriptor() {
        return git_config_get_multivar_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_get_multivar_foreach(const git_config *cfg, const char *name, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_config_get_multivar_foreach$handle() {
        return git_config_get_multivar_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_get_multivar_foreach(const git_config *cfg, const char *name, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_config_get_multivar_foreach$address() {
        return git_config_get_multivar_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_get_multivar_foreach(const git_config *cfg, const char *name, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static int git_config_get_multivar_foreach(MemorySegment cfg, MemorySegment name, MemorySegment regexp, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_config_get_multivar_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_get_multivar_foreach", cfg, name, regexp, callback, payload);
            }
            return (int)mh$.invokeExact(cfg, name, regexp, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_multivar_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_multivar_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_multivar_iterator_new(git_config_iterator **out, const git_config *cfg, const char *name, const char *regexp)
     * }
     */
    public static FunctionDescriptor git_config_multivar_iterator_new$descriptor() {
        return git_config_multivar_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_multivar_iterator_new(git_config_iterator **out, const git_config *cfg, const char *name, const char *regexp)
     * }
     */
    public static MethodHandle git_config_multivar_iterator_new$handle() {
        return git_config_multivar_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_multivar_iterator_new(git_config_iterator **out, const git_config *cfg, const char *name, const char *regexp)
     * }
     */
    public static MemorySegment git_config_multivar_iterator_new$address() {
        return git_config_multivar_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_multivar_iterator_new(git_config_iterator **out, const git_config *cfg, const char *name, const char *regexp)
     * }
     */
    public static int git_config_multivar_iterator_new(MemorySegment out, MemorySegment cfg, MemorySegment name, MemorySegment regexp) {
        var mh$ = git_config_multivar_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_multivar_iterator_new", out, cfg, name, regexp);
            }
            return (int)mh$.invokeExact(out, cfg, name, regexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_next(git_config_entry **entry, git_config_iterator *iter)
     * }
     */
    public static FunctionDescriptor git_config_next$descriptor() {
        return git_config_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_next(git_config_entry **entry, git_config_iterator *iter)
     * }
     */
    public static MethodHandle git_config_next$handle() {
        return git_config_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_next(git_config_entry **entry, git_config_iterator *iter)
     * }
     */
    public static MemorySegment git_config_next$address() {
        return git_config_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_next(git_config_entry **entry, git_config_iterator *iter)
     * }
     */
    public static int git_config_next(MemorySegment entry, MemorySegment iter) {
        var mh$ = git_config_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_next", entry, iter);
            }
            return (int)mh$.invokeExact(entry, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_iterator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_iterator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_config_iterator_free(git_config_iterator *iter)
     * }
     */
    public static FunctionDescriptor git_config_iterator_free$descriptor() {
        return git_config_iterator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_config_iterator_free(git_config_iterator *iter)
     * }
     */
    public static MethodHandle git_config_iterator_free$handle() {
        return git_config_iterator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_config_iterator_free(git_config_iterator *iter)
     * }
     */
    public static MemorySegment git_config_iterator_free$address() {
        return git_config_iterator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_config_iterator_free(git_config_iterator *iter)
     * }
     */
    public static void git_config_iterator_free(MemorySegment iter) {
        var mh$ = git_config_iterator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_iterator_free", iter);
            }
            mh$.invokeExact(iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_set_int32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_set_int32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_set_int32(git_config *cfg, const char *name, int32_t value)
     * }
     */
    public static FunctionDescriptor git_config_set_int32$descriptor() {
        return git_config_set_int32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_set_int32(git_config *cfg, const char *name, int32_t value)
     * }
     */
    public static MethodHandle git_config_set_int32$handle() {
        return git_config_set_int32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_set_int32(git_config *cfg, const char *name, int32_t value)
     * }
     */
    public static MemorySegment git_config_set_int32$address() {
        return git_config_set_int32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_set_int32(git_config *cfg, const char *name, int32_t value)
     * }
     */
    public static int git_config_set_int32(MemorySegment cfg, MemorySegment name, int value) {
        var mh$ = git_config_set_int32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_set_int32", cfg, name, value);
            }
            return (int)mh$.invokeExact(cfg, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_set_int64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_set_int64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_set_int64(git_config *cfg, const char *name, int64_t value)
     * }
     */
    public static FunctionDescriptor git_config_set_int64$descriptor() {
        return git_config_set_int64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_set_int64(git_config *cfg, const char *name, int64_t value)
     * }
     */
    public static MethodHandle git_config_set_int64$handle() {
        return git_config_set_int64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_set_int64(git_config *cfg, const char *name, int64_t value)
     * }
     */
    public static MemorySegment git_config_set_int64$address() {
        return git_config_set_int64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_set_int64(git_config *cfg, const char *name, int64_t value)
     * }
     */
    public static int git_config_set_int64(MemorySegment cfg, MemorySegment name, long value) {
        var mh$ = git_config_set_int64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_set_int64", cfg, name, value);
            }
            return (int)mh$.invokeExact(cfg, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_set_bool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_set_bool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_set_bool(git_config *cfg, const char *name, int value)
     * }
     */
    public static FunctionDescriptor git_config_set_bool$descriptor() {
        return git_config_set_bool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_set_bool(git_config *cfg, const char *name, int value)
     * }
     */
    public static MethodHandle git_config_set_bool$handle() {
        return git_config_set_bool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_set_bool(git_config *cfg, const char *name, int value)
     * }
     */
    public static MemorySegment git_config_set_bool$address() {
        return git_config_set_bool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_set_bool(git_config *cfg, const char *name, int value)
     * }
     */
    public static int git_config_set_bool(MemorySegment cfg, MemorySegment name, int value) {
        var mh$ = git_config_set_bool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_set_bool", cfg, name, value);
            }
            return (int)mh$.invokeExact(cfg, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_set_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_set_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_set_string(git_config *cfg, const char *name, const char *value)
     * }
     */
    public static FunctionDescriptor git_config_set_string$descriptor() {
        return git_config_set_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_set_string(git_config *cfg, const char *name, const char *value)
     * }
     */
    public static MethodHandle git_config_set_string$handle() {
        return git_config_set_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_set_string(git_config *cfg, const char *name, const char *value)
     * }
     */
    public static MemorySegment git_config_set_string$address() {
        return git_config_set_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_set_string(git_config *cfg, const char *name, const char *value)
     * }
     */
    public static int git_config_set_string(MemorySegment cfg, MemorySegment name, MemorySegment value) {
        var mh$ = git_config_set_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_set_string", cfg, name, value);
            }
            return (int)mh$.invokeExact(cfg, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_set_multivar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_set_multivar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_set_multivar(git_config *cfg, const char *name, const char *regexp, const char *value)
     * }
     */
    public static FunctionDescriptor git_config_set_multivar$descriptor() {
        return git_config_set_multivar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_set_multivar(git_config *cfg, const char *name, const char *regexp, const char *value)
     * }
     */
    public static MethodHandle git_config_set_multivar$handle() {
        return git_config_set_multivar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_set_multivar(git_config *cfg, const char *name, const char *regexp, const char *value)
     * }
     */
    public static MemorySegment git_config_set_multivar$address() {
        return git_config_set_multivar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_set_multivar(git_config *cfg, const char *name, const char *regexp, const char *value)
     * }
     */
    public static int git_config_set_multivar(MemorySegment cfg, MemorySegment name, MemorySegment regexp, MemorySegment value) {
        var mh$ = git_config_set_multivar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_set_multivar", cfg, name, regexp, value);
            }
            return (int)mh$.invokeExact(cfg, name, regexp, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_delete_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_delete_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_delete_entry(git_config *cfg, const char *name)
     * }
     */
    public static FunctionDescriptor git_config_delete_entry$descriptor() {
        return git_config_delete_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_delete_entry(git_config *cfg, const char *name)
     * }
     */
    public static MethodHandle git_config_delete_entry$handle() {
        return git_config_delete_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_delete_entry(git_config *cfg, const char *name)
     * }
     */
    public static MemorySegment git_config_delete_entry$address() {
        return git_config_delete_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_delete_entry(git_config *cfg, const char *name)
     * }
     */
    public static int git_config_delete_entry(MemorySegment cfg, MemorySegment name) {
        var mh$ = git_config_delete_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_delete_entry", cfg, name);
            }
            return (int)mh$.invokeExact(cfg, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_delete_multivar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_delete_multivar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_delete_multivar(git_config *cfg, const char *name, const char *regexp)
     * }
     */
    public static FunctionDescriptor git_config_delete_multivar$descriptor() {
        return git_config_delete_multivar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_delete_multivar(git_config *cfg, const char *name, const char *regexp)
     * }
     */
    public static MethodHandle git_config_delete_multivar$handle() {
        return git_config_delete_multivar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_delete_multivar(git_config *cfg, const char *name, const char *regexp)
     * }
     */
    public static MemorySegment git_config_delete_multivar$address() {
        return git_config_delete_multivar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_delete_multivar(git_config *cfg, const char *name, const char *regexp)
     * }
     */
    public static int git_config_delete_multivar(MemorySegment cfg, MemorySegment name, MemorySegment regexp) {
        var mh$ = git_config_delete_multivar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_delete_multivar", cfg, name, regexp);
            }
            return (int)mh$.invokeExact(cfg, name, regexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_foreach(const git_config *cfg, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_config_foreach$descriptor() {
        return git_config_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_foreach(const git_config *cfg, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_config_foreach$handle() {
        return git_config_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_foreach(const git_config *cfg, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_config_foreach$address() {
        return git_config_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_foreach(const git_config *cfg, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static int git_config_foreach(MemorySegment cfg, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_config_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_foreach", cfg, callback, payload);
            }
            return (int)mh$.invokeExact(cfg, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_iterator_new(git_config_iterator **out, const git_config *cfg)
     * }
     */
    public static FunctionDescriptor git_config_iterator_new$descriptor() {
        return git_config_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_iterator_new(git_config_iterator **out, const git_config *cfg)
     * }
     */
    public static MethodHandle git_config_iterator_new$handle() {
        return git_config_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_iterator_new(git_config_iterator **out, const git_config *cfg)
     * }
     */
    public static MemorySegment git_config_iterator_new$address() {
        return git_config_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_iterator_new(git_config_iterator **out, const git_config *cfg)
     * }
     */
    public static int git_config_iterator_new(MemorySegment out, MemorySegment cfg) {
        var mh$ = git_config_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_iterator_new", out, cfg);
            }
            return (int)mh$.invokeExact(out, cfg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_iterator_glob_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_iterator_glob_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_iterator_glob_new(git_config_iterator **out, const git_config *cfg, const char *regexp)
     * }
     */
    public static FunctionDescriptor git_config_iterator_glob_new$descriptor() {
        return git_config_iterator_glob_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_iterator_glob_new(git_config_iterator **out, const git_config *cfg, const char *regexp)
     * }
     */
    public static MethodHandle git_config_iterator_glob_new$handle() {
        return git_config_iterator_glob_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_iterator_glob_new(git_config_iterator **out, const git_config *cfg, const char *regexp)
     * }
     */
    public static MemorySegment git_config_iterator_glob_new$address() {
        return git_config_iterator_glob_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_iterator_glob_new(git_config_iterator **out, const git_config *cfg, const char *regexp)
     * }
     */
    public static int git_config_iterator_glob_new(MemorySegment out, MemorySegment cfg, MemorySegment regexp) {
        var mh$ = git_config_iterator_glob_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_iterator_glob_new", out, cfg, regexp);
            }
            return (int)mh$.invokeExact(out, cfg, regexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_foreach_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_foreach_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_foreach_match(const git_config *cfg, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_config_foreach_match$descriptor() {
        return git_config_foreach_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_foreach_match(const git_config *cfg, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_config_foreach_match$handle() {
        return git_config_foreach_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_foreach_match(const git_config *cfg, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_config_foreach_match$address() {
        return git_config_foreach_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_foreach_match(const git_config *cfg, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static int git_config_foreach_match(MemorySegment cfg, MemorySegment regexp, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_config_foreach_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_foreach_match", cfg, regexp, callback, payload);
            }
            return (int)mh$.invokeExact(cfg, regexp, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_get_mapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_get_mapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_get_mapped(int *out, const git_config *cfg, const char *name, const git_configmap *maps, size_t map_n)
     * }
     */
    public static FunctionDescriptor git_config_get_mapped$descriptor() {
        return git_config_get_mapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_get_mapped(int *out, const git_config *cfg, const char *name, const git_configmap *maps, size_t map_n)
     * }
     */
    public static MethodHandle git_config_get_mapped$handle() {
        return git_config_get_mapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_get_mapped(int *out, const git_config *cfg, const char *name, const git_configmap *maps, size_t map_n)
     * }
     */
    public static MemorySegment git_config_get_mapped$address() {
        return git_config_get_mapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_get_mapped(int *out, const git_config *cfg, const char *name, const git_configmap *maps, size_t map_n)
     * }
     */
    public static int git_config_get_mapped(MemorySegment out, MemorySegment cfg, MemorySegment name, MemorySegment maps, long map_n) {
        var mh$ = git_config_get_mapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_get_mapped", out, cfg, name, maps, map_n);
            }
            return (int)mh$.invokeExact(out, cfg, name, maps, map_n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_lookup_map_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_lookup_map_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_lookup_map_value(int *out, const git_configmap *maps, size_t map_n, const char *value)
     * }
     */
    public static FunctionDescriptor git_config_lookup_map_value$descriptor() {
        return git_config_lookup_map_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_lookup_map_value(int *out, const git_configmap *maps, size_t map_n, const char *value)
     * }
     */
    public static MethodHandle git_config_lookup_map_value$handle() {
        return git_config_lookup_map_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_lookup_map_value(int *out, const git_configmap *maps, size_t map_n, const char *value)
     * }
     */
    public static MemorySegment git_config_lookup_map_value$address() {
        return git_config_lookup_map_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_lookup_map_value(int *out, const git_configmap *maps, size_t map_n, const char *value)
     * }
     */
    public static int git_config_lookup_map_value(MemorySegment out, MemorySegment maps, long map_n, MemorySegment value) {
        var mh$ = git_config_lookup_map_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_lookup_map_value", out, maps, map_n, value);
            }
            return (int)mh$.invokeExact(out, maps, map_n, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_parse_bool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_parse_bool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_parse_bool(int *out, const char *value)
     * }
     */
    public static FunctionDescriptor git_config_parse_bool$descriptor() {
        return git_config_parse_bool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_parse_bool(int *out, const char *value)
     * }
     */
    public static MethodHandle git_config_parse_bool$handle() {
        return git_config_parse_bool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_parse_bool(int *out, const char *value)
     * }
     */
    public static MemorySegment git_config_parse_bool$address() {
        return git_config_parse_bool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_parse_bool(int *out, const char *value)
     * }
     */
    public static int git_config_parse_bool(MemorySegment out, MemorySegment value) {
        var mh$ = git_config_parse_bool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_parse_bool", out, value);
            }
            return (int)mh$.invokeExact(out, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_parse_int32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_parse_int32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_parse_int32(int32_t *out, const char *value)
     * }
     */
    public static FunctionDescriptor git_config_parse_int32$descriptor() {
        return git_config_parse_int32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_parse_int32(int32_t *out, const char *value)
     * }
     */
    public static MethodHandle git_config_parse_int32$handle() {
        return git_config_parse_int32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_parse_int32(int32_t *out, const char *value)
     * }
     */
    public static MemorySegment git_config_parse_int32$address() {
        return git_config_parse_int32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_parse_int32(int32_t *out, const char *value)
     * }
     */
    public static int git_config_parse_int32(MemorySegment out, MemorySegment value) {
        var mh$ = git_config_parse_int32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_parse_int32", out, value);
            }
            return (int)mh$.invokeExact(out, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_parse_int64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_parse_int64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_parse_int64(int64_t *out, const char *value)
     * }
     */
    public static FunctionDescriptor git_config_parse_int64$descriptor() {
        return git_config_parse_int64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_parse_int64(int64_t *out, const char *value)
     * }
     */
    public static MethodHandle git_config_parse_int64$handle() {
        return git_config_parse_int64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_parse_int64(int64_t *out, const char *value)
     * }
     */
    public static MemorySegment git_config_parse_int64$address() {
        return git_config_parse_int64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_parse_int64(int64_t *out, const char *value)
     * }
     */
    public static int git_config_parse_int64(MemorySegment out, MemorySegment value) {
        var mh$ = git_config_parse_int64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_parse_int64", out, value);
            }
            return (int)mh$.invokeExact(out, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_parse_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_parse_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_parse_path(git_buf *out, const char *value)
     * }
     */
    public static FunctionDescriptor git_config_parse_path$descriptor() {
        return git_config_parse_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_parse_path(git_buf *out, const char *value)
     * }
     */
    public static MethodHandle git_config_parse_path$handle() {
        return git_config_parse_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_parse_path(git_buf *out, const char *value)
     * }
     */
    public static MemorySegment git_config_parse_path$address() {
        return git_config_parse_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_parse_path(git_buf *out, const char *value)
     * }
     */
    public static int git_config_parse_path(MemorySegment out, MemorySegment value) {
        var mh$ = git_config_parse_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_parse_path", out, value);
            }
            return (int)mh$.invokeExact(out, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_backend_foreach_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_backend_foreach_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_backend_foreach_match(git_config_backend *backend, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_config_backend_foreach_match$descriptor() {
        return git_config_backend_foreach_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_backend_foreach_match(git_config_backend *backend, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_config_backend_foreach_match$handle() {
        return git_config_backend_foreach_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_backend_foreach_match(git_config_backend *backend, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_config_backend_foreach_match$address() {
        return git_config_backend_foreach_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_backend_foreach_match(git_config_backend *backend, const char *regexp, git_config_foreach_cb callback, void *payload)
     * }
     */
    public static int git_config_backend_foreach_match(MemorySegment backend, MemorySegment regexp, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_config_backend_foreach_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_backend_foreach_match", backend, regexp, callback, payload);
            }
            return (int)mh$.invokeExact(backend, regexp, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_config_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_config_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_config_lock(git_transaction **tx, git_config *cfg)
     * }
     */
    public static FunctionDescriptor git_config_lock$descriptor() {
        return git_config_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_config_lock(git_transaction **tx, git_config *cfg)
     * }
     */
    public static MethodHandle git_config_lock$handle() {
        return git_config_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_config_lock(git_transaction **tx, git_config *cfg)
     * }
     */
    public static MemorySegment git_config_lock$address() {
        return git_config_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_config_lock(git_transaction **tx, git_config *cfg)
     * }
     */
    public static int git_config_lock(MemorySegment tx, MemorySegment cfg) {
        var mh$ = git_config_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_config_lock", tx, cfg);
            }
            return (int)mh$.invokeExact(tx, cfg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_DESCRIBE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DESCRIBE_DEFAULT = 0
     * }
     */
    public static int GIT_DESCRIBE_DEFAULT() {
        return GIT_DESCRIBE_DEFAULT;
    }
    private static final int GIT_DESCRIBE_TAGS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DESCRIBE_TAGS = 1
     * }
     */
    public static int GIT_DESCRIBE_TAGS() {
        return GIT_DESCRIBE_TAGS;
    }
    private static final int GIT_DESCRIBE_ALL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DESCRIBE_ALL = 2
     * }
     */
    public static int GIT_DESCRIBE_ALL() {
        return GIT_DESCRIBE_ALL;
    }

    private static class git_describe_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_describe_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_describe_options_init(git_describe_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_describe_options_init$descriptor() {
        return git_describe_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_describe_options_init(git_describe_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_describe_options_init$handle() {
        return git_describe_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_describe_options_init(git_describe_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_describe_options_init$address() {
        return git_describe_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_describe_options_init(git_describe_options *opts, unsigned int version)
     * }
     */
    public static int git_describe_options_init(MemorySegment opts, int version) {
        var mh$ = git_describe_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_describe_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_describe_format_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_describe_format_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_describe_format_options_init(git_describe_format_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_describe_format_options_init$descriptor() {
        return git_describe_format_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_describe_format_options_init(git_describe_format_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_describe_format_options_init$handle() {
        return git_describe_format_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_describe_format_options_init(git_describe_format_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_describe_format_options_init$address() {
        return git_describe_format_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_describe_format_options_init(git_describe_format_options *opts, unsigned int version)
     * }
     */
    public static int git_describe_format_options_init(MemorySegment opts, int version) {
        var mh$ = git_describe_format_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_describe_format_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_describe_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_describe_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_describe_commit(git_describe_result **result, git_object *committish, git_describe_options *opts)
     * }
     */
    public static FunctionDescriptor git_describe_commit$descriptor() {
        return git_describe_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_describe_commit(git_describe_result **result, git_object *committish, git_describe_options *opts)
     * }
     */
    public static MethodHandle git_describe_commit$handle() {
        return git_describe_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_describe_commit(git_describe_result **result, git_object *committish, git_describe_options *opts)
     * }
     */
    public static MemorySegment git_describe_commit$address() {
        return git_describe_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_describe_commit(git_describe_result **result, git_object *committish, git_describe_options *opts)
     * }
     */
    public static int git_describe_commit(MemorySegment result, MemorySegment committish, MemorySegment opts) {
        var mh$ = git_describe_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_describe_commit", result, committish, opts);
            }
            return (int)mh$.invokeExact(result, committish, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_describe_workdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_describe_workdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_describe_workdir(git_describe_result **out, git_repository *repo, git_describe_options *opts)
     * }
     */
    public static FunctionDescriptor git_describe_workdir$descriptor() {
        return git_describe_workdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_describe_workdir(git_describe_result **out, git_repository *repo, git_describe_options *opts)
     * }
     */
    public static MethodHandle git_describe_workdir$handle() {
        return git_describe_workdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_describe_workdir(git_describe_result **out, git_repository *repo, git_describe_options *opts)
     * }
     */
    public static MemorySegment git_describe_workdir$address() {
        return git_describe_workdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_describe_workdir(git_describe_result **out, git_repository *repo, git_describe_options *opts)
     * }
     */
    public static int git_describe_workdir(MemorySegment out, MemorySegment repo, MemorySegment opts) {
        var mh$ = git_describe_workdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_describe_workdir", out, repo, opts);
            }
            return (int)mh$.invokeExact(out, repo, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_describe_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_describe_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_describe_format(git_buf *out, const git_describe_result *result, const git_describe_format_options *opts)
     * }
     */
    public static FunctionDescriptor git_describe_format$descriptor() {
        return git_describe_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_describe_format(git_buf *out, const git_describe_result *result, const git_describe_format_options *opts)
     * }
     */
    public static MethodHandle git_describe_format$handle() {
        return git_describe_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_describe_format(git_buf *out, const git_describe_result *result, const git_describe_format_options *opts)
     * }
     */
    public static MemorySegment git_describe_format$address() {
        return git_describe_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_describe_format(git_buf *out, const git_describe_result *result, const git_describe_format_options *opts)
     * }
     */
    public static int git_describe_format(MemorySegment out, MemorySegment result, MemorySegment opts) {
        var mh$ = git_describe_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_describe_format", out, result, opts);
            }
            return (int)mh$.invokeExact(out, result, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_describe_result_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_describe_result_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_describe_result_free(git_describe_result *result)
     * }
     */
    public static FunctionDescriptor git_describe_result_free$descriptor() {
        return git_describe_result_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_describe_result_free(git_describe_result *result)
     * }
     */
    public static MethodHandle git_describe_result_free$handle() {
        return git_describe_result_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_describe_result_free(git_describe_result *result)
     * }
     */
    public static MemorySegment git_describe_result_free$address() {
        return git_describe_result_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_describe_result_free(git_describe_result *result)
     * }
     */
    public static void git_describe_result_free(MemorySegment result) {
        var mh$ = git_describe_result_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_describe_result_free", result);
            }
            mh$.invokeExact(result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_OK = 0
     * }
     */
    public static int GIT_OK() {
        return GIT_OK;
    }
    private static final int GIT_ERROR = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR = -1
     * }
     */
    public static int GIT_ERROR() {
        return GIT_ERROR;
    }
    private static final int GIT_ENOTFOUND = (int)-3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ENOTFOUND = -3
     * }
     */
    public static int GIT_ENOTFOUND() {
        return GIT_ENOTFOUND;
    }
    private static final int GIT_EEXISTS = (int)-4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EEXISTS = -4
     * }
     */
    public static int GIT_EEXISTS() {
        return GIT_EEXISTS;
    }
    private static final int GIT_EAMBIGUOUS = (int)-5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EAMBIGUOUS = -5
     * }
     */
    public static int GIT_EAMBIGUOUS() {
        return GIT_EAMBIGUOUS;
    }
    private static final int GIT_EBUFS = (int)-6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EBUFS = -6
     * }
     */
    public static int GIT_EBUFS() {
        return GIT_EBUFS;
    }
    private static final int GIT_EUSER = (int)-7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EUSER = -7
     * }
     */
    public static int GIT_EUSER() {
        return GIT_EUSER;
    }
    private static final int GIT_EBAREREPO = (int)-8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EBAREREPO = -8
     * }
     */
    public static int GIT_EBAREREPO() {
        return GIT_EBAREREPO;
    }
    private static final int GIT_EUNBORNBRANCH = (int)-9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EUNBORNBRANCH = -9
     * }
     */
    public static int GIT_EUNBORNBRANCH() {
        return GIT_EUNBORNBRANCH;
    }
    private static final int GIT_EUNMERGED = (int)-10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EUNMERGED = -10
     * }
     */
    public static int GIT_EUNMERGED() {
        return GIT_EUNMERGED;
    }
    private static final int GIT_ENONFASTFORWARD = (int)-11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ENONFASTFORWARD = -11
     * }
     */
    public static int GIT_ENONFASTFORWARD() {
        return GIT_ENONFASTFORWARD;
    }
    private static final int GIT_EINVALIDSPEC = (int)-12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EINVALIDSPEC = -12
     * }
     */
    public static int GIT_EINVALIDSPEC() {
        return GIT_EINVALIDSPEC;
    }
    private static final int GIT_ECONFLICT = (int)-13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ECONFLICT = -13
     * }
     */
    public static int GIT_ECONFLICT() {
        return GIT_ECONFLICT;
    }
    private static final int GIT_ELOCKED = (int)-14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ELOCKED = -14
     * }
     */
    public static int GIT_ELOCKED() {
        return GIT_ELOCKED;
    }
    private static final int GIT_EMODIFIED = (int)-15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EMODIFIED = -15
     * }
     */
    public static int GIT_EMODIFIED() {
        return GIT_EMODIFIED;
    }
    private static final int GIT_EAUTH = (int)-16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EAUTH = -16
     * }
     */
    public static int GIT_EAUTH() {
        return GIT_EAUTH;
    }
    private static final int GIT_ECERTIFICATE = (int)-17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ECERTIFICATE = -17
     * }
     */
    public static int GIT_ECERTIFICATE() {
        return GIT_ECERTIFICATE;
    }
    private static final int GIT_EAPPLIED = (int)-18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EAPPLIED = -18
     * }
     */
    public static int GIT_EAPPLIED() {
        return GIT_EAPPLIED;
    }
    private static final int GIT_EPEEL = (int)-19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EPEEL = -19
     * }
     */
    public static int GIT_EPEEL() {
        return GIT_EPEEL;
    }
    private static final int GIT_EEOF = (int)-20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EEOF = -20
     * }
     */
    public static int GIT_EEOF() {
        return GIT_EEOF;
    }
    private static final int GIT_EINVALID = (int)-21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EINVALID = -21
     * }
     */
    public static int GIT_EINVALID() {
        return GIT_EINVALID;
    }
    private static final int GIT_EUNCOMMITTED = (int)-22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EUNCOMMITTED = -22
     * }
     */
    public static int GIT_EUNCOMMITTED() {
        return GIT_EUNCOMMITTED;
    }
    private static final int GIT_EDIRECTORY = (int)-23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EDIRECTORY = -23
     * }
     */
    public static int GIT_EDIRECTORY() {
        return GIT_EDIRECTORY;
    }
    private static final int GIT_EMERGECONFLICT = (int)-24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EMERGECONFLICT = -24
     * }
     */
    public static int GIT_EMERGECONFLICT() {
        return GIT_EMERGECONFLICT;
    }
    private static final int GIT_PASSTHROUGH = (int)-30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PASSTHROUGH = -30
     * }
     */
    public static int GIT_PASSTHROUGH() {
        return GIT_PASSTHROUGH;
    }
    private static final int GIT_ITEROVER = (int)-31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ITEROVER = -31
     * }
     */
    public static int GIT_ITEROVER() {
        return GIT_ITEROVER;
    }
    private static final int GIT_RETRY = (int)-32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_RETRY = -32
     * }
     */
    public static int GIT_RETRY() {
        return GIT_RETRY;
    }
    private static final int GIT_EMISMATCH = (int)-33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EMISMATCH = -33
     * }
     */
    public static int GIT_EMISMATCH() {
        return GIT_EMISMATCH;
    }
    private static final int GIT_EINDEXDIRTY = (int)-34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EINDEXDIRTY = -34
     * }
     */
    public static int GIT_EINDEXDIRTY() {
        return GIT_EINDEXDIRTY;
    }
    private static final int GIT_EAPPLYFAIL = (int)-35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EAPPLYFAIL = -35
     * }
     */
    public static int GIT_EAPPLYFAIL() {
        return GIT_EAPPLYFAIL;
    }
    private static final int GIT_EOWNER = (int)-36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EOWNER = -36
     * }
     */
    public static int GIT_EOWNER() {
        return GIT_EOWNER;
    }
    private static final int GIT_TIMEOUT = (int)-37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TIMEOUT = -37
     * }
     */
    public static int GIT_TIMEOUT() {
        return GIT_TIMEOUT;
    }
    private static final int GIT_EUNCHANGED = (int)-38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EUNCHANGED = -38
     * }
     */
    public static int GIT_EUNCHANGED() {
        return GIT_EUNCHANGED;
    }
    private static final int GIT_ENOTSUPPORTED = (int)-39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ENOTSUPPORTED = -39
     * }
     */
    public static int GIT_ENOTSUPPORTED() {
        return GIT_ENOTSUPPORTED;
    }
    private static final int GIT_EREADONLY = (int)-40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EREADONLY = -40
     * }
     */
    public static int GIT_EREADONLY() {
        return GIT_EREADONLY;
    }
    private static final int GIT_ERROR_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_NONE = 0
     * }
     */
    public static int GIT_ERROR_NONE() {
        return GIT_ERROR_NONE;
    }
    private static final int GIT_ERROR_NOMEMORY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_NOMEMORY = 1
     * }
     */
    public static int GIT_ERROR_NOMEMORY() {
        return GIT_ERROR_NOMEMORY;
    }
    private static final int GIT_ERROR_OS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_OS = 2
     * }
     */
    public static int GIT_ERROR_OS() {
        return GIT_ERROR_OS;
    }
    private static final int GIT_ERROR_INVALID = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_INVALID = 3
     * }
     */
    public static int GIT_ERROR_INVALID() {
        return GIT_ERROR_INVALID;
    }
    private static final int GIT_ERROR_REFERENCE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_REFERENCE = 4
     * }
     */
    public static int GIT_ERROR_REFERENCE() {
        return GIT_ERROR_REFERENCE;
    }
    private static final int GIT_ERROR_ZLIB = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_ZLIB = 5
     * }
     */
    public static int GIT_ERROR_ZLIB() {
        return GIT_ERROR_ZLIB;
    }
    private static final int GIT_ERROR_REPOSITORY = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_REPOSITORY = 6
     * }
     */
    public static int GIT_ERROR_REPOSITORY() {
        return GIT_ERROR_REPOSITORY;
    }
    private static final int GIT_ERROR_CONFIG = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_CONFIG = 7
     * }
     */
    public static int GIT_ERROR_CONFIG() {
        return GIT_ERROR_CONFIG;
    }
    private static final int GIT_ERROR_REGEX = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_REGEX = 8
     * }
     */
    public static int GIT_ERROR_REGEX() {
        return GIT_ERROR_REGEX;
    }
    private static final int GIT_ERROR_ODB = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_ODB = 9
     * }
     */
    public static int GIT_ERROR_ODB() {
        return GIT_ERROR_ODB;
    }
    private static final int GIT_ERROR_INDEX = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_INDEX = 10
     * }
     */
    public static int GIT_ERROR_INDEX() {
        return GIT_ERROR_INDEX;
    }
    private static final int GIT_ERROR_OBJECT = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_OBJECT = 11
     * }
     */
    public static int GIT_ERROR_OBJECT() {
        return GIT_ERROR_OBJECT;
    }
    private static final int GIT_ERROR_NET = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_NET = 12
     * }
     */
    public static int GIT_ERROR_NET() {
        return GIT_ERROR_NET;
    }
    private static final int GIT_ERROR_TAG = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_TAG = 13
     * }
     */
    public static int GIT_ERROR_TAG() {
        return GIT_ERROR_TAG;
    }
    private static final int GIT_ERROR_TREE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_TREE = 14
     * }
     */
    public static int GIT_ERROR_TREE() {
        return GIT_ERROR_TREE;
    }
    private static final int GIT_ERROR_INDEXER = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_INDEXER = 15
     * }
     */
    public static int GIT_ERROR_INDEXER() {
        return GIT_ERROR_INDEXER;
    }
    private static final int GIT_ERROR_SSL = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_SSL = 16
     * }
     */
    public static int GIT_ERROR_SSL() {
        return GIT_ERROR_SSL;
    }
    private static final int GIT_ERROR_SUBMODULE = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_SUBMODULE = 17
     * }
     */
    public static int GIT_ERROR_SUBMODULE() {
        return GIT_ERROR_SUBMODULE;
    }
    private static final int GIT_ERROR_THREAD = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_THREAD = 18
     * }
     */
    public static int GIT_ERROR_THREAD() {
        return GIT_ERROR_THREAD;
    }
    private static final int GIT_ERROR_STASH = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_STASH = 19
     * }
     */
    public static int GIT_ERROR_STASH() {
        return GIT_ERROR_STASH;
    }
    private static final int GIT_ERROR_CHECKOUT = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_CHECKOUT = 20
     * }
     */
    public static int GIT_ERROR_CHECKOUT() {
        return GIT_ERROR_CHECKOUT;
    }
    private static final int GIT_ERROR_FETCHHEAD = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_FETCHHEAD = 21
     * }
     */
    public static int GIT_ERROR_FETCHHEAD() {
        return GIT_ERROR_FETCHHEAD;
    }
    private static final int GIT_ERROR_MERGE = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_MERGE = 22
     * }
     */
    public static int GIT_ERROR_MERGE() {
        return GIT_ERROR_MERGE;
    }
    private static final int GIT_ERROR_SSH = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_SSH = 23
     * }
     */
    public static int GIT_ERROR_SSH() {
        return GIT_ERROR_SSH;
    }
    private static final int GIT_ERROR_FILTER = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_FILTER = 24
     * }
     */
    public static int GIT_ERROR_FILTER() {
        return GIT_ERROR_FILTER;
    }
    private static final int GIT_ERROR_REVERT = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_REVERT = 25
     * }
     */
    public static int GIT_ERROR_REVERT() {
        return GIT_ERROR_REVERT;
    }
    private static final int GIT_ERROR_CALLBACK = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_CALLBACK = 26
     * }
     */
    public static int GIT_ERROR_CALLBACK() {
        return GIT_ERROR_CALLBACK;
    }
    private static final int GIT_ERROR_CHERRYPICK = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_CHERRYPICK = 27
     * }
     */
    public static int GIT_ERROR_CHERRYPICK() {
        return GIT_ERROR_CHERRYPICK;
    }
    private static final int GIT_ERROR_DESCRIBE = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_DESCRIBE = 28
     * }
     */
    public static int GIT_ERROR_DESCRIBE() {
        return GIT_ERROR_DESCRIBE;
    }
    private static final int GIT_ERROR_REBASE = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_REBASE = 29
     * }
     */
    public static int GIT_ERROR_REBASE() {
        return GIT_ERROR_REBASE;
    }
    private static final int GIT_ERROR_FILESYSTEM = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_FILESYSTEM = 30
     * }
     */
    public static int GIT_ERROR_FILESYSTEM() {
        return GIT_ERROR_FILESYSTEM;
    }
    private static final int GIT_ERROR_PATCH = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_PATCH = 31
     * }
     */
    public static int GIT_ERROR_PATCH() {
        return GIT_ERROR_PATCH;
    }
    private static final int GIT_ERROR_WORKTREE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_WORKTREE = 32
     * }
     */
    public static int GIT_ERROR_WORKTREE() {
        return GIT_ERROR_WORKTREE;
    }
    private static final int GIT_ERROR_SHA = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_SHA = 33
     * }
     */
    public static int GIT_ERROR_SHA() {
        return GIT_ERROR_SHA;
    }
    private static final int GIT_ERROR_HTTP = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_HTTP = 34
     * }
     */
    public static int GIT_ERROR_HTTP() {
        return GIT_ERROR_HTTP;
    }
    private static final int GIT_ERROR_INTERNAL = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_INTERNAL = 35
     * }
     */
    public static int GIT_ERROR_INTERNAL() {
        return GIT_ERROR_INTERNAL;
    }
    private static final int GIT_ERROR_GRAFTS = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ERROR_GRAFTS = 36
     * }
     */
    public static int GIT_ERROR_GRAFTS() {
        return GIT_ERROR_GRAFTS;
    }

    private static class git_error_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER    );

        public static final MemorySegment ADDR = git2.findOrThrow("git_error_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_error *git_error_last()
     * }
     */
    public static FunctionDescriptor git_error_last$descriptor() {
        return git_error_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_error *git_error_last()
     * }
     */
    public static MethodHandle git_error_last$handle() {
        return git_error_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_error *git_error_last()
     * }
     */
    public static MemorySegment git_error_last$address() {
        return git_error_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_error *git_error_last()
     * }
     */
    public static MemorySegment git_error_last() {
        var mh$ = git_error_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_error_last");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_FILTER_TO_WORKTREE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILTER_TO_WORKTREE = 0
     * }
     */
    public static int GIT_FILTER_TO_WORKTREE() {
        return GIT_FILTER_TO_WORKTREE;
    }
    private static final int GIT_FILTER_SMUDGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILTER_SMUDGE = 0
     * }
     */
    public static int GIT_FILTER_SMUDGE() {
        return GIT_FILTER_SMUDGE;
    }
    private static final int GIT_FILTER_TO_ODB = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILTER_TO_ODB = 1
     * }
     */
    public static int GIT_FILTER_TO_ODB() {
        return GIT_FILTER_TO_ODB;
    }
    private static final int GIT_FILTER_CLEAN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILTER_CLEAN = 1
     * }
     */
    public static int GIT_FILTER_CLEAN() {
        return GIT_FILTER_CLEAN;
    }
    private static final int GIT_FILTER_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILTER_DEFAULT = 0
     * }
     */
    public static int GIT_FILTER_DEFAULT() {
        return GIT_FILTER_DEFAULT;
    }
    private static final int GIT_FILTER_ALLOW_UNSAFE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILTER_ALLOW_UNSAFE = 1
     * }
     */
    public static int GIT_FILTER_ALLOW_UNSAFE() {
        return GIT_FILTER_ALLOW_UNSAFE;
    }
    private static final int GIT_FILTER_NO_SYSTEM_ATTRIBUTES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILTER_NO_SYSTEM_ATTRIBUTES = 2
     * }
     */
    public static int GIT_FILTER_NO_SYSTEM_ATTRIBUTES() {
        return GIT_FILTER_NO_SYSTEM_ATTRIBUTES;
    }
    private static final int GIT_FILTER_ATTRIBUTES_FROM_HEAD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILTER_ATTRIBUTES_FROM_HEAD = 4
     * }
     */
    public static int GIT_FILTER_ATTRIBUTES_FROM_HEAD() {
        return GIT_FILTER_ATTRIBUTES_FROM_HEAD;
    }
    private static final int GIT_FILTER_ATTRIBUTES_FROM_COMMIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_FILTER_ATTRIBUTES_FROM_COMMIT = 8
     * }
     */
    public static int GIT_FILTER_ATTRIBUTES_FROM_COMMIT() {
        return GIT_FILTER_ATTRIBUTES_FROM_COMMIT;
    }

    private static class git_filter_list_load {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_load");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_load(git_filter_list **filters, git_repository *repo, git_blob *blob, const char *path, git_filter_mode_t mode, uint32_t flags)
     * }
     */
    public static FunctionDescriptor git_filter_list_load$descriptor() {
        return git_filter_list_load.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_load(git_filter_list **filters, git_repository *repo, git_blob *blob, const char *path, git_filter_mode_t mode, uint32_t flags)
     * }
     */
    public static MethodHandle git_filter_list_load$handle() {
        return git_filter_list_load.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_load(git_filter_list **filters, git_repository *repo, git_blob *blob, const char *path, git_filter_mode_t mode, uint32_t flags)
     * }
     */
    public static MemorySegment git_filter_list_load$address() {
        return git_filter_list_load.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_load(git_filter_list **filters, git_repository *repo, git_blob *blob, const char *path, git_filter_mode_t mode, uint32_t flags)
     * }
     */
    public static int git_filter_list_load(MemorySegment filters, MemorySegment repo, MemorySegment blob, MemorySegment path, int mode, int flags) {
        var mh$ = git_filter_list_load.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_load", filters, repo, blob, path, mode, flags);
            }
            return (int)mh$.invokeExact(filters, repo, blob, path, mode, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_load_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_load_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_load_ext(git_filter_list **filters, git_repository *repo, git_blob *blob, const char *path, git_filter_mode_t mode, git_filter_options *opts)
     * }
     */
    public static FunctionDescriptor git_filter_list_load_ext$descriptor() {
        return git_filter_list_load_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_load_ext(git_filter_list **filters, git_repository *repo, git_blob *blob, const char *path, git_filter_mode_t mode, git_filter_options *opts)
     * }
     */
    public static MethodHandle git_filter_list_load_ext$handle() {
        return git_filter_list_load_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_load_ext(git_filter_list **filters, git_repository *repo, git_blob *blob, const char *path, git_filter_mode_t mode, git_filter_options *opts)
     * }
     */
    public static MemorySegment git_filter_list_load_ext$address() {
        return git_filter_list_load_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_load_ext(git_filter_list **filters, git_repository *repo, git_blob *blob, const char *path, git_filter_mode_t mode, git_filter_options *opts)
     * }
     */
    public static int git_filter_list_load_ext(MemorySegment filters, MemorySegment repo, MemorySegment blob, MemorySegment path, int mode, MemorySegment opts) {
        var mh$ = git_filter_list_load_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_load_ext", filters, repo, blob, path, mode, opts);
            }
            return (int)mh$.invokeExact(filters, repo, blob, path, mode, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_contains(git_filter_list *filters, const char *name)
     * }
     */
    public static FunctionDescriptor git_filter_list_contains$descriptor() {
        return git_filter_list_contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_contains(git_filter_list *filters, const char *name)
     * }
     */
    public static MethodHandle git_filter_list_contains$handle() {
        return git_filter_list_contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_contains(git_filter_list *filters, const char *name)
     * }
     */
    public static MemorySegment git_filter_list_contains$address() {
        return git_filter_list_contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_contains(git_filter_list *filters, const char *name)
     * }
     */
    public static int git_filter_list_contains(MemorySegment filters, MemorySegment name) {
        var mh$ = git_filter_list_contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_contains", filters, name);
            }
            return (int)mh$.invokeExact(filters, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_apply_to_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_apply_to_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_buffer(git_buf *out, git_filter_list *filters, const char *in, size_t in_len)
     * }
     */
    public static FunctionDescriptor git_filter_list_apply_to_buffer$descriptor() {
        return git_filter_list_apply_to_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_buffer(git_buf *out, git_filter_list *filters, const char *in, size_t in_len)
     * }
     */
    public static MethodHandle git_filter_list_apply_to_buffer$handle() {
        return git_filter_list_apply_to_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_buffer(git_buf *out, git_filter_list *filters, const char *in, size_t in_len)
     * }
     */
    public static MemorySegment git_filter_list_apply_to_buffer$address() {
        return git_filter_list_apply_to_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_buffer(git_buf *out, git_filter_list *filters, const char *in, size_t in_len)
     * }
     */
    public static int git_filter_list_apply_to_buffer(MemorySegment out, MemorySegment filters, MemorySegment in, long in_len) {
        var mh$ = git_filter_list_apply_to_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_apply_to_buffer", out, filters, in, in_len);
            }
            return (int)mh$.invokeExact(out, filters, in, in_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_apply_to_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_apply_to_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_file(git_buf *out, git_filter_list *filters, git_repository *repo, const char *path)
     * }
     */
    public static FunctionDescriptor git_filter_list_apply_to_file$descriptor() {
        return git_filter_list_apply_to_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_file(git_buf *out, git_filter_list *filters, git_repository *repo, const char *path)
     * }
     */
    public static MethodHandle git_filter_list_apply_to_file$handle() {
        return git_filter_list_apply_to_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_file(git_buf *out, git_filter_list *filters, git_repository *repo, const char *path)
     * }
     */
    public static MemorySegment git_filter_list_apply_to_file$address() {
        return git_filter_list_apply_to_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_file(git_buf *out, git_filter_list *filters, git_repository *repo, const char *path)
     * }
     */
    public static int git_filter_list_apply_to_file(MemorySegment out, MemorySegment filters, MemorySegment repo, MemorySegment path) {
        var mh$ = git_filter_list_apply_to_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_apply_to_file", out, filters, repo, path);
            }
            return (int)mh$.invokeExact(out, filters, repo, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_apply_to_blob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_apply_to_blob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_blob(git_buf *out, git_filter_list *filters, git_blob *blob)
     * }
     */
    public static FunctionDescriptor git_filter_list_apply_to_blob$descriptor() {
        return git_filter_list_apply_to_blob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_blob(git_buf *out, git_filter_list *filters, git_blob *blob)
     * }
     */
    public static MethodHandle git_filter_list_apply_to_blob$handle() {
        return git_filter_list_apply_to_blob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_blob(git_buf *out, git_filter_list *filters, git_blob *blob)
     * }
     */
    public static MemorySegment git_filter_list_apply_to_blob$address() {
        return git_filter_list_apply_to_blob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_blob(git_buf *out, git_filter_list *filters, git_blob *blob)
     * }
     */
    public static int git_filter_list_apply_to_blob(MemorySegment out, MemorySegment filters, MemorySegment blob) {
        var mh$ = git_filter_list_apply_to_blob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_apply_to_blob", out, filters, blob);
            }
            return (int)mh$.invokeExact(out, filters, blob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_stream_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_stream_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_buffer(git_filter_list *filters, const char *buffer, size_t len, git_writestream *target)
     * }
     */
    public static FunctionDescriptor git_filter_list_stream_buffer$descriptor() {
        return git_filter_list_stream_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_buffer(git_filter_list *filters, const char *buffer, size_t len, git_writestream *target)
     * }
     */
    public static MethodHandle git_filter_list_stream_buffer$handle() {
        return git_filter_list_stream_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_buffer(git_filter_list *filters, const char *buffer, size_t len, git_writestream *target)
     * }
     */
    public static MemorySegment git_filter_list_stream_buffer$address() {
        return git_filter_list_stream_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_stream_buffer(git_filter_list *filters, const char *buffer, size_t len, git_writestream *target)
     * }
     */
    public static int git_filter_list_stream_buffer(MemorySegment filters, MemorySegment buffer, long len, MemorySegment target) {
        var mh$ = git_filter_list_stream_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_stream_buffer", filters, buffer, len, target);
            }
            return (int)mh$.invokeExact(filters, buffer, len, target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_stream_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_stream_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_file(git_filter_list *filters, git_repository *repo, const char *path, git_writestream *target)
     * }
     */
    public static FunctionDescriptor git_filter_list_stream_file$descriptor() {
        return git_filter_list_stream_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_file(git_filter_list *filters, git_repository *repo, const char *path, git_writestream *target)
     * }
     */
    public static MethodHandle git_filter_list_stream_file$handle() {
        return git_filter_list_stream_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_file(git_filter_list *filters, git_repository *repo, const char *path, git_writestream *target)
     * }
     */
    public static MemorySegment git_filter_list_stream_file$address() {
        return git_filter_list_stream_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_stream_file(git_filter_list *filters, git_repository *repo, const char *path, git_writestream *target)
     * }
     */
    public static int git_filter_list_stream_file(MemorySegment filters, MemorySegment repo, MemorySegment path, MemorySegment target) {
        var mh$ = git_filter_list_stream_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_stream_file", filters, repo, path, target);
            }
            return (int)mh$.invokeExact(filters, repo, path, target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_stream_blob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_stream_blob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_blob(git_filter_list *filters, git_blob *blob, git_writestream *target)
     * }
     */
    public static FunctionDescriptor git_filter_list_stream_blob$descriptor() {
        return git_filter_list_stream_blob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_blob(git_filter_list *filters, git_blob *blob, git_writestream *target)
     * }
     */
    public static MethodHandle git_filter_list_stream_blob$handle() {
        return git_filter_list_stream_blob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_blob(git_filter_list *filters, git_blob *blob, git_writestream *target)
     * }
     */
    public static MemorySegment git_filter_list_stream_blob$address() {
        return git_filter_list_stream_blob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_stream_blob(git_filter_list *filters, git_blob *blob, git_writestream *target)
     * }
     */
    public static int git_filter_list_stream_blob(MemorySegment filters, MemorySegment blob, MemorySegment target) {
        var mh$ = git_filter_list_stream_blob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_stream_blob", filters, blob, target);
            }
            return (int)mh$.invokeExact(filters, blob, target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_filter_list_free(git_filter_list *filters)
     * }
     */
    public static FunctionDescriptor git_filter_list_free$descriptor() {
        return git_filter_list_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_filter_list_free(git_filter_list *filters)
     * }
     */
    public static MethodHandle git_filter_list_free$handle() {
        return git_filter_list_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_filter_list_free(git_filter_list *filters)
     * }
     */
    public static MemorySegment git_filter_list_free$address() {
        return git_filter_list_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_filter_list_free(git_filter_list *filters)
     * }
     */
    public static void git_filter_list_free(MemorySegment filters) {
        var mh$ = git_filter_list_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_free", filters);
            }
            mh$.invokeExact(filters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_REBASE_OPERATION_PICK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REBASE_OPERATION_PICK = 0
     * }
     */
    public static int GIT_REBASE_OPERATION_PICK() {
        return GIT_REBASE_OPERATION_PICK;
    }
    private static final int GIT_REBASE_OPERATION_REWORD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REBASE_OPERATION_REWORD = 1
     * }
     */
    public static int GIT_REBASE_OPERATION_REWORD() {
        return GIT_REBASE_OPERATION_REWORD;
    }
    private static final int GIT_REBASE_OPERATION_EDIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REBASE_OPERATION_EDIT = 2
     * }
     */
    public static int GIT_REBASE_OPERATION_EDIT() {
        return GIT_REBASE_OPERATION_EDIT;
    }
    private static final int GIT_REBASE_OPERATION_SQUASH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REBASE_OPERATION_SQUASH = 3
     * }
     */
    public static int GIT_REBASE_OPERATION_SQUASH() {
        return GIT_REBASE_OPERATION_SQUASH;
    }
    private static final int GIT_REBASE_OPERATION_FIXUP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REBASE_OPERATION_FIXUP = 4
     * }
     */
    public static int GIT_REBASE_OPERATION_FIXUP() {
        return GIT_REBASE_OPERATION_FIXUP;
    }
    private static final int GIT_REBASE_OPERATION_EXEC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REBASE_OPERATION_EXEC = 5
     * }
     */
    public static int GIT_REBASE_OPERATION_EXEC() {
        return GIT_REBASE_OPERATION_EXEC;
    }

    private static class git_rebase_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_rebase_options_init(git_rebase_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_rebase_options_init$descriptor() {
        return git_rebase_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_rebase_options_init(git_rebase_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_rebase_options_init$handle() {
        return git_rebase_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_rebase_options_init(git_rebase_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_rebase_options_init$address() {
        return git_rebase_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_rebase_options_init(git_rebase_options *opts, unsigned int version)
     * }
     */
    public static int git_rebase_options_init(MemorySegment opts, int version) {
        var mh$ = git_rebase_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_rebase_init(git_rebase **out, git_repository *repo, const git_annotated_commit *branch, const git_annotated_commit *upstream, const git_annotated_commit *onto, const git_rebase_options *opts)
     * }
     */
    public static FunctionDescriptor git_rebase_init$descriptor() {
        return git_rebase_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_rebase_init(git_rebase **out, git_repository *repo, const git_annotated_commit *branch, const git_annotated_commit *upstream, const git_annotated_commit *onto, const git_rebase_options *opts)
     * }
     */
    public static MethodHandle git_rebase_init$handle() {
        return git_rebase_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_rebase_init(git_rebase **out, git_repository *repo, const git_annotated_commit *branch, const git_annotated_commit *upstream, const git_annotated_commit *onto, const git_rebase_options *opts)
     * }
     */
    public static MemorySegment git_rebase_init$address() {
        return git_rebase_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_rebase_init(git_rebase **out, git_repository *repo, const git_annotated_commit *branch, const git_annotated_commit *upstream, const git_annotated_commit *onto, const git_rebase_options *opts)
     * }
     */
    public static int git_rebase_init(MemorySegment out, MemorySegment repo, MemorySegment branch, MemorySegment upstream, MemorySegment onto, MemorySegment opts) {
        var mh$ = git_rebase_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_init", out, repo, branch, upstream, onto, opts);
            }
            return (int)mh$.invokeExact(out, repo, branch, upstream, onto, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_rebase_open(git_rebase **out, git_repository *repo, const git_rebase_options *opts)
     * }
     */
    public static FunctionDescriptor git_rebase_open$descriptor() {
        return git_rebase_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_rebase_open(git_rebase **out, git_repository *repo, const git_rebase_options *opts)
     * }
     */
    public static MethodHandle git_rebase_open$handle() {
        return git_rebase_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_rebase_open(git_rebase **out, git_repository *repo, const git_rebase_options *opts)
     * }
     */
    public static MemorySegment git_rebase_open$address() {
        return git_rebase_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_rebase_open(git_rebase **out, git_repository *repo, const git_rebase_options *opts)
     * }
     */
    public static int git_rebase_open(MemorySegment out, MemorySegment repo, MemorySegment opts) {
        var mh$ = git_rebase_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_open", out, repo, opts);
            }
            return (int)mh$.invokeExact(out, repo, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_orig_head_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_orig_head_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_rebase_orig_head_name(git_rebase *rebase)
     * }
     */
    public static FunctionDescriptor git_rebase_orig_head_name$descriptor() {
        return git_rebase_orig_head_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_rebase_orig_head_name(git_rebase *rebase)
     * }
     */
    public static MethodHandle git_rebase_orig_head_name$handle() {
        return git_rebase_orig_head_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_rebase_orig_head_name(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_orig_head_name$address() {
        return git_rebase_orig_head_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_rebase_orig_head_name(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_orig_head_name(MemorySegment rebase) {
        var mh$ = git_rebase_orig_head_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_orig_head_name", rebase);
            }
            return (MemorySegment)mh$.invokeExact(rebase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_orig_head_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_orig_head_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_rebase_orig_head_id(git_rebase *rebase)
     * }
     */
    public static FunctionDescriptor git_rebase_orig_head_id$descriptor() {
        return git_rebase_orig_head_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_rebase_orig_head_id(git_rebase *rebase)
     * }
     */
    public static MethodHandle git_rebase_orig_head_id$handle() {
        return git_rebase_orig_head_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_rebase_orig_head_id(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_orig_head_id$address() {
        return git_rebase_orig_head_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_rebase_orig_head_id(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_orig_head_id(MemorySegment rebase) {
        var mh$ = git_rebase_orig_head_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_orig_head_id", rebase);
            }
            return (MemorySegment)mh$.invokeExact(rebase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_onto_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_onto_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_rebase_onto_name(git_rebase *rebase)
     * }
     */
    public static FunctionDescriptor git_rebase_onto_name$descriptor() {
        return git_rebase_onto_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_rebase_onto_name(git_rebase *rebase)
     * }
     */
    public static MethodHandle git_rebase_onto_name$handle() {
        return git_rebase_onto_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_rebase_onto_name(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_onto_name$address() {
        return git_rebase_onto_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_rebase_onto_name(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_onto_name(MemorySegment rebase) {
        var mh$ = git_rebase_onto_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_onto_name", rebase);
            }
            return (MemorySegment)mh$.invokeExact(rebase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_onto_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_onto_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_rebase_onto_id(git_rebase *rebase)
     * }
     */
    public static FunctionDescriptor git_rebase_onto_id$descriptor() {
        return git_rebase_onto_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_rebase_onto_id(git_rebase *rebase)
     * }
     */
    public static MethodHandle git_rebase_onto_id$handle() {
        return git_rebase_onto_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_rebase_onto_id(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_onto_id$address() {
        return git_rebase_onto_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_rebase_onto_id(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_onto_id(MemorySegment rebase) {
        var mh$ = git_rebase_onto_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_onto_id", rebase);
            }
            return (MemorySegment)mh$.invokeExact(rebase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_operation_entrycount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_operation_entrycount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_rebase_operation_entrycount(git_rebase *rebase)
     * }
     */
    public static FunctionDescriptor git_rebase_operation_entrycount$descriptor() {
        return git_rebase_operation_entrycount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_rebase_operation_entrycount(git_rebase *rebase)
     * }
     */
    public static MethodHandle git_rebase_operation_entrycount$handle() {
        return git_rebase_operation_entrycount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_rebase_operation_entrycount(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_operation_entrycount$address() {
        return git_rebase_operation_entrycount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_rebase_operation_entrycount(git_rebase *rebase)
     * }
     */
    public static long git_rebase_operation_entrycount(MemorySegment rebase) {
        var mh$ = git_rebase_operation_entrycount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_operation_entrycount", rebase);
            }
            return (long)mh$.invokeExact(rebase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_operation_current {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_operation_current");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_rebase_operation_current(git_rebase *rebase)
     * }
     */
    public static FunctionDescriptor git_rebase_operation_current$descriptor() {
        return git_rebase_operation_current.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_rebase_operation_current(git_rebase *rebase)
     * }
     */
    public static MethodHandle git_rebase_operation_current$handle() {
        return git_rebase_operation_current.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_rebase_operation_current(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_operation_current$address() {
        return git_rebase_operation_current.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_rebase_operation_current(git_rebase *rebase)
     * }
     */
    public static long git_rebase_operation_current(MemorySegment rebase) {
        var mh$ = git_rebase_operation_current.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_operation_current", rebase);
            }
            return (long)mh$.invokeExact(rebase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_operation_byindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_operation_byindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_rebase_operation *git_rebase_operation_byindex(git_rebase *rebase, size_t idx)
     * }
     */
    public static FunctionDescriptor git_rebase_operation_byindex$descriptor() {
        return git_rebase_operation_byindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_rebase_operation *git_rebase_operation_byindex(git_rebase *rebase, size_t idx)
     * }
     */
    public static MethodHandle git_rebase_operation_byindex$handle() {
        return git_rebase_operation_byindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_rebase_operation *git_rebase_operation_byindex(git_rebase *rebase, size_t idx)
     * }
     */
    public static MemorySegment git_rebase_operation_byindex$address() {
        return git_rebase_operation_byindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_rebase_operation *git_rebase_operation_byindex(git_rebase *rebase, size_t idx)
     * }
     */
    public static MemorySegment git_rebase_operation_byindex(MemorySegment rebase, long idx) {
        var mh$ = git_rebase_operation_byindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_operation_byindex", rebase, idx);
            }
            return (MemorySegment)mh$.invokeExact(rebase, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_rebase_next(git_rebase_operation **operation, git_rebase *rebase)
     * }
     */
    public static FunctionDescriptor git_rebase_next$descriptor() {
        return git_rebase_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_rebase_next(git_rebase_operation **operation, git_rebase *rebase)
     * }
     */
    public static MethodHandle git_rebase_next$handle() {
        return git_rebase_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_rebase_next(git_rebase_operation **operation, git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_next$address() {
        return git_rebase_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_rebase_next(git_rebase_operation **operation, git_rebase *rebase)
     * }
     */
    public static int git_rebase_next(MemorySegment operation, MemorySegment rebase) {
        var mh$ = git_rebase_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_next", operation, rebase);
            }
            return (int)mh$.invokeExact(operation, rebase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_inmemory_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_inmemory_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_rebase_inmemory_index(git_index **index, git_rebase *rebase)
     * }
     */
    public static FunctionDescriptor git_rebase_inmemory_index$descriptor() {
        return git_rebase_inmemory_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_rebase_inmemory_index(git_index **index, git_rebase *rebase)
     * }
     */
    public static MethodHandle git_rebase_inmemory_index$handle() {
        return git_rebase_inmemory_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_rebase_inmemory_index(git_index **index, git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_inmemory_index$address() {
        return git_rebase_inmemory_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_rebase_inmemory_index(git_index **index, git_rebase *rebase)
     * }
     */
    public static int git_rebase_inmemory_index(MemorySegment index, MemorySegment rebase) {
        var mh$ = git_rebase_inmemory_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_inmemory_index", index, rebase);
            }
            return (int)mh$.invokeExact(index, rebase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_rebase_commit(git_oid *id, git_rebase *rebase, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message)
     * }
     */
    public static FunctionDescriptor git_rebase_commit$descriptor() {
        return git_rebase_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_rebase_commit(git_oid *id, git_rebase *rebase, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message)
     * }
     */
    public static MethodHandle git_rebase_commit$handle() {
        return git_rebase_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_rebase_commit(git_oid *id, git_rebase *rebase, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message)
     * }
     */
    public static MemorySegment git_rebase_commit$address() {
        return git_rebase_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_rebase_commit(git_oid *id, git_rebase *rebase, const git_signature *author, const git_signature *committer, const char *message_encoding, const char *message)
     * }
     */
    public static int git_rebase_commit(MemorySegment id, MemorySegment rebase, MemorySegment author, MemorySegment committer, MemorySegment message_encoding, MemorySegment message) {
        var mh$ = git_rebase_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_commit", id, rebase, author, committer, message_encoding, message);
            }
            return (int)mh$.invokeExact(id, rebase, author, committer, message_encoding, message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_rebase_abort(git_rebase *rebase)
     * }
     */
    public static FunctionDescriptor git_rebase_abort$descriptor() {
        return git_rebase_abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_rebase_abort(git_rebase *rebase)
     * }
     */
    public static MethodHandle git_rebase_abort$handle() {
        return git_rebase_abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_rebase_abort(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_abort$address() {
        return git_rebase_abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_rebase_abort(git_rebase *rebase)
     * }
     */
    public static int git_rebase_abort(MemorySegment rebase) {
        var mh$ = git_rebase_abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_abort", rebase);
            }
            return (int)mh$.invokeExact(rebase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_rebase_finish(git_rebase *rebase, const git_signature *signature)
     * }
     */
    public static FunctionDescriptor git_rebase_finish$descriptor() {
        return git_rebase_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_rebase_finish(git_rebase *rebase, const git_signature *signature)
     * }
     */
    public static MethodHandle git_rebase_finish$handle() {
        return git_rebase_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_rebase_finish(git_rebase *rebase, const git_signature *signature)
     * }
     */
    public static MemorySegment git_rebase_finish$address() {
        return git_rebase_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_rebase_finish(git_rebase *rebase, const git_signature *signature)
     * }
     */
    public static int git_rebase_finish(MemorySegment rebase, MemorySegment signature) {
        var mh$ = git_rebase_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_finish", rebase, signature);
            }
            return (int)mh$.invokeExact(rebase, signature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_rebase_free(git_rebase *rebase)
     * }
     */
    public static FunctionDescriptor git_rebase_free$descriptor() {
        return git_rebase_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_rebase_free(git_rebase *rebase)
     * }
     */
    public static MethodHandle git_rebase_free$handle() {
        return git_rebase_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_rebase_free(git_rebase *rebase)
     * }
     */
    public static MemorySegment git_rebase_free$address() {
        return git_rebase_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_rebase_free(git_rebase *rebase)
     * }
     */
    public static void git_rebase_free(MemorySegment rebase) {
        var mh$ = git_rebase_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_free", rebase);
            }
            mh$.invokeExact(rebase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_TRACE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TRACE_NONE = 0
     * }
     */
    public static int GIT_TRACE_NONE() {
        return GIT_TRACE_NONE;
    }
    private static final int GIT_TRACE_FATAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TRACE_FATAL = 1
     * }
     */
    public static int GIT_TRACE_FATAL() {
        return GIT_TRACE_FATAL;
    }
    private static final int GIT_TRACE_ERROR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TRACE_ERROR = 2
     * }
     */
    public static int GIT_TRACE_ERROR() {
        return GIT_TRACE_ERROR;
    }
    private static final int GIT_TRACE_WARN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TRACE_WARN = 3
     * }
     */
    public static int GIT_TRACE_WARN() {
        return GIT_TRACE_WARN;
    }
    private static final int GIT_TRACE_INFO = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TRACE_INFO = 4
     * }
     */
    public static int GIT_TRACE_INFO() {
        return GIT_TRACE_INFO;
    }
    private static final int GIT_TRACE_DEBUG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TRACE_DEBUG = 5
     * }
     */
    public static int GIT_TRACE_DEBUG() {
        return GIT_TRACE_DEBUG;
    }
    private static final int GIT_TRACE_TRACE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_TRACE_TRACE = 6
     * }
     */
    public static int GIT_TRACE_TRACE() {
        return GIT_TRACE_TRACE;
    }

    private static class git_trace_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_trace_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_trace_set(git_trace_level_t level, git_trace_cb cb)
     * }
     */
    public static FunctionDescriptor git_trace_set$descriptor() {
        return git_trace_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_trace_set(git_trace_level_t level, git_trace_cb cb)
     * }
     */
    public static MethodHandle git_trace_set$handle() {
        return git_trace_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_trace_set(git_trace_level_t level, git_trace_cb cb)
     * }
     */
    public static MemorySegment git_trace_set$address() {
        return git_trace_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_trace_set(git_trace_level_t level, git_trace_cb cb)
     * }
     */
    public static int git_trace_set(int level, MemorySegment cb) {
        var mh$ = git_trace_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_trace_set", level, cb);
            }
            return (int)mh$.invokeExact(level, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revert_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revert_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revert_options_init(git_revert_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_revert_options_init$descriptor() {
        return git_revert_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revert_options_init(git_revert_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_revert_options_init$handle() {
        return git_revert_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revert_options_init(git_revert_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_revert_options_init$address() {
        return git_revert_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revert_options_init(git_revert_options *opts, unsigned int version)
     * }
     */
    public static int git_revert_options_init(MemorySegment opts, int version) {
        var mh$ = git_revert_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revert_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revert_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revert_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revert_commit(git_index **out, git_repository *repo, git_commit *revert_commit, git_commit *our_commit, unsigned int mainline, const git_merge_options *merge_options)
     * }
     */
    public static FunctionDescriptor git_revert_commit$descriptor() {
        return git_revert_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revert_commit(git_index **out, git_repository *repo, git_commit *revert_commit, git_commit *our_commit, unsigned int mainline, const git_merge_options *merge_options)
     * }
     */
    public static MethodHandle git_revert_commit$handle() {
        return git_revert_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revert_commit(git_index **out, git_repository *repo, git_commit *revert_commit, git_commit *our_commit, unsigned int mainline, const git_merge_options *merge_options)
     * }
     */
    public static MemorySegment git_revert_commit$address() {
        return git_revert_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revert_commit(git_index **out, git_repository *repo, git_commit *revert_commit, git_commit *our_commit, unsigned int mainline, const git_merge_options *merge_options)
     * }
     */
    public static int git_revert_commit(MemorySegment out, MemorySegment repo, MemorySegment revert_commit, MemorySegment our_commit, int mainline, MemorySegment merge_options) {
        var mh$ = git_revert_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revert_commit", out, repo, revert_commit, our_commit, mainline, merge_options);
            }
            return (int)mh$.invokeExact(out, repo, revert_commit, our_commit, mainline, merge_options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revert(git_repository *repo, git_commit *commit, const git_revert_options *given_opts)
     * }
     */
    public static FunctionDescriptor git_revert$descriptor() {
        return git_revert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revert(git_repository *repo, git_commit *commit, const git_revert_options *given_opts)
     * }
     */
    public static MethodHandle git_revert$handle() {
        return git_revert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revert(git_repository *repo, git_commit *commit, const git_revert_options *given_opts)
     * }
     */
    public static MemorySegment git_revert$address() {
        return git_revert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revert(git_repository *repo, git_commit *commit, const git_revert_options *given_opts)
     * }
     */
    public static int git_revert(MemorySegment repo, MemorySegment commit, MemorySegment given_opts) {
        var mh$ = git_revert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revert", repo, commit, given_opts);
            }
            return (int)mh$.invokeExact(repo, commit, given_opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revparse_single {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revparse_single");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revparse_single(git_object **out, git_repository *repo, const char *spec)
     * }
     */
    public static FunctionDescriptor git_revparse_single$descriptor() {
        return git_revparse_single.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revparse_single(git_object **out, git_repository *repo, const char *spec)
     * }
     */
    public static MethodHandle git_revparse_single$handle() {
        return git_revparse_single.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revparse_single(git_object **out, git_repository *repo, const char *spec)
     * }
     */
    public static MemorySegment git_revparse_single$address() {
        return git_revparse_single.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revparse_single(git_object **out, git_repository *repo, const char *spec)
     * }
     */
    public static int git_revparse_single(MemorySegment out, MemorySegment repo, MemorySegment spec) {
        var mh$ = git_revparse_single.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revparse_single", out, repo, spec);
            }
            return (int)mh$.invokeExact(out, repo, spec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revparse_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revparse_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revparse_ext(git_object **object_out, git_reference **reference_out, git_repository *repo, const char *spec)
     * }
     */
    public static FunctionDescriptor git_revparse_ext$descriptor() {
        return git_revparse_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revparse_ext(git_object **object_out, git_reference **reference_out, git_repository *repo, const char *spec)
     * }
     */
    public static MethodHandle git_revparse_ext$handle() {
        return git_revparse_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revparse_ext(git_object **object_out, git_reference **reference_out, git_repository *repo, const char *spec)
     * }
     */
    public static MemorySegment git_revparse_ext$address() {
        return git_revparse_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revparse_ext(git_object **object_out, git_reference **reference_out, git_repository *repo, const char *spec)
     * }
     */
    public static int git_revparse_ext(MemorySegment object_out, MemorySegment reference_out, MemorySegment repo, MemorySegment spec) {
        var mh$ = git_revparse_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revparse_ext", object_out, reference_out, repo, spec);
            }
            return (int)mh$.invokeExact(object_out, reference_out, repo, spec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_REVSPEC_SINGLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REVSPEC_SINGLE = 1
     * }
     */
    public static int GIT_REVSPEC_SINGLE() {
        return GIT_REVSPEC_SINGLE;
    }
    private static final int GIT_REVSPEC_RANGE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REVSPEC_RANGE = 2
     * }
     */
    public static int GIT_REVSPEC_RANGE() {
        return GIT_REVSPEC_RANGE;
    }
    private static final int GIT_REVSPEC_MERGE_BASE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_REVSPEC_MERGE_BASE = 4
     * }
     */
    public static int GIT_REVSPEC_MERGE_BASE() {
        return GIT_REVSPEC_MERGE_BASE;
    }

    private static class git_revparse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revparse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revparse(git_revspec *revspec, git_repository *repo, const char *spec)
     * }
     */
    public static FunctionDescriptor git_revparse$descriptor() {
        return git_revparse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revparse(git_revspec *revspec, git_repository *repo, const char *spec)
     * }
     */
    public static MethodHandle git_revparse$handle() {
        return git_revparse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revparse(git_revspec *revspec, git_repository *repo, const char *spec)
     * }
     */
    public static MemorySegment git_revparse$address() {
        return git_revparse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revparse(git_revspec *revspec, git_repository *repo, const char *spec)
     * }
     */
    public static int git_revparse(MemorySegment revspec, MemorySegment repo, MemorySegment spec) {
        var mh$ = git_revparse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revparse", revspec, repo, spec);
            }
            return (int)mh$.invokeExact(revspec, repo, spec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_STASH_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_DEFAULT = 0
     * }
     */
    public static int GIT_STASH_DEFAULT() {
        return GIT_STASH_DEFAULT;
    }
    private static final int GIT_STASH_KEEP_INDEX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_KEEP_INDEX = 1
     * }
     */
    public static int GIT_STASH_KEEP_INDEX() {
        return GIT_STASH_KEEP_INDEX;
    }
    private static final int GIT_STASH_INCLUDE_UNTRACKED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_INCLUDE_UNTRACKED = 2
     * }
     */
    public static int GIT_STASH_INCLUDE_UNTRACKED() {
        return GIT_STASH_INCLUDE_UNTRACKED;
    }
    private static final int GIT_STASH_INCLUDE_IGNORED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_INCLUDE_IGNORED = 4
     * }
     */
    public static int GIT_STASH_INCLUDE_IGNORED() {
        return GIT_STASH_INCLUDE_IGNORED;
    }
    private static final int GIT_STASH_KEEP_ALL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_KEEP_ALL = 8
     * }
     */
    public static int GIT_STASH_KEEP_ALL() {
        return GIT_STASH_KEEP_ALL;
    }

    private static class git_stash_save {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_stash_save");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_stash_save(git_oid *out, git_repository *repo, const git_signature *stasher, const char *message, uint32_t flags)
     * }
     */
    public static FunctionDescriptor git_stash_save$descriptor() {
        return git_stash_save.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_stash_save(git_oid *out, git_repository *repo, const git_signature *stasher, const char *message, uint32_t flags)
     * }
     */
    public static MethodHandle git_stash_save$handle() {
        return git_stash_save.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_stash_save(git_oid *out, git_repository *repo, const git_signature *stasher, const char *message, uint32_t flags)
     * }
     */
    public static MemorySegment git_stash_save$address() {
        return git_stash_save.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_stash_save(git_oid *out, git_repository *repo, const git_signature *stasher, const char *message, uint32_t flags)
     * }
     */
    public static int git_stash_save(MemorySegment out, MemorySegment repo, MemorySegment stasher, MemorySegment message, int flags) {
        var mh$ = git_stash_save.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_stash_save", out, repo, stasher, message, flags);
            }
            return (int)mh$.invokeExact(out, repo, stasher, message, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_stash_save_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_stash_save_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_stash_save_options_init(git_stash_save_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_stash_save_options_init$descriptor() {
        return git_stash_save_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_stash_save_options_init(git_stash_save_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_stash_save_options_init$handle() {
        return git_stash_save_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_stash_save_options_init(git_stash_save_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_stash_save_options_init$address() {
        return git_stash_save_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_stash_save_options_init(git_stash_save_options *opts, unsigned int version)
     * }
     */
    public static int git_stash_save_options_init(MemorySegment opts, int version) {
        var mh$ = git_stash_save_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_stash_save_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_stash_save_with_opts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_stash_save_with_opts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_stash_save_with_opts(git_oid *out, git_repository *repo, const git_stash_save_options *opts)
     * }
     */
    public static FunctionDescriptor git_stash_save_with_opts$descriptor() {
        return git_stash_save_with_opts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_stash_save_with_opts(git_oid *out, git_repository *repo, const git_stash_save_options *opts)
     * }
     */
    public static MethodHandle git_stash_save_with_opts$handle() {
        return git_stash_save_with_opts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_stash_save_with_opts(git_oid *out, git_repository *repo, const git_stash_save_options *opts)
     * }
     */
    public static MemorySegment git_stash_save_with_opts$address() {
        return git_stash_save_with_opts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_stash_save_with_opts(git_oid *out, git_repository *repo, const git_stash_save_options *opts)
     * }
     */
    public static int git_stash_save_with_opts(MemorySegment out, MemorySegment repo, MemorySegment opts) {
        var mh$ = git_stash_save_with_opts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_stash_save_with_opts", out, repo, opts);
            }
            return (int)mh$.invokeExact(out, repo, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_STASH_APPLY_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_APPLY_DEFAULT = 0
     * }
     */
    public static int GIT_STASH_APPLY_DEFAULT() {
        return GIT_STASH_APPLY_DEFAULT;
    }
    private static final int GIT_STASH_APPLY_REINSTATE_INDEX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_APPLY_REINSTATE_INDEX = 1
     * }
     */
    public static int GIT_STASH_APPLY_REINSTATE_INDEX() {
        return GIT_STASH_APPLY_REINSTATE_INDEX;
    }
    private static final int GIT_STASH_APPLY_PROGRESS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_APPLY_PROGRESS_NONE = 0
     * }
     */
    public static int GIT_STASH_APPLY_PROGRESS_NONE() {
        return GIT_STASH_APPLY_PROGRESS_NONE;
    }
    private static final int GIT_STASH_APPLY_PROGRESS_LOADING_STASH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_APPLY_PROGRESS_LOADING_STASH = 1
     * }
     */
    public static int GIT_STASH_APPLY_PROGRESS_LOADING_STASH() {
        return GIT_STASH_APPLY_PROGRESS_LOADING_STASH;
    }
    private static final int GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX = 2
     * }
     */
    public static int GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX() {
        return GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX;
    }
    private static final int GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED = 3
     * }
     */
    public static int GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED() {
        return GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED;
    }
    private static final int GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED = 4
     * }
     */
    public static int GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED() {
        return GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED;
    }
    private static final int GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED = 5
     * }
     */
    public static int GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED() {
        return GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED;
    }
    private static final int GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED = 6
     * }
     */
    public static int GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED() {
        return GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED;
    }
    private static final int GIT_STASH_APPLY_PROGRESS_DONE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STASH_APPLY_PROGRESS_DONE = 7
     * }
     */
    public static int GIT_STASH_APPLY_PROGRESS_DONE() {
        return GIT_STASH_APPLY_PROGRESS_DONE;
    }

    private static class git_stash_apply_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_stash_apply_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_stash_apply_options_init(git_stash_apply_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_stash_apply_options_init$descriptor() {
        return git_stash_apply_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_stash_apply_options_init(git_stash_apply_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_stash_apply_options_init$handle() {
        return git_stash_apply_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_stash_apply_options_init(git_stash_apply_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_stash_apply_options_init$address() {
        return git_stash_apply_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_stash_apply_options_init(git_stash_apply_options *opts, unsigned int version)
     * }
     */
    public static int git_stash_apply_options_init(MemorySegment opts, int version) {
        var mh$ = git_stash_apply_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_stash_apply_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_stash_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_stash_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_stash_apply(git_repository *repo, size_t index, const git_stash_apply_options *options)
     * }
     */
    public static FunctionDescriptor git_stash_apply$descriptor() {
        return git_stash_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_stash_apply(git_repository *repo, size_t index, const git_stash_apply_options *options)
     * }
     */
    public static MethodHandle git_stash_apply$handle() {
        return git_stash_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_stash_apply(git_repository *repo, size_t index, const git_stash_apply_options *options)
     * }
     */
    public static MemorySegment git_stash_apply$address() {
        return git_stash_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_stash_apply(git_repository *repo, size_t index, const git_stash_apply_options *options)
     * }
     */
    public static int git_stash_apply(MemorySegment repo, long index, MemorySegment options) {
        var mh$ = git_stash_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_stash_apply", repo, index, options);
            }
            return (int)mh$.invokeExact(repo, index, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_stash_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_stash_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_stash_foreach(git_repository *repo, git_stash_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_stash_foreach$descriptor() {
        return git_stash_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_stash_foreach(git_repository *repo, git_stash_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_stash_foreach$handle() {
        return git_stash_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_stash_foreach(git_repository *repo, git_stash_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_stash_foreach$address() {
        return git_stash_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_stash_foreach(git_repository *repo, git_stash_cb callback, void *payload)
     * }
     */
    public static int git_stash_foreach(MemorySegment repo, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_stash_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_stash_foreach", repo, callback, payload);
            }
            return (int)mh$.invokeExact(repo, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_stash_drop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_stash_drop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_stash_drop(git_repository *repo, size_t index)
     * }
     */
    public static FunctionDescriptor git_stash_drop$descriptor() {
        return git_stash_drop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_stash_drop(git_repository *repo, size_t index)
     * }
     */
    public static MethodHandle git_stash_drop$handle() {
        return git_stash_drop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_stash_drop(git_repository *repo, size_t index)
     * }
     */
    public static MemorySegment git_stash_drop$address() {
        return git_stash_drop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_stash_drop(git_repository *repo, size_t index)
     * }
     */
    public static int git_stash_drop(MemorySegment repo, long index) {
        var mh$ = git_stash_drop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_stash_drop", repo, index);
            }
            return (int)mh$.invokeExact(repo, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_stash_pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_stash_pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_stash_pop(git_repository *repo, size_t index, const git_stash_apply_options *options)
     * }
     */
    public static FunctionDescriptor git_stash_pop$descriptor() {
        return git_stash_pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_stash_pop(git_repository *repo, size_t index, const git_stash_apply_options *options)
     * }
     */
    public static MethodHandle git_stash_pop$handle() {
        return git_stash_pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_stash_pop(git_repository *repo, size_t index, const git_stash_apply_options *options)
     * }
     */
    public static MemorySegment git_stash_pop$address() {
        return git_stash_pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_stash_pop(git_repository *repo, size_t index, const git_stash_apply_options *options)
     * }
     */
    public static int git_stash_pop(MemorySegment repo, long index, MemorySegment options) {
        var mh$ = git_stash_pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_stash_pop", repo, index, options);
            }
            return (int)mh$.invokeExact(repo, index, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_STATUS_CURRENT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_CURRENT = 0
     * }
     */
    public static int GIT_STATUS_CURRENT() {
        return GIT_STATUS_CURRENT;
    }
    private static final int GIT_STATUS_INDEX_NEW = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_INDEX_NEW = 1
     * }
     */
    public static int GIT_STATUS_INDEX_NEW() {
        return GIT_STATUS_INDEX_NEW;
    }
    private static final int GIT_STATUS_INDEX_MODIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_INDEX_MODIFIED = 2
     * }
     */
    public static int GIT_STATUS_INDEX_MODIFIED() {
        return GIT_STATUS_INDEX_MODIFIED;
    }
    private static final int GIT_STATUS_INDEX_DELETED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_INDEX_DELETED = 4
     * }
     */
    public static int GIT_STATUS_INDEX_DELETED() {
        return GIT_STATUS_INDEX_DELETED;
    }
    private static final int GIT_STATUS_INDEX_RENAMED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_INDEX_RENAMED = 8
     * }
     */
    public static int GIT_STATUS_INDEX_RENAMED() {
        return GIT_STATUS_INDEX_RENAMED;
    }
    private static final int GIT_STATUS_INDEX_TYPECHANGE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_INDEX_TYPECHANGE = 16
     * }
     */
    public static int GIT_STATUS_INDEX_TYPECHANGE() {
        return GIT_STATUS_INDEX_TYPECHANGE;
    }
    private static final int GIT_STATUS_WT_NEW = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_WT_NEW = 128
     * }
     */
    public static int GIT_STATUS_WT_NEW() {
        return GIT_STATUS_WT_NEW;
    }
    private static final int GIT_STATUS_WT_MODIFIED = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_WT_MODIFIED = 256
     * }
     */
    public static int GIT_STATUS_WT_MODIFIED() {
        return GIT_STATUS_WT_MODIFIED;
    }
    private static final int GIT_STATUS_WT_DELETED = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_WT_DELETED = 512
     * }
     */
    public static int GIT_STATUS_WT_DELETED() {
        return GIT_STATUS_WT_DELETED;
    }
    private static final int GIT_STATUS_WT_TYPECHANGE = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_WT_TYPECHANGE = 1024
     * }
     */
    public static int GIT_STATUS_WT_TYPECHANGE() {
        return GIT_STATUS_WT_TYPECHANGE;
    }
    private static final int GIT_STATUS_WT_RENAMED = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_WT_RENAMED = 2048
     * }
     */
    public static int GIT_STATUS_WT_RENAMED() {
        return GIT_STATUS_WT_RENAMED;
    }
    private static final int GIT_STATUS_WT_UNREADABLE = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_WT_UNREADABLE = 4096
     * }
     */
    public static int GIT_STATUS_WT_UNREADABLE() {
        return GIT_STATUS_WT_UNREADABLE;
    }
    private static final int GIT_STATUS_IGNORED = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_IGNORED = 16384
     * }
     */
    public static int GIT_STATUS_IGNORED() {
        return GIT_STATUS_IGNORED;
    }
    private static final int GIT_STATUS_CONFLICTED = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_CONFLICTED = 32768
     * }
     */
    public static int GIT_STATUS_CONFLICTED() {
        return GIT_STATUS_CONFLICTED;
    }
    private static final int GIT_STATUS_SHOW_INDEX_AND_WORKDIR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_SHOW_INDEX_AND_WORKDIR = 0
     * }
     */
    public static int GIT_STATUS_SHOW_INDEX_AND_WORKDIR() {
        return GIT_STATUS_SHOW_INDEX_AND_WORKDIR;
    }
    private static final int GIT_STATUS_SHOW_INDEX_ONLY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_SHOW_INDEX_ONLY = 1
     * }
     */
    public static int GIT_STATUS_SHOW_INDEX_ONLY() {
        return GIT_STATUS_SHOW_INDEX_ONLY;
    }
    private static final int GIT_STATUS_SHOW_WORKDIR_ONLY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_SHOW_WORKDIR_ONLY = 2
     * }
     */
    public static int GIT_STATUS_SHOW_WORKDIR_ONLY() {
        return GIT_STATUS_SHOW_WORKDIR_ONLY;
    }
    private static final int GIT_STATUS_OPT_INCLUDE_UNTRACKED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_INCLUDE_UNTRACKED = 1
     * }
     */
    public static int GIT_STATUS_OPT_INCLUDE_UNTRACKED() {
        return GIT_STATUS_OPT_INCLUDE_UNTRACKED;
    }
    private static final int GIT_STATUS_OPT_INCLUDE_IGNORED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_INCLUDE_IGNORED = 2
     * }
     */
    public static int GIT_STATUS_OPT_INCLUDE_IGNORED() {
        return GIT_STATUS_OPT_INCLUDE_IGNORED;
    }
    private static final int GIT_STATUS_OPT_INCLUDE_UNMODIFIED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_INCLUDE_UNMODIFIED = 4
     * }
     */
    public static int GIT_STATUS_OPT_INCLUDE_UNMODIFIED() {
        return GIT_STATUS_OPT_INCLUDE_UNMODIFIED;
    }
    private static final int GIT_STATUS_OPT_EXCLUDE_SUBMODULES = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_EXCLUDE_SUBMODULES = 8
     * }
     */
    public static int GIT_STATUS_OPT_EXCLUDE_SUBMODULES() {
        return GIT_STATUS_OPT_EXCLUDE_SUBMODULES;
    }
    private static final int GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS = 16
     * }
     */
    public static int GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS() {
        return GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS;
    }
    private static final int GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH = 32
     * }
     */
    public static int GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH() {
        return GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH;
    }
    private static final int GIT_STATUS_OPT_RECURSE_IGNORED_DIRS = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_RECURSE_IGNORED_DIRS = 64
     * }
     */
    public static int GIT_STATUS_OPT_RECURSE_IGNORED_DIRS() {
        return GIT_STATUS_OPT_RECURSE_IGNORED_DIRS;
    }
    private static final int GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX = 128
     * }
     */
    public static int GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX() {
        return GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX;
    }
    private static final int GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR = 256
     * }
     */
    public static int GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR() {
        return GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR;
    }
    private static final int GIT_STATUS_OPT_SORT_CASE_SENSITIVELY = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_SORT_CASE_SENSITIVELY = 512
     * }
     */
    public static int GIT_STATUS_OPT_SORT_CASE_SENSITIVELY() {
        return GIT_STATUS_OPT_SORT_CASE_SENSITIVELY;
    }
    private static final int GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY = 1024
     * }
     */
    public static int GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY() {
        return GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY;
    }
    private static final int GIT_STATUS_OPT_RENAMES_FROM_REWRITES = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_RENAMES_FROM_REWRITES = 2048
     * }
     */
    public static int GIT_STATUS_OPT_RENAMES_FROM_REWRITES() {
        return GIT_STATUS_OPT_RENAMES_FROM_REWRITES;
    }
    private static final int GIT_STATUS_OPT_NO_REFRESH = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_NO_REFRESH = 4096
     * }
     */
    public static int GIT_STATUS_OPT_NO_REFRESH() {
        return GIT_STATUS_OPT_NO_REFRESH;
    }
    private static final int GIT_STATUS_OPT_UPDATE_INDEX = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_UPDATE_INDEX = 8192
     * }
     */
    public static int GIT_STATUS_OPT_UPDATE_INDEX() {
        return GIT_STATUS_OPT_UPDATE_INDEX;
    }
    private static final int GIT_STATUS_OPT_INCLUDE_UNREADABLE = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_INCLUDE_UNREADABLE = 16384
     * }
     */
    public static int GIT_STATUS_OPT_INCLUDE_UNREADABLE() {
        return GIT_STATUS_OPT_INCLUDE_UNREADABLE;
    }
    private static final int GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED = 32768
     * }
     */
    public static int GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED() {
        return GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED;
    }

    private static class git_status_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_status_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_status_options_init(git_status_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_status_options_init$descriptor() {
        return git_status_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_status_options_init(git_status_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_status_options_init$handle() {
        return git_status_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_status_options_init(git_status_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_status_options_init$address() {
        return git_status_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_status_options_init(git_status_options *opts, unsigned int version)
     * }
     */
    public static int git_status_options_init(MemorySegment opts, int version) {
        var mh$ = git_status_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_status_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_status_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_status_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_status_foreach(git_repository *repo, git_status_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_status_foreach$descriptor() {
        return git_status_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_status_foreach(git_repository *repo, git_status_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_status_foreach$handle() {
        return git_status_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_status_foreach(git_repository *repo, git_status_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_status_foreach$address() {
        return git_status_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_status_foreach(git_repository *repo, git_status_cb callback, void *payload)
     * }
     */
    public static int git_status_foreach(MemorySegment repo, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_status_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_status_foreach", repo, callback, payload);
            }
            return (int)mh$.invokeExact(repo, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_status_foreach_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_status_foreach_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_status_foreach_ext(git_repository *repo, const git_status_options *opts, git_status_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_status_foreach_ext$descriptor() {
        return git_status_foreach_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_status_foreach_ext(git_repository *repo, const git_status_options *opts, git_status_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_status_foreach_ext$handle() {
        return git_status_foreach_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_status_foreach_ext(git_repository *repo, const git_status_options *opts, git_status_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_status_foreach_ext$address() {
        return git_status_foreach_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_status_foreach_ext(git_repository *repo, const git_status_options *opts, git_status_cb callback, void *payload)
     * }
     */
    public static int git_status_foreach_ext(MemorySegment repo, MemorySegment opts, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_status_foreach_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_status_foreach_ext", repo, opts, callback, payload);
            }
            return (int)mh$.invokeExact(repo, opts, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_status_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_status_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_status_file(unsigned int *status_flags, git_repository *repo, const char *path)
     * }
     */
    public static FunctionDescriptor git_status_file$descriptor() {
        return git_status_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_status_file(unsigned int *status_flags, git_repository *repo, const char *path)
     * }
     */
    public static MethodHandle git_status_file$handle() {
        return git_status_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_status_file(unsigned int *status_flags, git_repository *repo, const char *path)
     * }
     */
    public static MemorySegment git_status_file$address() {
        return git_status_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_status_file(unsigned int *status_flags, git_repository *repo, const char *path)
     * }
     */
    public static int git_status_file(MemorySegment status_flags, MemorySegment repo, MemorySegment path) {
        var mh$ = git_status_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_status_file", status_flags, repo, path);
            }
            return (int)mh$.invokeExact(status_flags, repo, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_status_list_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_status_list_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_status_list_new(git_status_list **out, git_repository *repo, const git_status_options *opts)
     * }
     */
    public static FunctionDescriptor git_status_list_new$descriptor() {
        return git_status_list_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_status_list_new(git_status_list **out, git_repository *repo, const git_status_options *opts)
     * }
     */
    public static MethodHandle git_status_list_new$handle() {
        return git_status_list_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_status_list_new(git_status_list **out, git_repository *repo, const git_status_options *opts)
     * }
     */
    public static MemorySegment git_status_list_new$address() {
        return git_status_list_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_status_list_new(git_status_list **out, git_repository *repo, const git_status_options *opts)
     * }
     */
    public static int git_status_list_new(MemorySegment out, MemorySegment repo, MemorySegment opts) {
        var mh$ = git_status_list_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_status_list_new", out, repo, opts);
            }
            return (int)mh$.invokeExact(out, repo, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_status_list_entrycount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_status_list_entrycount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_status_list_entrycount(git_status_list *statuslist)
     * }
     */
    public static FunctionDescriptor git_status_list_entrycount$descriptor() {
        return git_status_list_entrycount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_status_list_entrycount(git_status_list *statuslist)
     * }
     */
    public static MethodHandle git_status_list_entrycount$handle() {
        return git_status_list_entrycount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_status_list_entrycount(git_status_list *statuslist)
     * }
     */
    public static MemorySegment git_status_list_entrycount$address() {
        return git_status_list_entrycount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_status_list_entrycount(git_status_list *statuslist)
     * }
     */
    public static long git_status_list_entrycount(MemorySegment statuslist) {
        var mh$ = git_status_list_entrycount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_status_list_entrycount", statuslist);
            }
            return (long)mh$.invokeExact(statuslist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_status_byindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_status_byindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_status_entry *git_status_byindex(git_status_list *statuslist, size_t idx)
     * }
     */
    public static FunctionDescriptor git_status_byindex$descriptor() {
        return git_status_byindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_status_entry *git_status_byindex(git_status_list *statuslist, size_t idx)
     * }
     */
    public static MethodHandle git_status_byindex$handle() {
        return git_status_byindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_status_entry *git_status_byindex(git_status_list *statuslist, size_t idx)
     * }
     */
    public static MemorySegment git_status_byindex$address() {
        return git_status_byindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_status_entry *git_status_byindex(git_status_list *statuslist, size_t idx)
     * }
     */
    public static MemorySegment git_status_byindex(MemorySegment statuslist, long idx) {
        var mh$ = git_status_byindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_status_byindex", statuslist, idx);
            }
            return (MemorySegment)mh$.invokeExact(statuslist, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_status_list_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_status_list_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_status_list_free(git_status_list *statuslist)
     * }
     */
    public static FunctionDescriptor git_status_list_free$descriptor() {
        return git_status_list_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_status_list_free(git_status_list *statuslist)
     * }
     */
    public static MethodHandle git_status_list_free$handle() {
        return git_status_list_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_status_list_free(git_status_list *statuslist)
     * }
     */
    public static MemorySegment git_status_list_free$address() {
        return git_status_list_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_status_list_free(git_status_list *statuslist)
     * }
     */
    public static void git_status_list_free(MemorySegment statuslist) {
        var mh$ = git_status_list_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_status_list_free", statuslist);
            }
            mh$.invokeExact(statuslist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_status_should_ignore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_status_should_ignore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_status_should_ignore(int *ignored, git_repository *repo, const char *path)
     * }
     */
    public static FunctionDescriptor git_status_should_ignore$descriptor() {
        return git_status_should_ignore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_status_should_ignore(int *ignored, git_repository *repo, const char *path)
     * }
     */
    public static MethodHandle git_status_should_ignore$handle() {
        return git_status_should_ignore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_status_should_ignore(int *ignored, git_repository *repo, const char *path)
     * }
     */
    public static MemorySegment git_status_should_ignore$address() {
        return git_status_should_ignore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_status_should_ignore(int *ignored, git_repository *repo, const char *path)
     * }
     */
    public static int git_status_should_ignore(MemorySegment ignored, MemorySegment repo, MemorySegment path) {
        var mh$ = git_status_should_ignore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_status_should_ignore", ignored, repo, path);
            }
            return (int)mh$.invokeExact(ignored, repo, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_SUBMODULE_STATUS_IN_HEAD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_IN_HEAD = 1
     * }
     */
    public static int GIT_SUBMODULE_STATUS_IN_HEAD() {
        return GIT_SUBMODULE_STATUS_IN_HEAD;
    }
    private static final int GIT_SUBMODULE_STATUS_IN_INDEX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_IN_INDEX = 2
     * }
     */
    public static int GIT_SUBMODULE_STATUS_IN_INDEX() {
        return GIT_SUBMODULE_STATUS_IN_INDEX;
    }
    private static final int GIT_SUBMODULE_STATUS_IN_CONFIG = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_IN_CONFIG = 4
     * }
     */
    public static int GIT_SUBMODULE_STATUS_IN_CONFIG() {
        return GIT_SUBMODULE_STATUS_IN_CONFIG;
    }
    private static final int GIT_SUBMODULE_STATUS_IN_WD = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_IN_WD = 8
     * }
     */
    public static int GIT_SUBMODULE_STATUS_IN_WD() {
        return GIT_SUBMODULE_STATUS_IN_WD;
    }
    private static final int GIT_SUBMODULE_STATUS_INDEX_ADDED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_INDEX_ADDED = 16
     * }
     */
    public static int GIT_SUBMODULE_STATUS_INDEX_ADDED() {
        return GIT_SUBMODULE_STATUS_INDEX_ADDED;
    }
    private static final int GIT_SUBMODULE_STATUS_INDEX_DELETED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_INDEX_DELETED = 32
     * }
     */
    public static int GIT_SUBMODULE_STATUS_INDEX_DELETED() {
        return GIT_SUBMODULE_STATUS_INDEX_DELETED;
    }
    private static final int GIT_SUBMODULE_STATUS_INDEX_MODIFIED = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_INDEX_MODIFIED = 64
     * }
     */
    public static int GIT_SUBMODULE_STATUS_INDEX_MODIFIED() {
        return GIT_SUBMODULE_STATUS_INDEX_MODIFIED;
    }
    private static final int GIT_SUBMODULE_STATUS_WD_UNINITIALIZED = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_WD_UNINITIALIZED = 128
     * }
     */
    public static int GIT_SUBMODULE_STATUS_WD_UNINITIALIZED() {
        return GIT_SUBMODULE_STATUS_WD_UNINITIALIZED;
    }
    private static final int GIT_SUBMODULE_STATUS_WD_ADDED = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_WD_ADDED = 256
     * }
     */
    public static int GIT_SUBMODULE_STATUS_WD_ADDED() {
        return GIT_SUBMODULE_STATUS_WD_ADDED;
    }
    private static final int GIT_SUBMODULE_STATUS_WD_DELETED = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_WD_DELETED = 512
     * }
     */
    public static int GIT_SUBMODULE_STATUS_WD_DELETED() {
        return GIT_SUBMODULE_STATUS_WD_DELETED;
    }
    private static final int GIT_SUBMODULE_STATUS_WD_MODIFIED = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_WD_MODIFIED = 1024
     * }
     */
    public static int GIT_SUBMODULE_STATUS_WD_MODIFIED() {
        return GIT_SUBMODULE_STATUS_WD_MODIFIED;
    }
    private static final int GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED = 2048
     * }
     */
    public static int GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED() {
        return GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED;
    }
    private static final int GIT_SUBMODULE_STATUS_WD_WD_MODIFIED = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_WD_WD_MODIFIED = 4096
     * }
     */
    public static int GIT_SUBMODULE_STATUS_WD_WD_MODIFIED() {
        return GIT_SUBMODULE_STATUS_WD_WD_MODIFIED;
    }
    private static final int GIT_SUBMODULE_STATUS_WD_UNTRACKED = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SUBMODULE_STATUS_WD_UNTRACKED = 8192
     * }
     */
    public static int GIT_SUBMODULE_STATUS_WD_UNTRACKED() {
        return GIT_SUBMODULE_STATUS_WD_UNTRACKED;
    }

    private static class git_submodule_update_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_update_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_update_options_init(git_submodule_update_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_submodule_update_options_init$descriptor() {
        return git_submodule_update_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_update_options_init(git_submodule_update_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_submodule_update_options_init$handle() {
        return git_submodule_update_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_update_options_init(git_submodule_update_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_submodule_update_options_init$address() {
        return git_submodule_update_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_update_options_init(git_submodule_update_options *opts, unsigned int version)
     * }
     */
    public static int git_submodule_update_options_init(MemorySegment opts, int version) {
        var mh$ = git_submodule_update_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_update_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_update(git_submodule *submodule, int init, git_submodule_update_options *options)
     * }
     */
    public static FunctionDescriptor git_submodule_update$descriptor() {
        return git_submodule_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_update(git_submodule *submodule, int init, git_submodule_update_options *options)
     * }
     */
    public static MethodHandle git_submodule_update$handle() {
        return git_submodule_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_update(git_submodule *submodule, int init, git_submodule_update_options *options)
     * }
     */
    public static MemorySegment git_submodule_update$address() {
        return git_submodule_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_update(git_submodule *submodule, int init, git_submodule_update_options *options)
     * }
     */
    public static int git_submodule_update(MemorySegment submodule, int init, MemorySegment options) {
        var mh$ = git_submodule_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_update", submodule, init, options);
            }
            return (int)mh$.invokeExact(submodule, init, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_lookup(git_submodule **out, git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_submodule_lookup$descriptor() {
        return git_submodule_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_lookup(git_submodule **out, git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_submodule_lookup$handle() {
        return git_submodule_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_lookup(git_submodule **out, git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_submodule_lookup$address() {
        return git_submodule_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_lookup(git_submodule **out, git_repository *repo, const char *name)
     * }
     */
    public static int git_submodule_lookup(MemorySegment out, MemorySegment repo, MemorySegment name) {
        var mh$ = git_submodule_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_lookup", out, repo, name);
            }
            return (int)mh$.invokeExact(out, repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_dup(git_submodule **out, git_submodule *source)
     * }
     */
    public static FunctionDescriptor git_submodule_dup$descriptor() {
        return git_submodule_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_dup(git_submodule **out, git_submodule *source)
     * }
     */
    public static MethodHandle git_submodule_dup$handle() {
        return git_submodule_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_dup(git_submodule **out, git_submodule *source)
     * }
     */
    public static MemorySegment git_submodule_dup$address() {
        return git_submodule_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_dup(git_submodule **out, git_submodule *source)
     * }
     */
    public static int git_submodule_dup(MemorySegment out, MemorySegment source) {
        var mh$ = git_submodule_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_dup", out, source);
            }
            return (int)mh$.invokeExact(out, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_submodule_free(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_free$descriptor() {
        return git_submodule_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_submodule_free(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_free$handle() {
        return git_submodule_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_submodule_free(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_free$address() {
        return git_submodule_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_submodule_free(git_submodule *submodule)
     * }
     */
    public static void git_submodule_free(MemorySegment submodule) {
        var mh$ = git_submodule_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_free", submodule);
            }
            mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_foreach(git_repository *repo, git_submodule_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_submodule_foreach$descriptor() {
        return git_submodule_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_foreach(git_repository *repo, git_submodule_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_submodule_foreach$handle() {
        return git_submodule_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_foreach(git_repository *repo, git_submodule_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_submodule_foreach$address() {
        return git_submodule_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_foreach(git_repository *repo, git_submodule_cb callback, void *payload)
     * }
     */
    public static int git_submodule_foreach(MemorySegment repo, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_submodule_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_foreach", repo, callback, payload);
            }
            return (int)mh$.invokeExact(repo, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_add_setup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_add_setup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_add_setup(git_submodule **out, git_repository *repo, const char *url, const char *path, int use_gitlink)
     * }
     */
    public static FunctionDescriptor git_submodule_add_setup$descriptor() {
        return git_submodule_add_setup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_add_setup(git_submodule **out, git_repository *repo, const char *url, const char *path, int use_gitlink)
     * }
     */
    public static MethodHandle git_submodule_add_setup$handle() {
        return git_submodule_add_setup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_add_setup(git_submodule **out, git_repository *repo, const char *url, const char *path, int use_gitlink)
     * }
     */
    public static MemorySegment git_submodule_add_setup$address() {
        return git_submodule_add_setup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_add_setup(git_submodule **out, git_repository *repo, const char *url, const char *path, int use_gitlink)
     * }
     */
    public static int git_submodule_add_setup(MemorySegment out, MemorySegment repo, MemorySegment url, MemorySegment path, int use_gitlink) {
        var mh$ = git_submodule_add_setup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_add_setup", out, repo, url, path, use_gitlink);
            }
            return (int)mh$.invokeExact(out, repo, url, path, use_gitlink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_clone(git_repository **out, git_submodule *submodule, const git_submodule_update_options *opts)
     * }
     */
    public static FunctionDescriptor git_submodule_clone$descriptor() {
        return git_submodule_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_clone(git_repository **out, git_submodule *submodule, const git_submodule_update_options *opts)
     * }
     */
    public static MethodHandle git_submodule_clone$handle() {
        return git_submodule_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_clone(git_repository **out, git_submodule *submodule, const git_submodule_update_options *opts)
     * }
     */
    public static MemorySegment git_submodule_clone$address() {
        return git_submodule_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_clone(git_repository **out, git_submodule *submodule, const git_submodule_update_options *opts)
     * }
     */
    public static int git_submodule_clone(MemorySegment out, MemorySegment submodule, MemorySegment opts) {
        var mh$ = git_submodule_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_clone", out, submodule, opts);
            }
            return (int)mh$.invokeExact(out, submodule, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_add_finalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_add_finalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_add_finalize(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_add_finalize$descriptor() {
        return git_submodule_add_finalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_add_finalize(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_add_finalize$handle() {
        return git_submodule_add_finalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_add_finalize(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_add_finalize$address() {
        return git_submodule_add_finalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_add_finalize(git_submodule *submodule)
     * }
     */
    public static int git_submodule_add_finalize(MemorySegment submodule) {
        var mh$ = git_submodule_add_finalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_add_finalize", submodule);
            }
            return (int)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_add_to_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_add_to_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_add_to_index(git_submodule *submodule, int write_index)
     * }
     */
    public static FunctionDescriptor git_submodule_add_to_index$descriptor() {
        return git_submodule_add_to_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_add_to_index(git_submodule *submodule, int write_index)
     * }
     */
    public static MethodHandle git_submodule_add_to_index$handle() {
        return git_submodule_add_to_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_add_to_index(git_submodule *submodule, int write_index)
     * }
     */
    public static MemorySegment git_submodule_add_to_index$address() {
        return git_submodule_add_to_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_add_to_index(git_submodule *submodule, int write_index)
     * }
     */
    public static int git_submodule_add_to_index(MemorySegment submodule, int write_index) {
        var mh$ = git_submodule_add_to_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_add_to_index", submodule, write_index);
            }
            return (int)mh$.invokeExact(submodule, write_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_submodule_owner(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_owner$descriptor() {
        return git_submodule_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_submodule_owner(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_owner$handle() {
        return git_submodule_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_submodule_owner(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_owner$address() {
        return git_submodule_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_submodule_owner(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_owner(MemorySegment submodule) {
        var mh$ = git_submodule_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_owner", submodule);
            }
            return (MemorySegment)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_submodule_name(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_name$descriptor() {
        return git_submodule_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_submodule_name(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_name$handle() {
        return git_submodule_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_submodule_name(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_name$address() {
        return git_submodule_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_submodule_name(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_name(MemorySegment submodule) {
        var mh$ = git_submodule_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_name", submodule);
            }
            return (MemorySegment)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_submodule_path(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_path$descriptor() {
        return git_submodule_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_submodule_path(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_path$handle() {
        return git_submodule_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_submodule_path(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_path$address() {
        return git_submodule_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_submodule_path(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_path(MemorySegment submodule) {
        var mh$ = git_submodule_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_path", submodule);
            }
            return (MemorySegment)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_url {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_url");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_submodule_url(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_url$descriptor() {
        return git_submodule_url.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_submodule_url(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_url$handle() {
        return git_submodule_url.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_submodule_url(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_url$address() {
        return git_submodule_url.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_submodule_url(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_url(MemorySegment submodule) {
        var mh$ = git_submodule_url.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_url", submodule);
            }
            return (MemorySegment)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_resolve_url {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_resolve_url");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_resolve_url(git_buf *out, git_repository *repo, const char *url)
     * }
     */
    public static FunctionDescriptor git_submodule_resolve_url$descriptor() {
        return git_submodule_resolve_url.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_resolve_url(git_buf *out, git_repository *repo, const char *url)
     * }
     */
    public static MethodHandle git_submodule_resolve_url$handle() {
        return git_submodule_resolve_url.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_resolve_url(git_buf *out, git_repository *repo, const char *url)
     * }
     */
    public static MemorySegment git_submodule_resolve_url$address() {
        return git_submodule_resolve_url.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_resolve_url(git_buf *out, git_repository *repo, const char *url)
     * }
     */
    public static int git_submodule_resolve_url(MemorySegment out, MemorySegment repo, MemorySegment url) {
        var mh$ = git_submodule_resolve_url.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_resolve_url", out, repo, url);
            }
            return (int)mh$.invokeExact(out, repo, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_branch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_branch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_submodule_branch(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_branch$descriptor() {
        return git_submodule_branch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_submodule_branch(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_branch$handle() {
        return git_submodule_branch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_submodule_branch(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_branch$address() {
        return git_submodule_branch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_submodule_branch(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_branch(MemorySegment submodule) {
        var mh$ = git_submodule_branch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_branch", submodule);
            }
            return (MemorySegment)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_set_branch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_set_branch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_set_branch(git_repository *repo, const char *name, const char *branch)
     * }
     */
    public static FunctionDescriptor git_submodule_set_branch$descriptor() {
        return git_submodule_set_branch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_set_branch(git_repository *repo, const char *name, const char *branch)
     * }
     */
    public static MethodHandle git_submodule_set_branch$handle() {
        return git_submodule_set_branch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_set_branch(git_repository *repo, const char *name, const char *branch)
     * }
     */
    public static MemorySegment git_submodule_set_branch$address() {
        return git_submodule_set_branch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_set_branch(git_repository *repo, const char *name, const char *branch)
     * }
     */
    public static int git_submodule_set_branch(MemorySegment repo, MemorySegment name, MemorySegment branch) {
        var mh$ = git_submodule_set_branch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_set_branch", repo, name, branch);
            }
            return (int)mh$.invokeExact(repo, name, branch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_set_url {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_set_url");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_set_url(git_repository *repo, const char *name, const char *url)
     * }
     */
    public static FunctionDescriptor git_submodule_set_url$descriptor() {
        return git_submodule_set_url.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_set_url(git_repository *repo, const char *name, const char *url)
     * }
     */
    public static MethodHandle git_submodule_set_url$handle() {
        return git_submodule_set_url.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_set_url(git_repository *repo, const char *name, const char *url)
     * }
     */
    public static MemorySegment git_submodule_set_url$address() {
        return git_submodule_set_url.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_set_url(git_repository *repo, const char *name, const char *url)
     * }
     */
    public static int git_submodule_set_url(MemorySegment repo, MemorySegment name, MemorySegment url) {
        var mh$ = git_submodule_set_url.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_set_url", repo, name, url);
            }
            return (int)mh$.invokeExact(repo, name, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_index_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_index_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_index_id(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_index_id$descriptor() {
        return git_submodule_index_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_index_id(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_index_id$handle() {
        return git_submodule_index_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_index_id(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_index_id$address() {
        return git_submodule_index_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_index_id(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_index_id(MemorySegment submodule) {
        var mh$ = git_submodule_index_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_index_id", submodule);
            }
            return (MemorySegment)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_head_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_head_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_head_id(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_head_id$descriptor() {
        return git_submodule_head_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_head_id(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_head_id$handle() {
        return git_submodule_head_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_head_id(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_head_id$address() {
        return git_submodule_head_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_head_id(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_head_id(MemorySegment submodule) {
        var mh$ = git_submodule_head_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_head_id", submodule);
            }
            return (MemorySegment)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_wd_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_wd_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_wd_id(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_wd_id$descriptor() {
        return git_submodule_wd_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_wd_id(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_wd_id$handle() {
        return git_submodule_wd_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_wd_id(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_wd_id$address() {
        return git_submodule_wd_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_submodule_wd_id(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_wd_id(MemorySegment submodule) {
        var mh$ = git_submodule_wd_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_wd_id", submodule);
            }
            return (MemorySegment)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_ignore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_ignore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_submodule_ignore_t git_submodule_ignore(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_ignore$descriptor() {
        return git_submodule_ignore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_submodule_ignore_t git_submodule_ignore(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_ignore$handle() {
        return git_submodule_ignore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_submodule_ignore_t git_submodule_ignore(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_ignore$address() {
        return git_submodule_ignore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_submodule_ignore_t git_submodule_ignore(git_submodule *submodule)
     * }
     */
    public static int git_submodule_ignore(MemorySegment submodule) {
        var mh$ = git_submodule_ignore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_ignore", submodule);
            }
            return (int)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_set_ignore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_set_ignore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_set_ignore(git_repository *repo, const char *name, git_submodule_ignore_t ignore)
     * }
     */
    public static FunctionDescriptor git_submodule_set_ignore$descriptor() {
        return git_submodule_set_ignore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_set_ignore(git_repository *repo, const char *name, git_submodule_ignore_t ignore)
     * }
     */
    public static MethodHandle git_submodule_set_ignore$handle() {
        return git_submodule_set_ignore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_set_ignore(git_repository *repo, const char *name, git_submodule_ignore_t ignore)
     * }
     */
    public static MemorySegment git_submodule_set_ignore$address() {
        return git_submodule_set_ignore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_set_ignore(git_repository *repo, const char *name, git_submodule_ignore_t ignore)
     * }
     */
    public static int git_submodule_set_ignore(MemorySegment repo, MemorySegment name, int ignore) {
        var mh$ = git_submodule_set_ignore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_set_ignore", repo, name, ignore);
            }
            return (int)mh$.invokeExact(repo, name, ignore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_update_strategy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_update_strategy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_submodule_update_t git_submodule_update_strategy(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_update_strategy$descriptor() {
        return git_submodule_update_strategy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_submodule_update_t git_submodule_update_strategy(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_update_strategy$handle() {
        return git_submodule_update_strategy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_submodule_update_t git_submodule_update_strategy(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_update_strategy$address() {
        return git_submodule_update_strategy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_submodule_update_t git_submodule_update_strategy(git_submodule *submodule)
     * }
     */
    public static int git_submodule_update_strategy(MemorySegment submodule) {
        var mh$ = git_submodule_update_strategy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_update_strategy", submodule);
            }
            return (int)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_set_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_set_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_set_update(git_repository *repo, const char *name, git_submodule_update_t update)
     * }
     */
    public static FunctionDescriptor git_submodule_set_update$descriptor() {
        return git_submodule_set_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_set_update(git_repository *repo, const char *name, git_submodule_update_t update)
     * }
     */
    public static MethodHandle git_submodule_set_update$handle() {
        return git_submodule_set_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_set_update(git_repository *repo, const char *name, git_submodule_update_t update)
     * }
     */
    public static MemorySegment git_submodule_set_update$address() {
        return git_submodule_set_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_set_update(git_repository *repo, const char *name, git_submodule_update_t update)
     * }
     */
    public static int git_submodule_set_update(MemorySegment repo, MemorySegment name, int update) {
        var mh$ = git_submodule_set_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_set_update", repo, name, update);
            }
            return (int)mh$.invokeExact(repo, name, update);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_fetch_recurse_submodules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_fetch_recurse_submodules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_submodule_recurse_t git_submodule_fetch_recurse_submodules(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_fetch_recurse_submodules$descriptor() {
        return git_submodule_fetch_recurse_submodules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_submodule_recurse_t git_submodule_fetch_recurse_submodules(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_fetch_recurse_submodules$handle() {
        return git_submodule_fetch_recurse_submodules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_submodule_recurse_t git_submodule_fetch_recurse_submodules(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_fetch_recurse_submodules$address() {
        return git_submodule_fetch_recurse_submodules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_submodule_recurse_t git_submodule_fetch_recurse_submodules(git_submodule *submodule)
     * }
     */
    public static int git_submodule_fetch_recurse_submodules(MemorySegment submodule) {
        var mh$ = git_submodule_fetch_recurse_submodules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_fetch_recurse_submodules", submodule);
            }
            return (int)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_set_fetch_recurse_submodules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_set_fetch_recurse_submodules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_set_fetch_recurse_submodules(git_repository *repo, const char *name, git_submodule_recurse_t fetch_recurse_submodules)
     * }
     */
    public static FunctionDescriptor git_submodule_set_fetch_recurse_submodules$descriptor() {
        return git_submodule_set_fetch_recurse_submodules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_set_fetch_recurse_submodules(git_repository *repo, const char *name, git_submodule_recurse_t fetch_recurse_submodules)
     * }
     */
    public static MethodHandle git_submodule_set_fetch_recurse_submodules$handle() {
        return git_submodule_set_fetch_recurse_submodules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_set_fetch_recurse_submodules(git_repository *repo, const char *name, git_submodule_recurse_t fetch_recurse_submodules)
     * }
     */
    public static MemorySegment git_submodule_set_fetch_recurse_submodules$address() {
        return git_submodule_set_fetch_recurse_submodules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_set_fetch_recurse_submodules(git_repository *repo, const char *name, git_submodule_recurse_t fetch_recurse_submodules)
     * }
     */
    public static int git_submodule_set_fetch_recurse_submodules(MemorySegment repo, MemorySegment name, int fetch_recurse_submodules) {
        var mh$ = git_submodule_set_fetch_recurse_submodules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_set_fetch_recurse_submodules", repo, name, fetch_recurse_submodules);
            }
            return (int)mh$.invokeExact(repo, name, fetch_recurse_submodules);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_init(git_submodule *submodule, int overwrite)
     * }
     */
    public static FunctionDescriptor git_submodule_init$descriptor() {
        return git_submodule_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_init(git_submodule *submodule, int overwrite)
     * }
     */
    public static MethodHandle git_submodule_init$handle() {
        return git_submodule_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_init(git_submodule *submodule, int overwrite)
     * }
     */
    public static MemorySegment git_submodule_init$address() {
        return git_submodule_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_init(git_submodule *submodule, int overwrite)
     * }
     */
    public static int git_submodule_init(MemorySegment submodule, int overwrite) {
        var mh$ = git_submodule_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_init", submodule, overwrite);
            }
            return (int)mh$.invokeExact(submodule, overwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_repo_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_repo_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_repo_init(git_repository **out, const git_submodule *sm, int use_gitlink)
     * }
     */
    public static FunctionDescriptor git_submodule_repo_init$descriptor() {
        return git_submodule_repo_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_repo_init(git_repository **out, const git_submodule *sm, int use_gitlink)
     * }
     */
    public static MethodHandle git_submodule_repo_init$handle() {
        return git_submodule_repo_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_repo_init(git_repository **out, const git_submodule *sm, int use_gitlink)
     * }
     */
    public static MemorySegment git_submodule_repo_init$address() {
        return git_submodule_repo_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_repo_init(git_repository **out, const git_submodule *sm, int use_gitlink)
     * }
     */
    public static int git_submodule_repo_init(MemorySegment out, MemorySegment sm, int use_gitlink) {
        var mh$ = git_submodule_repo_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_repo_init", out, sm, use_gitlink);
            }
            return (int)mh$.invokeExact(out, sm, use_gitlink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_sync(git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_sync$descriptor() {
        return git_submodule_sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_sync(git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_sync$handle() {
        return git_submodule_sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_sync(git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_sync$address() {
        return git_submodule_sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_sync(git_submodule *submodule)
     * }
     */
    public static int git_submodule_sync(MemorySegment submodule) {
        var mh$ = git_submodule_sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_sync", submodule);
            }
            return (int)mh$.invokeExact(submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_open(git_repository **repo, git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_open$descriptor() {
        return git_submodule_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_open(git_repository **repo, git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_open$handle() {
        return git_submodule_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_open(git_repository **repo, git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_open$address() {
        return git_submodule_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_open(git_repository **repo, git_submodule *submodule)
     * }
     */
    public static int git_submodule_open(MemorySegment repo, MemorySegment submodule) {
        var mh$ = git_submodule_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_open", repo, submodule);
            }
            return (int)mh$.invokeExact(repo, submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_reload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_reload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_reload(git_submodule *submodule, int force)
     * }
     */
    public static FunctionDescriptor git_submodule_reload$descriptor() {
        return git_submodule_reload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_reload(git_submodule *submodule, int force)
     * }
     */
    public static MethodHandle git_submodule_reload$handle() {
        return git_submodule_reload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_reload(git_submodule *submodule, int force)
     * }
     */
    public static MemorySegment git_submodule_reload$address() {
        return git_submodule_reload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_reload(git_submodule *submodule, int force)
     * }
     */
    public static int git_submodule_reload(MemorySegment submodule, int force) {
        var mh$ = git_submodule_reload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_reload", submodule, force);
            }
            return (int)mh$.invokeExact(submodule, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_status {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_status");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_status(unsigned int *status, git_repository *repo, const char *name, git_submodule_ignore_t ignore)
     * }
     */
    public static FunctionDescriptor git_submodule_status$descriptor() {
        return git_submodule_status.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_status(unsigned int *status, git_repository *repo, const char *name, git_submodule_ignore_t ignore)
     * }
     */
    public static MethodHandle git_submodule_status$handle() {
        return git_submodule_status.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_status(unsigned int *status, git_repository *repo, const char *name, git_submodule_ignore_t ignore)
     * }
     */
    public static MemorySegment git_submodule_status$address() {
        return git_submodule_status.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_status(unsigned int *status, git_repository *repo, const char *name, git_submodule_ignore_t ignore)
     * }
     */
    public static int git_submodule_status(MemorySegment status, MemorySegment repo, MemorySegment name, int ignore) {
        var mh$ = git_submodule_status.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_status", status, repo, name, ignore);
            }
            return (int)mh$.invokeExact(status, repo, name, ignore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_location {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_location");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_location(unsigned int *location_status, git_submodule *submodule)
     * }
     */
    public static FunctionDescriptor git_submodule_location$descriptor() {
        return git_submodule_location.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_location(unsigned int *location_status, git_submodule *submodule)
     * }
     */
    public static MethodHandle git_submodule_location$handle() {
        return git_submodule_location.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_location(unsigned int *location_status, git_submodule *submodule)
     * }
     */
    public static MemorySegment git_submodule_location$address() {
        return git_submodule_location.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_location(unsigned int *location_status, git_submodule *submodule)
     * }
     */
    public static int git_submodule_location(MemorySegment location_status, MemorySegment submodule) {
        var mh$ = git_submodule_location.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_location", location_status, submodule);
            }
            return (int)mh$.invokeExact(location_status, submodule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_list(git_strarray *out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_worktree_list$descriptor() {
        return git_worktree_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_list(git_strarray *out, git_repository *repo)
     * }
     */
    public static MethodHandle git_worktree_list$handle() {
        return git_worktree_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_list(git_strarray *out, git_repository *repo)
     * }
     */
    public static MemorySegment git_worktree_list$address() {
        return git_worktree_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_list(git_strarray *out, git_repository *repo)
     * }
     */
    public static int git_worktree_list(MemorySegment out, MemorySegment repo) {
        var mh$ = git_worktree_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_list", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_lookup(git_worktree **out, git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_worktree_lookup$descriptor() {
        return git_worktree_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_lookup(git_worktree **out, git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_worktree_lookup$handle() {
        return git_worktree_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_lookup(git_worktree **out, git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_worktree_lookup$address() {
        return git_worktree_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_lookup(git_worktree **out, git_repository *repo, const char *name)
     * }
     */
    public static int git_worktree_lookup(MemorySegment out, MemorySegment repo, MemorySegment name) {
        var mh$ = git_worktree_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_lookup", out, repo, name);
            }
            return (int)mh$.invokeExact(out, repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_open_from_repository {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_open_from_repository");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_open_from_repository(git_worktree **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_worktree_open_from_repository$descriptor() {
        return git_worktree_open_from_repository.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_open_from_repository(git_worktree **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_worktree_open_from_repository$handle() {
        return git_worktree_open_from_repository.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_open_from_repository(git_worktree **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_worktree_open_from_repository$address() {
        return git_worktree_open_from_repository.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_open_from_repository(git_worktree **out, git_repository *repo)
     * }
     */
    public static int git_worktree_open_from_repository(MemorySegment out, MemorySegment repo) {
        var mh$ = git_worktree_open_from_repository.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_open_from_repository", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_worktree_free(git_worktree *wt)
     * }
     */
    public static FunctionDescriptor git_worktree_free$descriptor() {
        return git_worktree_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_worktree_free(git_worktree *wt)
     * }
     */
    public static MethodHandle git_worktree_free$handle() {
        return git_worktree_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_worktree_free(git_worktree *wt)
     * }
     */
    public static MemorySegment git_worktree_free$address() {
        return git_worktree_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_worktree_free(git_worktree *wt)
     * }
     */
    public static void git_worktree_free(MemorySegment wt) {
        var mh$ = git_worktree_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_free", wt);
            }
            mh$.invokeExact(wt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_validate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_validate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_validate(const git_worktree *wt)
     * }
     */
    public static FunctionDescriptor git_worktree_validate$descriptor() {
        return git_worktree_validate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_validate(const git_worktree *wt)
     * }
     */
    public static MethodHandle git_worktree_validate$handle() {
        return git_worktree_validate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_validate(const git_worktree *wt)
     * }
     */
    public static MemorySegment git_worktree_validate$address() {
        return git_worktree_validate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_validate(const git_worktree *wt)
     * }
     */
    public static int git_worktree_validate(MemorySegment wt) {
        var mh$ = git_worktree_validate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_validate", wt);
            }
            return (int)mh$.invokeExact(wt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_add_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_add_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_add_options_init(git_worktree_add_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_worktree_add_options_init$descriptor() {
        return git_worktree_add_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_add_options_init(git_worktree_add_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_worktree_add_options_init$handle() {
        return git_worktree_add_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_add_options_init(git_worktree_add_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_worktree_add_options_init$address() {
        return git_worktree_add_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_add_options_init(git_worktree_add_options *opts, unsigned int version)
     * }
     */
    public static int git_worktree_add_options_init(MemorySegment opts, int version) {
        var mh$ = git_worktree_add_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_add_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_add(git_worktree **out, git_repository *repo, const char *name, const char *path, const git_worktree_add_options *opts)
     * }
     */
    public static FunctionDescriptor git_worktree_add$descriptor() {
        return git_worktree_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_add(git_worktree **out, git_repository *repo, const char *name, const char *path, const git_worktree_add_options *opts)
     * }
     */
    public static MethodHandle git_worktree_add$handle() {
        return git_worktree_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_add(git_worktree **out, git_repository *repo, const char *name, const char *path, const git_worktree_add_options *opts)
     * }
     */
    public static MemorySegment git_worktree_add$address() {
        return git_worktree_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_add(git_worktree **out, git_repository *repo, const char *name, const char *path, const git_worktree_add_options *opts)
     * }
     */
    public static int git_worktree_add(MemorySegment out, MemorySegment repo, MemorySegment name, MemorySegment path, MemorySegment opts) {
        var mh$ = git_worktree_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_add", out, repo, name, path, opts);
            }
            return (int)mh$.invokeExact(out, repo, name, path, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_lock(git_worktree *wt, const char *reason)
     * }
     */
    public static FunctionDescriptor git_worktree_lock$descriptor() {
        return git_worktree_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_lock(git_worktree *wt, const char *reason)
     * }
     */
    public static MethodHandle git_worktree_lock$handle() {
        return git_worktree_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_lock(git_worktree *wt, const char *reason)
     * }
     */
    public static MemorySegment git_worktree_lock$address() {
        return git_worktree_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_lock(git_worktree *wt, const char *reason)
     * }
     */
    public static int git_worktree_lock(MemorySegment wt, MemorySegment reason) {
        var mh$ = git_worktree_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_lock", wt, reason);
            }
            return (int)mh$.invokeExact(wt, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_unlock(git_worktree *wt)
     * }
     */
    public static FunctionDescriptor git_worktree_unlock$descriptor() {
        return git_worktree_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_unlock(git_worktree *wt)
     * }
     */
    public static MethodHandle git_worktree_unlock$handle() {
        return git_worktree_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_unlock(git_worktree *wt)
     * }
     */
    public static MemorySegment git_worktree_unlock$address() {
        return git_worktree_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_unlock(git_worktree *wt)
     * }
     */
    public static int git_worktree_unlock(MemorySegment wt) {
        var mh$ = git_worktree_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_unlock", wt);
            }
            return (int)mh$.invokeExact(wt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_is_locked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_is_locked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_is_locked(git_buf *reason, const git_worktree *wt)
     * }
     */
    public static FunctionDescriptor git_worktree_is_locked$descriptor() {
        return git_worktree_is_locked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_is_locked(git_buf *reason, const git_worktree *wt)
     * }
     */
    public static MethodHandle git_worktree_is_locked$handle() {
        return git_worktree_is_locked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_is_locked(git_buf *reason, const git_worktree *wt)
     * }
     */
    public static MemorySegment git_worktree_is_locked$address() {
        return git_worktree_is_locked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_is_locked(git_buf *reason, const git_worktree *wt)
     * }
     */
    public static int git_worktree_is_locked(MemorySegment reason, MemorySegment wt) {
        var mh$ = git_worktree_is_locked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_is_locked", reason, wt);
            }
            return (int)mh$.invokeExact(reason, wt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_worktree_name(const git_worktree *wt)
     * }
     */
    public static FunctionDescriptor git_worktree_name$descriptor() {
        return git_worktree_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_worktree_name(const git_worktree *wt)
     * }
     */
    public static MethodHandle git_worktree_name$handle() {
        return git_worktree_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_worktree_name(const git_worktree *wt)
     * }
     */
    public static MemorySegment git_worktree_name$address() {
        return git_worktree_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_worktree_name(const git_worktree *wt)
     * }
     */
    public static MemorySegment git_worktree_name(MemorySegment wt) {
        var mh$ = git_worktree_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_name", wt);
            }
            return (MemorySegment)mh$.invokeExact(wt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_worktree_path(const git_worktree *wt)
     * }
     */
    public static FunctionDescriptor git_worktree_path$descriptor() {
        return git_worktree_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_worktree_path(const git_worktree *wt)
     * }
     */
    public static MethodHandle git_worktree_path$handle() {
        return git_worktree_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_worktree_path(const git_worktree *wt)
     * }
     */
    public static MemorySegment git_worktree_path$address() {
        return git_worktree_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_worktree_path(const git_worktree *wt)
     * }
     */
    public static MemorySegment git_worktree_path(MemorySegment wt) {
        var mh$ = git_worktree_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_path", wt);
            }
            return (MemorySegment)mh$.invokeExact(wt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_WORKTREE_PRUNE_VALID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_WORKTREE_PRUNE_VALID = 1
     * }
     */
    public static int GIT_WORKTREE_PRUNE_VALID() {
        return GIT_WORKTREE_PRUNE_VALID;
    }
    private static final int GIT_WORKTREE_PRUNE_LOCKED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_WORKTREE_PRUNE_LOCKED = 2
     * }
     */
    public static int GIT_WORKTREE_PRUNE_LOCKED() {
        return GIT_WORKTREE_PRUNE_LOCKED;
    }
    private static final int GIT_WORKTREE_PRUNE_WORKING_TREE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_WORKTREE_PRUNE_WORKING_TREE = 4
     * }
     */
    public static int GIT_WORKTREE_PRUNE_WORKING_TREE() {
        return GIT_WORKTREE_PRUNE_WORKING_TREE;
    }

    private static class git_worktree_prune_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_prune_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_prune_options_init(git_worktree_prune_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_worktree_prune_options_init$descriptor() {
        return git_worktree_prune_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_prune_options_init(git_worktree_prune_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_worktree_prune_options_init$handle() {
        return git_worktree_prune_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_prune_options_init(git_worktree_prune_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_worktree_prune_options_init$address() {
        return git_worktree_prune_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_prune_options_init(git_worktree_prune_options *opts, unsigned int version)
     * }
     */
    public static int git_worktree_prune_options_init(MemorySegment opts, int version) {
        var mh$ = git_worktree_prune_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_prune_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_is_prunable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_is_prunable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_is_prunable(git_worktree *wt, git_worktree_prune_options *opts)
     * }
     */
    public static FunctionDescriptor git_worktree_is_prunable$descriptor() {
        return git_worktree_is_prunable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_is_prunable(git_worktree *wt, git_worktree_prune_options *opts)
     * }
     */
    public static MethodHandle git_worktree_is_prunable$handle() {
        return git_worktree_is_prunable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_is_prunable(git_worktree *wt, git_worktree_prune_options *opts)
     * }
     */
    public static MemorySegment git_worktree_is_prunable$address() {
        return git_worktree_is_prunable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_is_prunable(git_worktree *wt, git_worktree_prune_options *opts)
     * }
     */
    public static int git_worktree_is_prunable(MemorySegment wt, MemorySegment opts) {
        var mh$ = git_worktree_is_prunable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_is_prunable", wt, opts);
            }
            return (int)mh$.invokeExact(wt, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_prune {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_prune");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_prune(git_worktree *wt, git_worktree_prune_options *opts)
     * }
     */
    public static FunctionDescriptor git_worktree_prune$descriptor() {
        return git_worktree_prune.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_prune(git_worktree *wt, git_worktree_prune_options *opts)
     * }
     */
    public static MethodHandle git_worktree_prune$handle() {
        return git_worktree_prune.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_prune(git_worktree *wt, git_worktree_prune_options *opts)
     * }
     */
    public static MemorySegment git_worktree_prune$address() {
        return git_worktree_prune.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_prune(git_worktree *wt, git_worktree_prune_options *opts)
     * }
     */
    public static int git_worktree_prune(MemorySegment wt, MemorySegment opts) {
        var mh$ = git_worktree_prune.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_prune", wt, opts);
            }
            return (int)mh$.invokeExact(wt, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_credential_userpass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_credential_userpass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_credential_userpass(git_credential **out, const char *url, const char *user_from_url, unsigned int allowed_types, void *payload)
     * }
     */
    public static FunctionDescriptor git_credential_userpass$descriptor() {
        return git_credential_userpass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_credential_userpass(git_credential **out, const char *url, const char *user_from_url, unsigned int allowed_types, void *payload)
     * }
     */
    public static MethodHandle git_credential_userpass$handle() {
        return git_credential_userpass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_credential_userpass(git_credential **out, const char *url, const char *user_from_url, unsigned int allowed_types, void *payload)
     * }
     */
    public static MemorySegment git_credential_userpass$address() {
        return git_credential_userpass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_credential_userpass(git_credential **out, const char *url, const char *user_from_url, unsigned int allowed_types, void *payload)
     * }
     */
    public static int git_credential_userpass(MemorySegment out, MemorySegment url, MemorySegment user_from_url, int allowed_types, MemorySegment payload) {
        var mh$ = git_credential_userpass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_credential_userpass", out, url, user_from_url, allowed_types, payload);
            }
            return (int)mh$.invokeExact(out, url, user_from_url, allowed_types, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_create_fromworkdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_create_fromworkdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromworkdir(git_oid *id, git_repository *repo, const char *relative_path)
     * }
     */
    public static FunctionDescriptor git_blob_create_fromworkdir$descriptor() {
        return git_blob_create_fromworkdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromworkdir(git_oid *id, git_repository *repo, const char *relative_path)
     * }
     */
    public static MethodHandle git_blob_create_fromworkdir$handle() {
        return git_blob_create_fromworkdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromworkdir(git_oid *id, git_repository *repo, const char *relative_path)
     * }
     */
    public static MemorySegment git_blob_create_fromworkdir$address() {
        return git_blob_create_fromworkdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_create_fromworkdir(git_oid *id, git_repository *repo, const char *relative_path)
     * }
     */
    public static int git_blob_create_fromworkdir(MemorySegment id, MemorySegment repo, MemorySegment relative_path) {
        var mh$ = git_blob_create_fromworkdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_create_fromworkdir", id, repo, relative_path);
            }
            return (int)mh$.invokeExact(id, repo, relative_path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_create_fromdisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_create_fromdisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromdisk(git_oid *id, git_repository *repo, const char *path)
     * }
     */
    public static FunctionDescriptor git_blob_create_fromdisk$descriptor() {
        return git_blob_create_fromdisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromdisk(git_oid *id, git_repository *repo, const char *path)
     * }
     */
    public static MethodHandle git_blob_create_fromdisk$handle() {
        return git_blob_create_fromdisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromdisk(git_oid *id, git_repository *repo, const char *path)
     * }
     */
    public static MemorySegment git_blob_create_fromdisk$address() {
        return git_blob_create_fromdisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_create_fromdisk(git_oid *id, git_repository *repo, const char *path)
     * }
     */
    public static int git_blob_create_fromdisk(MemorySegment id, MemorySegment repo, MemorySegment path) {
        var mh$ = git_blob_create_fromdisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_create_fromdisk", id, repo, path);
            }
            return (int)mh$.invokeExact(id, repo, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_create_fromstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_create_fromstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromstream(git_writestream **out, git_repository *repo, const char *hintpath)
     * }
     */
    public static FunctionDescriptor git_blob_create_fromstream$descriptor() {
        return git_blob_create_fromstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromstream(git_writestream **out, git_repository *repo, const char *hintpath)
     * }
     */
    public static MethodHandle git_blob_create_fromstream$handle() {
        return git_blob_create_fromstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromstream(git_writestream **out, git_repository *repo, const char *hintpath)
     * }
     */
    public static MemorySegment git_blob_create_fromstream$address() {
        return git_blob_create_fromstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_create_fromstream(git_writestream **out, git_repository *repo, const char *hintpath)
     * }
     */
    public static int git_blob_create_fromstream(MemorySegment out, MemorySegment repo, MemorySegment hintpath) {
        var mh$ = git_blob_create_fromstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_create_fromstream", out, repo, hintpath);
            }
            return (int)mh$.invokeExact(out, repo, hintpath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_create_fromstream_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_create_fromstream_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromstream_commit(git_oid *out, git_writestream *stream)
     * }
     */
    public static FunctionDescriptor git_blob_create_fromstream_commit$descriptor() {
        return git_blob_create_fromstream_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromstream_commit(git_oid *out, git_writestream *stream)
     * }
     */
    public static MethodHandle git_blob_create_fromstream_commit$handle() {
        return git_blob_create_fromstream_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_create_fromstream_commit(git_oid *out, git_writestream *stream)
     * }
     */
    public static MemorySegment git_blob_create_fromstream_commit$address() {
        return git_blob_create_fromstream_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_create_fromstream_commit(git_oid *out, git_writestream *stream)
     * }
     */
    public static int git_blob_create_fromstream_commit(MemorySegment out, MemorySegment stream) {
        var mh$ = git_blob_create_fromstream_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_create_fromstream_commit", out, stream);
            }
            return (int)mh$.invokeExact(out, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_create_frombuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_create_frombuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_create_frombuffer(git_oid *id, git_repository *repo, const void *buffer, size_t len)
     * }
     */
    public static FunctionDescriptor git_blob_create_frombuffer$descriptor() {
        return git_blob_create_frombuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_create_frombuffer(git_oid *id, git_repository *repo, const void *buffer, size_t len)
     * }
     */
    public static MethodHandle git_blob_create_frombuffer$handle() {
        return git_blob_create_frombuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_create_frombuffer(git_oid *id, git_repository *repo, const void *buffer, size_t len)
     * }
     */
    public static MemorySegment git_blob_create_frombuffer$address() {
        return git_blob_create_frombuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_create_frombuffer(git_oid *id, git_repository *repo, const void *buffer, size_t len)
     * }
     */
    public static int git_blob_create_frombuffer(MemorySegment id, MemorySegment repo, MemorySegment buffer, long len) {
        var mh$ = git_blob_create_frombuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_create_frombuffer", id, repo, buffer, len);
            }
            return (int)mh$.invokeExact(id, repo, buffer, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blob_filtered_content {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blob_filtered_content");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blob_filtered_content(git_buf *out, git_blob *blob, const char *as_path, int check_for_binary_data)
     * }
     */
    public static FunctionDescriptor git_blob_filtered_content$descriptor() {
        return git_blob_filtered_content.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blob_filtered_content(git_buf *out, git_blob *blob, const char *as_path, int check_for_binary_data)
     * }
     */
    public static MethodHandle git_blob_filtered_content$handle() {
        return git_blob_filtered_content.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blob_filtered_content(git_buf *out, git_blob *blob, const char *as_path, int check_for_binary_data)
     * }
     */
    public static MemorySegment git_blob_filtered_content$address() {
        return git_blob_filtered_content.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blob_filtered_content(git_buf *out, git_blob *blob, const char *as_path, int check_for_binary_data)
     * }
     */
    public static int git_blob_filtered_content(MemorySegment out, MemorySegment blob, MemorySegment as_path, int check_for_binary_data) {
        var mh$ = git_blob_filtered_content.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blob_filtered_content", out, blob, as_path, check_for_binary_data);
            }
            return (int)mh$.invokeExact(out, blob, as_path, check_for_binary_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_stream_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_stream_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_data(git_filter_list *filters, git_buf *data, git_writestream *target)
     * }
     */
    public static FunctionDescriptor git_filter_list_stream_data$descriptor() {
        return git_filter_list_stream_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_data(git_filter_list *filters, git_buf *data, git_writestream *target)
     * }
     */
    public static MethodHandle git_filter_list_stream_data$handle() {
        return git_filter_list_stream_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_stream_data(git_filter_list *filters, git_buf *data, git_writestream *target)
     * }
     */
    public static MemorySegment git_filter_list_stream_data$address() {
        return git_filter_list_stream_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_stream_data(git_filter_list *filters, git_buf *data, git_writestream *target)
     * }
     */
    public static int git_filter_list_stream_data(MemorySegment filters, MemorySegment data, MemorySegment target) {
        var mh$ = git_filter_list_stream_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_stream_data", filters, data, target);
            }
            return (int)mh$.invokeExact(filters, data, target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_filter_list_apply_to_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_filter_list_apply_to_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_data(git_buf *out, git_filter_list *filters, git_buf *in)
     * }
     */
    public static FunctionDescriptor git_filter_list_apply_to_data$descriptor() {
        return git_filter_list_apply_to_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_data(git_buf *out, git_filter_list *filters, git_buf *in)
     * }
     */
    public static MethodHandle git_filter_list_apply_to_data$handle() {
        return git_filter_list_apply_to_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_data(git_buf *out, git_filter_list *filters, git_buf *in)
     * }
     */
    public static MemorySegment git_filter_list_apply_to_data$address() {
        return git_filter_list_apply_to_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_filter_list_apply_to_data(git_buf *out, git_filter_list *filters, git_buf *in)
     * }
     */
    public static int git_filter_list_apply_to_data(MemorySegment out, MemorySegment filters, MemorySegment in) {
        var mh$ = git_filter_list_apply_to_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_filter_list_apply_to_data", out, filters, in);
            }
            return (int)mh$.invokeExact(out, filters, in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_treebuilder_write_with_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_treebuilder_write_with_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_treebuilder_write_with_buffer(git_oid *oid, git_treebuilder *bld, git_buf *tree)
     * }
     */
    public static FunctionDescriptor git_treebuilder_write_with_buffer$descriptor() {
        return git_treebuilder_write_with_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_treebuilder_write_with_buffer(git_oid *oid, git_treebuilder *bld, git_buf *tree)
     * }
     */
    public static MethodHandle git_treebuilder_write_with_buffer$handle() {
        return git_treebuilder_write_with_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_treebuilder_write_with_buffer(git_oid *oid, git_treebuilder *bld, git_buf *tree)
     * }
     */
    public static MemorySegment git_treebuilder_write_with_buffer$address() {
        return git_treebuilder_write_with_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_treebuilder_write_with_buffer(git_oid *oid, git_treebuilder *bld, git_buf *tree)
     * }
     */
    public static int git_treebuilder_write_with_buffer(MemorySegment oid, MemorySegment bld, MemorySegment tree) {
        var mh$ = git_treebuilder_write_with_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_treebuilder_write_with_buffer", oid, bld, tree);
            }
            return (int)mh$.invokeExact(oid, bld, tree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_buf_grow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_buf_grow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_buf_grow(git_buf *buffer, size_t target_size)
     * }
     */
    public static FunctionDescriptor git_buf_grow$descriptor() {
        return git_buf_grow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_buf_grow(git_buf *buffer, size_t target_size)
     * }
     */
    public static MethodHandle git_buf_grow$handle() {
        return git_buf_grow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_buf_grow(git_buf *buffer, size_t target_size)
     * }
     */
    public static MemorySegment git_buf_grow$address() {
        return git_buf_grow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_buf_grow(git_buf *buffer, size_t target_size)
     * }
     */
    public static int git_buf_grow(MemorySegment buffer, long target_size) {
        var mh$ = git_buf_grow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_buf_grow", buffer, target_size);
            }
            return (int)mh$.invokeExact(buffer, target_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_buf_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_buf_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_buf_set(git_buf *buffer, const void *data, size_t datalen)
     * }
     */
    public static FunctionDescriptor git_buf_set$descriptor() {
        return git_buf_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_buf_set(git_buf *buffer, const void *data, size_t datalen)
     * }
     */
    public static MethodHandle git_buf_set$handle() {
        return git_buf_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_buf_set(git_buf *buffer, const void *data, size_t datalen)
     * }
     */
    public static MemorySegment git_buf_set$address() {
        return git_buf_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_buf_set(git_buf *buffer, const void *data, size_t datalen)
     * }
     */
    public static int git_buf_set(MemorySegment buffer, MemorySegment data, long datalen) {
        var mh$ = git_buf_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_buf_set", buffer, data, datalen);
            }
            return (int)mh$.invokeExact(buffer, data, datalen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_buf_is_binary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_buf_is_binary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_buf_is_binary(const git_buf *buf)
     * }
     */
    public static FunctionDescriptor git_buf_is_binary$descriptor() {
        return git_buf_is_binary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_buf_is_binary(const git_buf *buf)
     * }
     */
    public static MethodHandle git_buf_is_binary$handle() {
        return git_buf_is_binary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_buf_is_binary(const git_buf *buf)
     * }
     */
    public static MemorySegment git_buf_is_binary$address() {
        return git_buf_is_binary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_buf_is_binary(const git_buf *buf)
     * }
     */
    public static int git_buf_is_binary(MemorySegment buf) {
        var mh$ = git_buf_is_binary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_buf_is_binary", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_buf_contains_nul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_buf_contains_nul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_buf_contains_nul(const git_buf *buf)
     * }
     */
    public static FunctionDescriptor git_buf_contains_nul$descriptor() {
        return git_buf_contains_nul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_buf_contains_nul(const git_buf *buf)
     * }
     */
    public static MethodHandle git_buf_contains_nul$handle() {
        return git_buf_contains_nul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_buf_contains_nul(const git_buf *buf)
     * }
     */
    public static MemorySegment git_buf_contains_nul$address() {
        return git_buf_contains_nul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_buf_contains_nul(const git_buf *buf)
     * }
     */
    public static int git_buf_contains_nul(MemorySegment buf) {
        var mh$ = git_buf_contains_nul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_buf_contains_nul", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_buf_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_buf_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_buf_free(git_buf *buffer)
     * }
     */
    public static FunctionDescriptor git_buf_free$descriptor() {
        return git_buf_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_buf_free(git_buf *buffer)
     * }
     */
    public static MethodHandle git_buf_free$handle() {
        return git_buf_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_buf_free(git_buf *buffer)
     * }
     */
    public static MemorySegment git_buf_free$address() {
        return git_buf_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_buf_free(git_buf *buffer)
     * }
     */
    public static void git_buf_free(MemorySegment buffer) {
        var mh$ = git_buf_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_buf_free", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_DIFF_FORMAT_EMAIL_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FORMAT_EMAIL_NONE = 0
     * }
     */
    public static int GIT_DIFF_FORMAT_EMAIL_NONE() {
        return GIT_DIFF_FORMAT_EMAIL_NONE;
    }
    private static final int GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER = 1
     * }
     */
    public static int GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER() {
        return GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER;
    }

    private static class git_diff_format_email {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_format_email");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_format_email(git_buf *out, git_diff *diff, const git_diff_format_email_options *opts)
     * }
     */
    public static FunctionDescriptor git_diff_format_email$descriptor() {
        return git_diff_format_email.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_format_email(git_buf *out, git_diff *diff, const git_diff_format_email_options *opts)
     * }
     */
    public static MethodHandle git_diff_format_email$handle() {
        return git_diff_format_email.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_format_email(git_buf *out, git_diff *diff, const git_diff_format_email_options *opts)
     * }
     */
    public static MemorySegment git_diff_format_email$address() {
        return git_diff_format_email.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_format_email(git_buf *out, git_diff *diff, const git_diff_format_email_options *opts)
     * }
     */
    public static int git_diff_format_email(MemorySegment out, MemorySegment diff, MemorySegment opts) {
        var mh$ = git_diff_format_email.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_format_email", out, diff, opts);
            }
            return (int)mh$.invokeExact(out, diff, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_commit_as_email {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_LONG,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_commit_as_email");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_commit_as_email(git_buf *out, git_repository *repo, git_commit *commit, size_t patch_no, size_t total_patches, uint32_t flags, const git_diff_options *diff_opts)
     * }
     */
    public static FunctionDescriptor git_diff_commit_as_email$descriptor() {
        return git_diff_commit_as_email.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_commit_as_email(git_buf *out, git_repository *repo, git_commit *commit, size_t patch_no, size_t total_patches, uint32_t flags, const git_diff_options *diff_opts)
     * }
     */
    public static MethodHandle git_diff_commit_as_email$handle() {
        return git_diff_commit_as_email.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_commit_as_email(git_buf *out, git_repository *repo, git_commit *commit, size_t patch_no, size_t total_patches, uint32_t flags, const git_diff_options *diff_opts)
     * }
     */
    public static MemorySegment git_diff_commit_as_email$address() {
        return git_diff_commit_as_email.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_commit_as_email(git_buf *out, git_repository *repo, git_commit *commit, size_t patch_no, size_t total_patches, uint32_t flags, const git_diff_options *diff_opts)
     * }
     */
    public static int git_diff_commit_as_email(MemorySegment out, MemorySegment repo, MemorySegment commit, long patch_no, long total_patches, int flags, MemorySegment diff_opts) {
        var mh$ = git_diff_commit_as_email.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_commit_as_email", out, repo, commit, patch_no, total_patches, flags, diff_opts);
            }
            return (int)mh$.invokeExact(out, repo, commit, patch_no, total_patches, flags, diff_opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_format_email_options_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_format_email_options_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_format_email_options_init(git_diff_format_email_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_diff_format_email_options_init$descriptor() {
        return git_diff_format_email_options_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_format_email_options_init(git_diff_format_email_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_diff_format_email_options_init$handle() {
        return git_diff_format_email_options_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_format_email_options_init(git_diff_format_email_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_diff_format_email_options_init$address() {
        return git_diff_format_email_options_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_format_email_options_init(git_diff_format_email_options *opts, unsigned int version)
     * }
     */
    public static int git_diff_format_email_options_init(MemorySegment opts, int version) {
        var mh$ = git_diff_format_email_options_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_format_email_options_init", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class giterr_last {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER    );

        public static final MemorySegment ADDR = git2.findOrThrow("giterr_last");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_error *giterr_last()
     * }
     */
    public static FunctionDescriptor giterr_last$descriptor() {
        return giterr_last.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_error *giterr_last()
     * }
     */
    public static MethodHandle giterr_last$handle() {
        return giterr_last.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_error *giterr_last()
     * }
     */
    public static MemorySegment giterr_last$address() {
        return giterr_last.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_error *giterr_last()
     * }
     */
    public static MemorySegment giterr_last() {
        var mh$ = giterr_last.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("giterr_last");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class giterr_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = git2.findOrThrow("giterr_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void giterr_clear()
     * }
     */
    public static FunctionDescriptor giterr_clear$descriptor() {
        return giterr_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void giterr_clear()
     * }
     */
    public static MethodHandle giterr_clear$handle() {
        return giterr_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void giterr_clear()
     * }
     */
    public static MemorySegment giterr_clear$address() {
        return giterr_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void giterr_clear()
     * }
     */
    public static void giterr_clear() {
        var mh$ = giterr_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("giterr_clear");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class giterr_set_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("giterr_set_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void giterr_set_str(int error_class, const char *string)
     * }
     */
    public static FunctionDescriptor giterr_set_str$descriptor() {
        return giterr_set_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void giterr_set_str(int error_class, const char *string)
     * }
     */
    public static MethodHandle giterr_set_str$handle() {
        return giterr_set_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void giterr_set_str(int error_class, const char *string)
     * }
     */
    public static MemorySegment giterr_set_str$address() {
        return giterr_set_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void giterr_set_str(int error_class, const char *string)
     * }
     */
    public static void giterr_set_str(int error_class, MemorySegment string) {
        var mh$ = giterr_set_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("giterr_set_str", error_class, string);
            }
            mh$.invokeExact(error_class, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class giterr_set_oom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = git2.findOrThrow("giterr_set_oom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void giterr_set_oom()
     * }
     */
    public static FunctionDescriptor giterr_set_oom$descriptor() {
        return giterr_set_oom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void giterr_set_oom()
     * }
     */
    public static MethodHandle giterr_set_oom$handle() {
        return giterr_set_oom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void giterr_set_oom()
     * }
     */
    public static MemorySegment giterr_set_oom$address() {
        return giterr_set_oom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void giterr_set_oom()
     * }
     */
    public static void giterr_set_oom() {
        var mh$ = giterr_set_oom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("giterr_set_oom");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_index_add_frombuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_index_add_frombuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_index_add_frombuffer(git_index *index, const git_index_entry *entry, const void *buffer, size_t len)
     * }
     */
    public static FunctionDescriptor git_index_add_frombuffer$descriptor() {
        return git_index_add_frombuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_index_add_frombuffer(git_index *index, const git_index_entry *entry, const void *buffer, size_t len)
     * }
     */
    public static MethodHandle git_index_add_frombuffer$handle() {
        return git_index_add_frombuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_index_add_frombuffer(git_index *index, const git_index_entry *entry, const void *buffer, size_t len)
     * }
     */
    public static MemorySegment git_index_add_frombuffer$address() {
        return git_index_add_frombuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_index_add_frombuffer(git_index *index, const git_index_entry *entry, const void *buffer, size_t len)
     * }
     */
    public static int git_index_add_frombuffer(MemorySegment index, MemorySegment entry, MemorySegment buffer, long len) {
        var mh$ = git_index_add_frombuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_index_add_frombuffer", index, entry, buffer, len);
            }
            return (int)mh$.invokeExact(index, entry, buffer, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_object__size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_object__size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_object__size(git_object_t type)
     * }
     */
    public static FunctionDescriptor git_object__size$descriptor() {
        return git_object__size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_object__size(git_object_t type)
     * }
     */
    public static MethodHandle git_object__size$handle() {
        return git_object__size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_object__size(git_object_t type)
     * }
     */
    public static MemorySegment git_object__size$address() {
        return git_object__size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_object__size(git_object_t type)
     * }
     */
    public static long git_object__size(int type) {
        var mh$ = git_object__size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_object__size", type);
            }
            return (long)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_is_valid_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_is_valid_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_is_valid_name(const char *remote_name)
     * }
     */
    public static FunctionDescriptor git_remote_is_valid_name$descriptor() {
        return git_remote_is_valid_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_is_valid_name(const char *remote_name)
     * }
     */
    public static MethodHandle git_remote_is_valid_name$handle() {
        return git_remote_is_valid_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_is_valid_name(const char *remote_name)
     * }
     */
    public static MemorySegment git_remote_is_valid_name$address() {
        return git_remote_is_valid_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_is_valid_name(const char *remote_name)
     * }
     */
    public static int git_remote_is_valid_name(MemorySegment remote_name) {
        var mh$ = git_remote_is_valid_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_is_valid_name", remote_name);
            }
            return (int)mh$.invokeExact(remote_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reference_is_valid_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reference_is_valid_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reference_is_valid_name(const char *refname)
     * }
     */
    public static FunctionDescriptor git_reference_is_valid_name$descriptor() {
        return git_reference_is_valid_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reference_is_valid_name(const char *refname)
     * }
     */
    public static MethodHandle git_reference_is_valid_name$handle() {
        return git_reference_is_valid_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reference_is_valid_name(const char *refname)
     * }
     */
    public static MemorySegment git_reference_is_valid_name$address() {
        return git_reference_is_valid_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reference_is_valid_name(const char *refname)
     * }
     */
    public static int git_reference_is_valid_name(MemorySegment refname) {
        var mh$ = git_reference_is_valid_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reference_is_valid_name", refname);
            }
            return (int)mh$.invokeExact(refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_create_frombuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_create_frombuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_create_frombuffer(git_oid *oid, git_repository *repo, const char *buffer, int force)
     * }
     */
    public static FunctionDescriptor git_tag_create_frombuffer$descriptor() {
        return git_tag_create_frombuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_create_frombuffer(git_oid *oid, git_repository *repo, const char *buffer, int force)
     * }
     */
    public static MethodHandle git_tag_create_frombuffer$handle() {
        return git_tag_create_frombuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_create_frombuffer(git_oid *oid, git_repository *repo, const char *buffer, int force)
     * }
     */
    public static MemorySegment git_tag_create_frombuffer$address() {
        return git_tag_create_frombuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_create_frombuffer(git_oid *oid, git_repository *repo, const char *buffer, int force)
     * }
     */
    public static int git_tag_create_frombuffer(MemorySegment oid, MemorySegment repo, MemorySegment buffer, int force) {
        var mh$ = git_tag_create_frombuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_create_frombuffer", oid, repo, buffer, force);
            }
            return (int)mh$.invokeExact(oid, repo, buffer, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_cred_free(git_credential *cred)
     * }
     */
    public static FunctionDescriptor git_cred_free$descriptor() {
        return git_cred_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_cred_free(git_credential *cred)
     * }
     */
    public static MethodHandle git_cred_free$handle() {
        return git_cred_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_cred_free(git_credential *cred)
     * }
     */
    public static MemorySegment git_cred_free$address() {
        return git_cred_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_cred_free(git_credential *cred)
     * }
     */
    public static void git_cred_free(MemorySegment cred) {
        var mh$ = git_cred_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_free", cred);
            }
            mh$.invokeExact(cred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_has_username {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_has_username");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cred_has_username(git_credential *cred)
     * }
     */
    public static FunctionDescriptor git_cred_has_username$descriptor() {
        return git_cred_has_username.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cred_has_username(git_credential *cred)
     * }
     */
    public static MethodHandle git_cred_has_username$handle() {
        return git_cred_has_username.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cred_has_username(git_credential *cred)
     * }
     */
    public static MemorySegment git_cred_has_username$address() {
        return git_cred_has_username.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cred_has_username(git_credential *cred)
     * }
     */
    public static int git_cred_has_username(MemorySegment cred) {
        var mh$ = git_cred_has_username.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_has_username", cred);
            }
            return (int)mh$.invokeExact(cred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_get_username {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_get_username");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_cred_get_username(git_credential *cred)
     * }
     */
    public static FunctionDescriptor git_cred_get_username$descriptor() {
        return git_cred_get_username.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_cred_get_username(git_credential *cred)
     * }
     */
    public static MethodHandle git_cred_get_username$handle() {
        return git_cred_get_username.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_cred_get_username(git_credential *cred)
     * }
     */
    public static MemorySegment git_cred_get_username$address() {
        return git_cred_get_username.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_cred_get_username(git_credential *cred)
     * }
     */
    public static MemorySegment git_cred_get_username(MemorySegment cred) {
        var mh$ = git_cred_get_username.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_get_username", cred);
            }
            return (MemorySegment)mh$.invokeExact(cred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_userpass_plaintext_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_userpass_plaintext_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cred_userpass_plaintext_new(git_credential **out, const char *username, const char *password)
     * }
     */
    public static FunctionDescriptor git_cred_userpass_plaintext_new$descriptor() {
        return git_cred_userpass_plaintext_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cred_userpass_plaintext_new(git_credential **out, const char *username, const char *password)
     * }
     */
    public static MethodHandle git_cred_userpass_plaintext_new$handle() {
        return git_cred_userpass_plaintext_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cred_userpass_plaintext_new(git_credential **out, const char *username, const char *password)
     * }
     */
    public static MemorySegment git_cred_userpass_plaintext_new$address() {
        return git_cred_userpass_plaintext_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cred_userpass_plaintext_new(git_credential **out, const char *username, const char *password)
     * }
     */
    public static int git_cred_userpass_plaintext_new(MemorySegment out, MemorySegment username, MemorySegment password) {
        var mh$ = git_cred_userpass_plaintext_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_userpass_plaintext_new", out, username, password);
            }
            return (int)mh$.invokeExact(out, username, password);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_default_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_default_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cred_default_new(git_credential **out)
     * }
     */
    public static FunctionDescriptor git_cred_default_new$descriptor() {
        return git_cred_default_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cred_default_new(git_credential **out)
     * }
     */
    public static MethodHandle git_cred_default_new$handle() {
        return git_cred_default_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cred_default_new(git_credential **out)
     * }
     */
    public static MemorySegment git_cred_default_new$address() {
        return git_cred_default_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cred_default_new(git_credential **out)
     * }
     */
    public static int git_cred_default_new(MemorySegment out) {
        var mh$ = git_cred_default_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_default_new", out);
            }
            return (int)mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_username_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_username_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cred_username_new(git_credential **out, const char *username)
     * }
     */
    public static FunctionDescriptor git_cred_username_new$descriptor() {
        return git_cred_username_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cred_username_new(git_credential **out, const char *username)
     * }
     */
    public static MethodHandle git_cred_username_new$handle() {
        return git_cred_username_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cred_username_new(git_credential **out, const char *username)
     * }
     */
    public static MemorySegment git_cred_username_new$address() {
        return git_cred_username_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cred_username_new(git_credential **out, const char *username)
     * }
     */
    public static int git_cred_username_new(MemorySegment out, MemorySegment username) {
        var mh$ = git_cred_username_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_username_new", out, username);
            }
            return (int)mh$.invokeExact(out, username);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_ssh_key_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_ssh_key_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static FunctionDescriptor git_cred_ssh_key_new$descriptor() {
        return git_cred_ssh_key_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static MethodHandle git_cred_ssh_key_new$handle() {
        return git_cred_ssh_key_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static MemorySegment git_cred_ssh_key_new$address() {
        return git_cred_ssh_key_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static int git_cred_ssh_key_new(MemorySegment out, MemorySegment username, MemorySegment publickey, MemorySegment privatekey, MemorySegment passphrase) {
        var mh$ = git_cred_ssh_key_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_ssh_key_new", out, username, publickey, privatekey, passphrase);
            }
            return (int)mh$.invokeExact(out, username, publickey, privatekey, passphrase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_ssh_key_memory_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_ssh_key_memory_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_memory_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static FunctionDescriptor git_cred_ssh_key_memory_new$descriptor() {
        return git_cred_ssh_key_memory_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_memory_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static MethodHandle git_cred_ssh_key_memory_new$handle() {
        return git_cred_ssh_key_memory_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_memory_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static MemorySegment git_cred_ssh_key_memory_new$address() {
        return git_cred_ssh_key_memory_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_memory_new(git_credential **out, const char *username, const char *publickey, const char *privatekey, const char *passphrase)
     * }
     */
    public static int git_cred_ssh_key_memory_new(MemorySegment out, MemorySegment username, MemorySegment publickey, MemorySegment privatekey, MemorySegment passphrase) {
        var mh$ = git_cred_ssh_key_memory_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_ssh_key_memory_new", out, username, publickey, privatekey, passphrase);
            }
            return (int)mh$.invokeExact(out, username, publickey, privatekey, passphrase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_ssh_interactive_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_ssh_interactive_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_interactive_new(git_credential **out, const char *username, git_credential_ssh_interactive_cb prompt_callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_cred_ssh_interactive_new$descriptor() {
        return git_cred_ssh_interactive_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_interactive_new(git_credential **out, const char *username, git_credential_ssh_interactive_cb prompt_callback, void *payload)
     * }
     */
    public static MethodHandle git_cred_ssh_interactive_new$handle() {
        return git_cred_ssh_interactive_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_interactive_new(git_credential **out, const char *username, git_credential_ssh_interactive_cb prompt_callback, void *payload)
     * }
     */
    public static MemorySegment git_cred_ssh_interactive_new$address() {
        return git_cred_ssh_interactive_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cred_ssh_interactive_new(git_credential **out, const char *username, git_credential_ssh_interactive_cb prompt_callback, void *payload)
     * }
     */
    public static int git_cred_ssh_interactive_new(MemorySegment out, MemorySegment username, MemorySegment prompt_callback, MemorySegment payload) {
        var mh$ = git_cred_ssh_interactive_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_ssh_interactive_new", out, username, prompt_callback, payload);
            }
            return (int)mh$.invokeExact(out, username, prompt_callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_ssh_key_from_agent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_ssh_key_from_agent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_from_agent(git_credential **out, const char *username)
     * }
     */
    public static FunctionDescriptor git_cred_ssh_key_from_agent$descriptor() {
        return git_cred_ssh_key_from_agent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_from_agent(git_credential **out, const char *username)
     * }
     */
    public static MethodHandle git_cred_ssh_key_from_agent$handle() {
        return git_cred_ssh_key_from_agent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_from_agent(git_credential **out, const char *username)
     * }
     */
    public static MemorySegment git_cred_ssh_key_from_agent$address() {
        return git_cred_ssh_key_from_agent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cred_ssh_key_from_agent(git_credential **out, const char *username)
     * }
     */
    public static int git_cred_ssh_key_from_agent(MemorySegment out, MemorySegment username) {
        var mh$ = git_cred_ssh_key_from_agent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_ssh_key_from_agent", out, username);
            }
            return (int)mh$.invokeExact(out, username);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_ssh_custom_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_ssh_custom_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_custom_new(git_credential **out, const char *username, const char *publickey, size_t publickey_len, git_credential_sign_cb sign_callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_cred_ssh_custom_new$descriptor() {
        return git_cred_ssh_custom_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_custom_new(git_credential **out, const char *username, const char *publickey, size_t publickey_len, git_credential_sign_cb sign_callback, void *payload)
     * }
     */
    public static MethodHandle git_cred_ssh_custom_new$handle() {
        return git_cred_ssh_custom_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cred_ssh_custom_new(git_credential **out, const char *username, const char *publickey, size_t publickey_len, git_credential_sign_cb sign_callback, void *payload)
     * }
     */
    public static MemorySegment git_cred_ssh_custom_new$address() {
        return git_cred_ssh_custom_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cred_ssh_custom_new(git_credential **out, const char *username, const char *publickey, size_t publickey_len, git_credential_sign_cb sign_callback, void *payload)
     * }
     */
    public static int git_cred_ssh_custom_new(MemorySegment out, MemorySegment username, MemorySegment publickey, long publickey_len, MemorySegment sign_callback, MemorySegment payload) {
        var mh$ = git_cred_ssh_custom_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_ssh_custom_new", out, username, publickey, publickey_len, sign_callback, payload);
            }
            return (int)mh$.invokeExact(out, username, publickey, publickey_len, sign_callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cred_userpass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cred_userpass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cred_userpass(git_credential **out, const char *url, const char *user_from_url, unsigned int allowed_types, void *payload)
     * }
     */
    public static FunctionDescriptor git_cred_userpass$descriptor() {
        return git_cred_userpass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cred_userpass(git_credential **out, const char *url, const char *user_from_url, unsigned int allowed_types, void *payload)
     * }
     */
    public static MethodHandle git_cred_userpass$handle() {
        return git_cred_userpass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cred_userpass(git_credential **out, const char *url, const char *user_from_url, unsigned int allowed_types, void *payload)
     * }
     */
    public static MemorySegment git_cred_userpass$address() {
        return git_cred_userpass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cred_userpass(git_credential **out, const char *url, const char *user_from_url, unsigned int allowed_types, void *payload)
     * }
     */
    public static int git_cred_userpass(MemorySegment out, MemorySegment url, MemorySegment user_from_url, int allowed_types, MemorySegment payload) {
        var mh$ = git_cred_userpass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cred_userpass", out, url, user_from_url, allowed_types, payload);
            }
            return (int)mh$.invokeExact(out, url, user_from_url, allowed_types, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oid_iszero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oid_iszero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_oid_iszero(const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_oid_iszero$descriptor() {
        return git_oid_iszero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_oid_iszero(const git_oid *id)
     * }
     */
    public static MethodHandle git_oid_iszero$handle() {
        return git_oid_iszero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_oid_iszero(const git_oid *id)
     * }
     */
    public static MemorySegment git_oid_iszero$address() {
        return git_oid_iszero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_oid_iszero(const git_oid *id)
     * }
     */
    public static int git_oid_iszero(MemorySegment id) {
        var mh$ = git_oid_iszero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oid_iszero", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_oidarray_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_oidarray_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_oidarray_free(git_oidarray *array)
     * }
     */
    public static FunctionDescriptor git_oidarray_free$descriptor() {
        return git_oidarray_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_oidarray_free(git_oidarray *array)
     * }
     */
    public static MethodHandle git_oidarray_free$handle() {
        return git_oidarray_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_oidarray_free(git_oidarray *array)
     * }
     */
    public static MemorySegment git_oidarray_free$address() {
        return git_oidarray_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_oidarray_free(git_oidarray *array)
     * }
     */
    public static void git_oidarray_free(MemorySegment array) {
        var mh$ = git_oidarray_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_oidarray_free", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_strarray_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_strarray_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_strarray_copy(git_strarray *tgt, const git_strarray *src)
     * }
     */
    public static FunctionDescriptor git_strarray_copy$descriptor() {
        return git_strarray_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_strarray_copy(git_strarray *tgt, const git_strarray *src)
     * }
     */
    public static MethodHandle git_strarray_copy$handle() {
        return git_strarray_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_strarray_copy(git_strarray *tgt, const git_strarray *src)
     * }
     */
    public static MemorySegment git_strarray_copy$address() {
        return git_strarray_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_strarray_copy(git_strarray *tgt, const git_strarray *src)
     * }
     */
    public static int git_strarray_copy(MemorySegment tgt, MemorySegment src) {
        var mh$ = git_strarray_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_strarray_copy", tgt, src);
            }
            return (int)mh$.invokeExact(tgt, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_strarray_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_strarray_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_strarray_free(git_strarray *array)
     * }
     */
    public static FunctionDescriptor git_strarray_free$descriptor() {
        return git_strarray_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_strarray_free(git_strarray *array)
     * }
     */
    public static MethodHandle git_strarray_free$handle() {
        return git_strarray_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_strarray_free(git_strarray *array)
     * }
     */
    public static MemorySegment git_strarray_free$address() {
        return git_strarray_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_strarray_free(git_strarray *array)
     * }
     */
    public static void git_strarray_free(MemorySegment array) {
        var mh$ = git_strarray_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_strarray_free", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_blame_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_blame_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_blame_init_options(git_blame_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_blame_init_options$descriptor() {
        return git_blame_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_blame_init_options(git_blame_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_blame_init_options$handle() {
        return git_blame_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_blame_init_options(git_blame_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_blame_init_options$address() {
        return git_blame_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_blame_init_options(git_blame_options *opts, unsigned int version)
     * }
     */
    public static int git_blame_init_options(MemorySegment opts, int version) {
        var mh$ = git_blame_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_blame_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_checkout_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_checkout_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_checkout_init_options(git_checkout_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_checkout_init_options$descriptor() {
        return git_checkout_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_checkout_init_options(git_checkout_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_checkout_init_options$handle() {
        return git_checkout_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_checkout_init_options(git_checkout_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_checkout_init_options$address() {
        return git_checkout_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_checkout_init_options(git_checkout_options *opts, unsigned int version)
     * }
     */
    public static int git_checkout_init_options(MemorySegment opts, int version) {
        var mh$ = git_checkout_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_checkout_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_cherrypick_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_cherrypick_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_cherrypick_init_options(git_cherrypick_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_cherrypick_init_options$descriptor() {
        return git_cherrypick_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_cherrypick_init_options(git_cherrypick_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_cherrypick_init_options$handle() {
        return git_cherrypick_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_cherrypick_init_options(git_cherrypick_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_cherrypick_init_options$address() {
        return git_cherrypick_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_cherrypick_init_options(git_cherrypick_options *opts, unsigned int version)
     * }
     */
    public static int git_cherrypick_init_options(MemorySegment opts, int version) {
        var mh$ = git_cherrypick_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_cherrypick_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_clone_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_clone_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_clone_init_options(git_clone_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_clone_init_options$descriptor() {
        return git_clone_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_clone_init_options(git_clone_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_clone_init_options$handle() {
        return git_clone_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_clone_init_options(git_clone_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_clone_init_options$address() {
        return git_clone_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_clone_init_options(git_clone_options *opts, unsigned int version)
     * }
     */
    public static int git_clone_init_options(MemorySegment opts, int version) {
        var mh$ = git_clone_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_clone_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_describe_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_describe_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_describe_init_options(git_describe_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_describe_init_options$descriptor() {
        return git_describe_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_describe_init_options(git_describe_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_describe_init_options$handle() {
        return git_describe_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_describe_init_options(git_describe_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_describe_init_options$address() {
        return git_describe_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_describe_init_options(git_describe_options *opts, unsigned int version)
     * }
     */
    public static int git_describe_init_options(MemorySegment opts, int version) {
        var mh$ = git_describe_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_describe_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_describe_init_format_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_describe_init_format_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_describe_init_format_options(git_describe_format_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_describe_init_format_options$descriptor() {
        return git_describe_init_format_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_describe_init_format_options(git_describe_format_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_describe_init_format_options$handle() {
        return git_describe_init_format_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_describe_init_format_options(git_describe_format_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_describe_init_format_options$address() {
        return git_describe_init_format_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_describe_init_format_options(git_describe_format_options *opts, unsigned int version)
     * }
     */
    public static int git_describe_init_format_options(MemorySegment opts, int version) {
        var mh$ = git_describe_init_format_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_describe_init_format_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_init_options(git_diff_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_diff_init_options$descriptor() {
        return git_diff_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_init_options(git_diff_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_diff_init_options$handle() {
        return git_diff_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_init_options(git_diff_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_diff_init_options$address() {
        return git_diff_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_init_options(git_diff_options *opts, unsigned int version)
     * }
     */
    public static int git_diff_init_options(MemorySegment opts, int version) {
        var mh$ = git_diff_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_find_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_find_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_find_init_options(git_diff_find_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_diff_find_init_options$descriptor() {
        return git_diff_find_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_find_init_options(git_diff_find_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_diff_find_init_options$handle() {
        return git_diff_find_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_find_init_options(git_diff_find_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_diff_find_init_options$address() {
        return git_diff_find_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_find_init_options(git_diff_find_options *opts, unsigned int version)
     * }
     */
    public static int git_diff_find_init_options(MemorySegment opts, int version) {
        var mh$ = git_diff_find_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_find_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_format_email_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_format_email_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_format_email_init_options(git_diff_format_email_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_diff_format_email_init_options$descriptor() {
        return git_diff_format_email_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_format_email_init_options(git_diff_format_email_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_diff_format_email_init_options$handle() {
        return git_diff_format_email_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_format_email_init_options(git_diff_format_email_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_diff_format_email_init_options$address() {
        return git_diff_format_email_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_format_email_init_options(git_diff_format_email_options *opts, unsigned int version)
     * }
     */
    public static int git_diff_format_email_init_options(MemorySegment opts, int version) {
        var mh$ = git_diff_format_email_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_format_email_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_diff_patchid_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_diff_patchid_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_diff_patchid_init_options(git_diff_patchid_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_diff_patchid_init_options$descriptor() {
        return git_diff_patchid_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_diff_patchid_init_options(git_diff_patchid_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_diff_patchid_init_options$handle() {
        return git_diff_patchid_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_diff_patchid_init_options(git_diff_patchid_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_diff_patchid_init_options$address() {
        return git_diff_patchid_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_diff_patchid_init_options(git_diff_patchid_options *opts, unsigned int version)
     * }
     */
    public static int git_diff_patchid_init_options(MemorySegment opts, int version) {
        var mh$ = git_diff_patchid_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_diff_patchid_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_fetch_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_fetch_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_fetch_init_options(git_fetch_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_fetch_init_options$descriptor() {
        return git_fetch_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_fetch_init_options(git_fetch_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_fetch_init_options$handle() {
        return git_fetch_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_fetch_init_options(git_fetch_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_fetch_init_options$address() {
        return git_fetch_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_fetch_init_options(git_fetch_options *opts, unsigned int version)
     * }
     */
    public static int git_fetch_init_options(MemorySegment opts, int version) {
        var mh$ = git_fetch_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_fetch_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_indexer_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_indexer_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_indexer_init_options(git_indexer_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_indexer_init_options$descriptor() {
        return git_indexer_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_indexer_init_options(git_indexer_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_indexer_init_options$handle() {
        return git_indexer_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_indexer_init_options(git_indexer_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_indexer_init_options$address() {
        return git_indexer_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_indexer_init_options(git_indexer_options *opts, unsigned int version)
     * }
     */
    public static int git_indexer_init_options(MemorySegment opts, int version) {
        var mh$ = git_indexer_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_indexer_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_init_options(git_merge_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_merge_init_options$descriptor() {
        return git_merge_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_init_options(git_merge_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_merge_init_options$handle() {
        return git_merge_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_init_options(git_merge_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_merge_init_options$address() {
        return git_merge_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_init_options(git_merge_options *opts, unsigned int version)
     * }
     */
    public static int git_merge_init_options(MemorySegment opts, int version) {
        var mh$ = git_merge_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_file_init_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_file_init_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_file_init_input(git_merge_file_input *input, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_merge_file_init_input$descriptor() {
        return git_merge_file_init_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_file_init_input(git_merge_file_input *input, unsigned int version)
     * }
     */
    public static MethodHandle git_merge_file_init_input$handle() {
        return git_merge_file_init_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_file_init_input(git_merge_file_input *input, unsigned int version)
     * }
     */
    public static MemorySegment git_merge_file_init_input$address() {
        return git_merge_file_init_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_file_init_input(git_merge_file_input *input, unsigned int version)
     * }
     */
    public static int git_merge_file_init_input(MemorySegment input, int version) {
        var mh$ = git_merge_file_init_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_file_init_input", input, version);
            }
            return (int)mh$.invokeExact(input, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_merge_file_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_merge_file_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_merge_file_init_options(git_merge_file_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_merge_file_init_options$descriptor() {
        return git_merge_file_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_merge_file_init_options(git_merge_file_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_merge_file_init_options$handle() {
        return git_merge_file_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_merge_file_init_options(git_merge_file_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_merge_file_init_options$address() {
        return git_merge_file_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_merge_file_init_options(git_merge_file_options *opts, unsigned int version)
     * }
     */
    public static int git_merge_file_init_options(MemorySegment opts, int version) {
        var mh$ = git_merge_file_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_merge_file_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_proxy_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_proxy_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_proxy_init_options(git_proxy_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_proxy_init_options$descriptor() {
        return git_proxy_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_proxy_init_options(git_proxy_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_proxy_init_options$handle() {
        return git_proxy_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_proxy_init_options(git_proxy_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_proxy_init_options$address() {
        return git_proxy_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_proxy_init_options(git_proxy_options *opts, unsigned int version)
     * }
     */
    public static int git_proxy_init_options(MemorySegment opts, int version) {
        var mh$ = git_proxy_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_proxy_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_push_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_push_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_push_init_options(git_push_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_push_init_options$descriptor() {
        return git_push_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_push_init_options(git_push_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_push_init_options$handle() {
        return git_push_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_push_init_options(git_push_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_push_init_options$address() {
        return git_push_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_push_init_options(git_push_options *opts, unsigned int version)
     * }
     */
    public static int git_push_init_options(MemorySegment opts, int version) {
        var mh$ = git_push_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_push_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_rebase_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_rebase_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_rebase_init_options(git_rebase_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_rebase_init_options$descriptor() {
        return git_rebase_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_rebase_init_options(git_rebase_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_rebase_init_options$handle() {
        return git_rebase_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_rebase_init_options(git_rebase_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_rebase_init_options$address() {
        return git_rebase_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_rebase_init_options(git_rebase_options *opts, unsigned int version)
     * }
     */
    public static int git_rebase_init_options(MemorySegment opts, int version) {
        var mh$ = git_rebase_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_rebase_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_remote_create_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_remote_create_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_remote_create_init_options(git_remote_create_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_remote_create_init_options$descriptor() {
        return git_remote_create_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_remote_create_init_options(git_remote_create_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_remote_create_init_options$handle() {
        return git_remote_create_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_remote_create_init_options(git_remote_create_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_remote_create_init_options$address() {
        return git_remote_create_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_remote_create_init_options(git_remote_create_options *opts, unsigned int version)
     * }
     */
    public static int git_remote_create_init_options(MemorySegment opts, int version) {
        var mh$ = git_remote_create_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_remote_create_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_repository_init_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_repository_init_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_repository_init_init_options(git_repository_init_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_repository_init_init_options$descriptor() {
        return git_repository_init_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_repository_init_init_options(git_repository_init_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_repository_init_init_options$handle() {
        return git_repository_init_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_repository_init_init_options(git_repository_init_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_repository_init_init_options$address() {
        return git_repository_init_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_repository_init_init_options(git_repository_init_options *opts, unsigned int version)
     * }
     */
    public static int git_repository_init_init_options(MemorySegment opts, int version) {
        var mh$ = git_repository_init_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_repository_init_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revert_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revert_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revert_init_options(git_revert_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_revert_init_options$descriptor() {
        return git_revert_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revert_init_options(git_revert_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_revert_init_options$handle() {
        return git_revert_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revert_init_options(git_revert_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_revert_init_options$address() {
        return git_revert_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revert_init_options(git_revert_options *opts, unsigned int version)
     * }
     */
    public static int git_revert_init_options(MemorySegment opts, int version) {
        var mh$ = git_revert_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revert_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_stash_apply_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_stash_apply_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_stash_apply_init_options(git_stash_apply_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_stash_apply_init_options$descriptor() {
        return git_stash_apply_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_stash_apply_init_options(git_stash_apply_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_stash_apply_init_options$handle() {
        return git_stash_apply_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_stash_apply_init_options(git_stash_apply_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_stash_apply_init_options$address() {
        return git_stash_apply_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_stash_apply_init_options(git_stash_apply_options *opts, unsigned int version)
     * }
     */
    public static int git_stash_apply_init_options(MemorySegment opts, int version) {
        var mh$ = git_stash_apply_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_stash_apply_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_status_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_status_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_status_init_options(git_status_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_status_init_options$descriptor() {
        return git_status_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_status_init_options(git_status_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_status_init_options$handle() {
        return git_status_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_status_init_options(git_status_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_status_init_options$address() {
        return git_status_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_status_init_options(git_status_options *opts, unsigned int version)
     * }
     */
    public static int git_status_init_options(MemorySegment opts, int version) {
        var mh$ = git_status_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_status_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_submodule_update_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_submodule_update_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_submodule_update_init_options(git_submodule_update_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_submodule_update_init_options$descriptor() {
        return git_submodule_update_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_submodule_update_init_options(git_submodule_update_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_submodule_update_init_options$handle() {
        return git_submodule_update_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_submodule_update_init_options(git_submodule_update_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_submodule_update_init_options$address() {
        return git_submodule_update_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_submodule_update_init_options(git_submodule_update_options *opts, unsigned int version)
     * }
     */
    public static int git_submodule_update_init_options(MemorySegment opts, int version) {
        var mh$ = git_submodule_update_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_submodule_update_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_add_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_add_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_add_init_options(git_worktree_add_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_worktree_add_init_options$descriptor() {
        return git_worktree_add_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_add_init_options(git_worktree_add_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_worktree_add_init_options$handle() {
        return git_worktree_add_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_add_init_options(git_worktree_add_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_worktree_add_init_options$address() {
        return git_worktree_add_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_add_init_options(git_worktree_add_options *opts, unsigned int version)
     * }
     */
    public static int git_worktree_add_init_options(MemorySegment opts, int version) {
        var mh$ = git_worktree_add_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_add_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_worktree_prune_init_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_worktree_prune_init_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_worktree_prune_init_options(git_worktree_prune_options *opts, unsigned int version)
     * }
     */
    public static FunctionDescriptor git_worktree_prune_init_options$descriptor() {
        return git_worktree_prune_init_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_worktree_prune_init_options(git_worktree_prune_options *opts, unsigned int version)
     * }
     */
    public static MethodHandle git_worktree_prune_init_options$handle() {
        return git_worktree_prune_init_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_worktree_prune_init_options(git_worktree_prune_options *opts, unsigned int version)
     * }
     */
    public static MemorySegment git_worktree_prune_init_options$address() {
        return git_worktree_prune_init_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_worktree_prune_init_options(git_worktree_prune_options *opts, unsigned int version)
     * }
     */
    public static int git_worktree_prune_init_options(MemorySegment opts, int version) {
        var mh$ = git_worktree_prune_init_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_worktree_prune_init_options", opts, version);
            }
            return (int)mh$.invokeExact(opts, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_EMAIL_CREATE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EMAIL_CREATE_DEFAULT = 0
     * }
     */
    public static int GIT_EMAIL_CREATE_DEFAULT() {
        return GIT_EMAIL_CREATE_DEFAULT;
    }
    private static final int GIT_EMAIL_CREATE_OMIT_NUMBERS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EMAIL_CREATE_OMIT_NUMBERS = 1
     * }
     */
    public static int GIT_EMAIL_CREATE_OMIT_NUMBERS() {
        return GIT_EMAIL_CREATE_OMIT_NUMBERS;
    }
    private static final int GIT_EMAIL_CREATE_ALWAYS_NUMBER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EMAIL_CREATE_ALWAYS_NUMBER = 2
     * }
     */
    public static int GIT_EMAIL_CREATE_ALWAYS_NUMBER() {
        return GIT_EMAIL_CREATE_ALWAYS_NUMBER;
    }
    private static final int GIT_EMAIL_CREATE_NO_RENAMES = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_EMAIL_CREATE_NO_RENAMES = 4
     * }
     */
    public static int GIT_EMAIL_CREATE_NO_RENAMES() {
        return GIT_EMAIL_CREATE_NO_RENAMES;
    }

    private static class git_email_create_from_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_email_create_from_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_email_create_from_commit(git_buf *out, git_commit *commit, const git_email_create_options *opts)
     * }
     */
    public static FunctionDescriptor git_email_create_from_commit$descriptor() {
        return git_email_create_from_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_email_create_from_commit(git_buf *out, git_commit *commit, const git_email_create_options *opts)
     * }
     */
    public static MethodHandle git_email_create_from_commit$handle() {
        return git_email_create_from_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_email_create_from_commit(git_buf *out, git_commit *commit, const git_email_create_options *opts)
     * }
     */
    public static MemorySegment git_email_create_from_commit$address() {
        return git_email_create_from_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_email_create_from_commit(git_buf *out, git_commit *commit, const git_email_create_options *opts)
     * }
     */
    public static int git_email_create_from_commit(MemorySegment out, MemorySegment commit, MemorySegment opts) {
        var mh$ = git_email_create_from_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_email_create_from_commit", out, commit, opts);
            }
            return (int)mh$.invokeExact(out, commit, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_libgit2_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT    );

        public static final MemorySegment ADDR = git2.findOrThrow("git_libgit2_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_libgit2_init()
     * }
     */
    public static FunctionDescriptor git_libgit2_init$descriptor() {
        return git_libgit2_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_libgit2_init()
     * }
     */
    public static MethodHandle git_libgit2_init$handle() {
        return git_libgit2_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_libgit2_init()
     * }
     */
    public static MemorySegment git_libgit2_init$address() {
        return git_libgit2_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_libgit2_init()
     * }
     */
    public static int git_libgit2_init() {
        var mh$ = git_libgit2_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_libgit2_init");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_libgit2_shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT    );

        public static final MemorySegment ADDR = git2.findOrThrow("git_libgit2_shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_libgit2_shutdown()
     * }
     */
    public static FunctionDescriptor git_libgit2_shutdown$descriptor() {
        return git_libgit2_shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_libgit2_shutdown()
     * }
     */
    public static MethodHandle git_libgit2_shutdown$handle() {
        return git_libgit2_shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_libgit2_shutdown()
     * }
     */
    public static MemorySegment git_libgit2_shutdown$address() {
        return git_libgit2_shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_libgit2_shutdown()
     * }
     */
    public static int git_libgit2_shutdown() {
        var mh$ = git_libgit2_shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_libgit2_shutdown");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_graph_ahead_behind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_graph_ahead_behind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_graph_ahead_behind(size_t *ahead, size_t *behind, git_repository *repo, const git_oid *local, const git_oid *upstream)
     * }
     */
    public static FunctionDescriptor git_graph_ahead_behind$descriptor() {
        return git_graph_ahead_behind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_graph_ahead_behind(size_t *ahead, size_t *behind, git_repository *repo, const git_oid *local, const git_oid *upstream)
     * }
     */
    public static MethodHandle git_graph_ahead_behind$handle() {
        return git_graph_ahead_behind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_graph_ahead_behind(size_t *ahead, size_t *behind, git_repository *repo, const git_oid *local, const git_oid *upstream)
     * }
     */
    public static MemorySegment git_graph_ahead_behind$address() {
        return git_graph_ahead_behind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_graph_ahead_behind(size_t *ahead, size_t *behind, git_repository *repo, const git_oid *local, const git_oid *upstream)
     * }
     */
    public static int git_graph_ahead_behind(MemorySegment ahead, MemorySegment behind, MemorySegment repo, MemorySegment local, MemorySegment upstream) {
        var mh$ = git_graph_ahead_behind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_graph_ahead_behind", ahead, behind, repo, local, upstream);
            }
            return (int)mh$.invokeExact(ahead, behind, repo, local, upstream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_graph_descendant_of {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_graph_descendant_of");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_graph_descendant_of(git_repository *repo, const git_oid *commit, const git_oid *ancestor)
     * }
     */
    public static FunctionDescriptor git_graph_descendant_of$descriptor() {
        return git_graph_descendant_of.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_graph_descendant_of(git_repository *repo, const git_oid *commit, const git_oid *ancestor)
     * }
     */
    public static MethodHandle git_graph_descendant_of$handle() {
        return git_graph_descendant_of.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_graph_descendant_of(git_repository *repo, const git_oid *commit, const git_oid *ancestor)
     * }
     */
    public static MemorySegment git_graph_descendant_of$address() {
        return git_graph_descendant_of.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_graph_descendant_of(git_repository *repo, const git_oid *commit, const git_oid *ancestor)
     * }
     */
    public static int git_graph_descendant_of(MemorySegment repo, MemorySegment commit, MemorySegment ancestor) {
        var mh$ = git_graph_descendant_of.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_graph_descendant_of", repo, commit, ancestor);
            }
            return (int)mh$.invokeExact(repo, commit, ancestor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_graph_reachable_from_any {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_graph_reachable_from_any");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_graph_reachable_from_any(git_repository *repo, const git_oid *commit, const git_oid descendant_array[], size_t length)
     * }
     */
    public static FunctionDescriptor git_graph_reachable_from_any$descriptor() {
        return git_graph_reachable_from_any.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_graph_reachable_from_any(git_repository *repo, const git_oid *commit, const git_oid descendant_array[], size_t length)
     * }
     */
    public static MethodHandle git_graph_reachable_from_any$handle() {
        return git_graph_reachable_from_any.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_graph_reachable_from_any(git_repository *repo, const git_oid *commit, const git_oid descendant_array[], size_t length)
     * }
     */
    public static MemorySegment git_graph_reachable_from_any$address() {
        return git_graph_reachable_from_any.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_graph_reachable_from_any(git_repository *repo, const git_oid *commit, const git_oid descendant_array[], size_t length)
     * }
     */
    public static int git_graph_reachable_from_any(MemorySegment repo, MemorySegment commit, MemorySegment descendant_array, long length) {
        var mh$ = git_graph_reachable_from_any.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_graph_reachable_from_any", repo, commit, descendant_array, length);
            }
            return (int)mh$.invokeExact(repo, commit, descendant_array, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_ignore_add_rule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_ignore_add_rule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_ignore_add_rule(git_repository *repo, const char *rules)
     * }
     */
    public static FunctionDescriptor git_ignore_add_rule$descriptor() {
        return git_ignore_add_rule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_ignore_add_rule(git_repository *repo, const char *rules)
     * }
     */
    public static MethodHandle git_ignore_add_rule$handle() {
        return git_ignore_add_rule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_ignore_add_rule(git_repository *repo, const char *rules)
     * }
     */
    public static MemorySegment git_ignore_add_rule$address() {
        return git_ignore_add_rule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_ignore_add_rule(git_repository *repo, const char *rules)
     * }
     */
    public static int git_ignore_add_rule(MemorySegment repo, MemorySegment rules) {
        var mh$ = git_ignore_add_rule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_ignore_add_rule", repo, rules);
            }
            return (int)mh$.invokeExact(repo, rules);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_ignore_clear_internal_rules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_ignore_clear_internal_rules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_ignore_clear_internal_rules(git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_ignore_clear_internal_rules$descriptor() {
        return git_ignore_clear_internal_rules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_ignore_clear_internal_rules(git_repository *repo)
     * }
     */
    public static MethodHandle git_ignore_clear_internal_rules$handle() {
        return git_ignore_clear_internal_rules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_ignore_clear_internal_rules(git_repository *repo)
     * }
     */
    public static MemorySegment git_ignore_clear_internal_rules$address() {
        return git_ignore_clear_internal_rules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_ignore_clear_internal_rules(git_repository *repo)
     * }
     */
    public static int git_ignore_clear_internal_rules(MemorySegment repo) {
        var mh$ = git_ignore_clear_internal_rules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_ignore_clear_internal_rules", repo);
            }
            return (int)mh$.invokeExact(repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_ignore_path_is_ignored {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_ignore_path_is_ignored");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_ignore_path_is_ignored(int *ignored, git_repository *repo, const char *path)
     * }
     */
    public static FunctionDescriptor git_ignore_path_is_ignored$descriptor() {
        return git_ignore_path_is_ignored.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_ignore_path_is_ignored(int *ignored, git_repository *repo, const char *path)
     * }
     */
    public static MethodHandle git_ignore_path_is_ignored$handle() {
        return git_ignore_path_is_ignored.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_ignore_path_is_ignored(int *ignored, git_repository *repo, const char *path)
     * }
     */
    public static MemorySegment git_ignore_path_is_ignored$address() {
        return git_ignore_path_is_ignored.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_ignore_path_is_ignored(int *ignored, git_repository *repo, const char *path)
     * }
     */
    public static int git_ignore_path_is_ignored(MemorySegment ignored, MemorySegment repo, MemorySegment path) {
        var mh$ = git_ignore_path_is_ignored.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_ignore_path_is_ignored", ignored, repo, path);
            }
            return (int)mh$.invokeExact(ignored, repo, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_mailmap_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_mailmap_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_mailmap_new(git_mailmap **out)
     * }
     */
    public static FunctionDescriptor git_mailmap_new$descriptor() {
        return git_mailmap_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_mailmap_new(git_mailmap **out)
     * }
     */
    public static MethodHandle git_mailmap_new$handle() {
        return git_mailmap_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_mailmap_new(git_mailmap **out)
     * }
     */
    public static MemorySegment git_mailmap_new$address() {
        return git_mailmap_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_mailmap_new(git_mailmap **out)
     * }
     */
    public static int git_mailmap_new(MemorySegment out) {
        var mh$ = git_mailmap_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_mailmap_new", out);
            }
            return (int)mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_mailmap_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_mailmap_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_mailmap_free(git_mailmap *mm)
     * }
     */
    public static FunctionDescriptor git_mailmap_free$descriptor() {
        return git_mailmap_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_mailmap_free(git_mailmap *mm)
     * }
     */
    public static MethodHandle git_mailmap_free$handle() {
        return git_mailmap_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_mailmap_free(git_mailmap *mm)
     * }
     */
    public static MemorySegment git_mailmap_free$address() {
        return git_mailmap_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_mailmap_free(git_mailmap *mm)
     * }
     */
    public static void git_mailmap_free(MemorySegment mm) {
        var mh$ = git_mailmap_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_mailmap_free", mm);
            }
            mh$.invokeExact(mm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_mailmap_add_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_mailmap_add_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_mailmap_add_entry(git_mailmap *mm, const char *real_name, const char *real_email, const char *replace_name, const char *replace_email)
     * }
     */
    public static FunctionDescriptor git_mailmap_add_entry$descriptor() {
        return git_mailmap_add_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_mailmap_add_entry(git_mailmap *mm, const char *real_name, const char *real_email, const char *replace_name, const char *replace_email)
     * }
     */
    public static MethodHandle git_mailmap_add_entry$handle() {
        return git_mailmap_add_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_mailmap_add_entry(git_mailmap *mm, const char *real_name, const char *real_email, const char *replace_name, const char *replace_email)
     * }
     */
    public static MemorySegment git_mailmap_add_entry$address() {
        return git_mailmap_add_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_mailmap_add_entry(git_mailmap *mm, const char *real_name, const char *real_email, const char *replace_name, const char *replace_email)
     * }
     */
    public static int git_mailmap_add_entry(MemorySegment mm, MemorySegment real_name, MemorySegment real_email, MemorySegment replace_name, MemorySegment replace_email) {
        var mh$ = git_mailmap_add_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_mailmap_add_entry", mm, real_name, real_email, replace_name, replace_email);
            }
            return (int)mh$.invokeExact(mm, real_name, real_email, replace_name, replace_email);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_mailmap_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_mailmap_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_mailmap_from_buffer(git_mailmap **out, const char *buf, size_t len)
     * }
     */
    public static FunctionDescriptor git_mailmap_from_buffer$descriptor() {
        return git_mailmap_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_mailmap_from_buffer(git_mailmap **out, const char *buf, size_t len)
     * }
     */
    public static MethodHandle git_mailmap_from_buffer$handle() {
        return git_mailmap_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_mailmap_from_buffer(git_mailmap **out, const char *buf, size_t len)
     * }
     */
    public static MemorySegment git_mailmap_from_buffer$address() {
        return git_mailmap_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_mailmap_from_buffer(git_mailmap **out, const char *buf, size_t len)
     * }
     */
    public static int git_mailmap_from_buffer(MemorySegment out, MemorySegment buf, long len) {
        var mh$ = git_mailmap_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_mailmap_from_buffer", out, buf, len);
            }
            return (int)mh$.invokeExact(out, buf, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_mailmap_from_repository {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_mailmap_from_repository");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_mailmap_from_repository(git_mailmap **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_mailmap_from_repository$descriptor() {
        return git_mailmap_from_repository.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_mailmap_from_repository(git_mailmap **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_mailmap_from_repository$handle() {
        return git_mailmap_from_repository.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_mailmap_from_repository(git_mailmap **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_mailmap_from_repository$address() {
        return git_mailmap_from_repository.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_mailmap_from_repository(git_mailmap **out, git_repository *repo)
     * }
     */
    public static int git_mailmap_from_repository(MemorySegment out, MemorySegment repo) {
        var mh$ = git_mailmap_from_repository.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_mailmap_from_repository", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_mailmap_resolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_mailmap_resolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_mailmap_resolve(const char **real_name, const char **real_email, const git_mailmap *mm, const char *name, const char *email)
     * }
     */
    public static FunctionDescriptor git_mailmap_resolve$descriptor() {
        return git_mailmap_resolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_mailmap_resolve(const char **real_name, const char **real_email, const git_mailmap *mm, const char *name, const char *email)
     * }
     */
    public static MethodHandle git_mailmap_resolve$handle() {
        return git_mailmap_resolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_mailmap_resolve(const char **real_name, const char **real_email, const git_mailmap *mm, const char *name, const char *email)
     * }
     */
    public static MemorySegment git_mailmap_resolve$address() {
        return git_mailmap_resolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_mailmap_resolve(const char **real_name, const char **real_email, const git_mailmap *mm, const char *name, const char *email)
     * }
     */
    public static int git_mailmap_resolve(MemorySegment real_name, MemorySegment real_email, MemorySegment mm, MemorySegment name, MemorySegment email) {
        var mh$ = git_mailmap_resolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_mailmap_resolve", real_name, real_email, mm, name, email);
            }
            return (int)mh$.invokeExact(real_name, real_email, mm, name, email);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_mailmap_resolve_signature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_mailmap_resolve_signature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_mailmap_resolve_signature(git_signature **out, const git_mailmap *mm, const git_signature *sig)
     * }
     */
    public static FunctionDescriptor git_mailmap_resolve_signature$descriptor() {
        return git_mailmap_resolve_signature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_mailmap_resolve_signature(git_signature **out, const git_mailmap *mm, const git_signature *sig)
     * }
     */
    public static MethodHandle git_mailmap_resolve_signature$handle() {
        return git_mailmap_resolve_signature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_mailmap_resolve_signature(git_signature **out, const git_mailmap *mm, const git_signature *sig)
     * }
     */
    public static MemorySegment git_mailmap_resolve_signature$address() {
        return git_mailmap_resolve_signature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_mailmap_resolve_signature(git_signature **out, const git_mailmap *mm, const git_signature *sig)
     * }
     */
    public static int git_mailmap_resolve_signature(MemorySegment out, MemorySegment mm, MemorySegment sig) {
        var mh$ = git_mailmap_resolve_signature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_mailmap_resolve_signature", out, mm, sig);
            }
            return (int)mh$.invokeExact(out, mm, sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_message_prettify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_CHAR
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_message_prettify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_message_prettify(git_buf *out, const char *message, int strip_comments, char comment_char)
     * }
     */
    public static FunctionDescriptor git_message_prettify$descriptor() {
        return git_message_prettify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_message_prettify(git_buf *out, const char *message, int strip_comments, char comment_char)
     * }
     */
    public static MethodHandle git_message_prettify$handle() {
        return git_message_prettify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_message_prettify(git_buf *out, const char *message, int strip_comments, char comment_char)
     * }
     */
    public static MemorySegment git_message_prettify$address() {
        return git_message_prettify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_message_prettify(git_buf *out, const char *message, int strip_comments, char comment_char)
     * }
     */
    public static int git_message_prettify(MemorySegment out, MemorySegment message, int strip_comments, byte comment_char) {
        var mh$ = git_message_prettify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_message_prettify", out, message, strip_comments, comment_char);
            }
            return (int)mh$.invokeExact(out, message, strip_comments, comment_char);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_message_trailers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_message_trailers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_message_trailers(git_message_trailer_array *arr, const char *message)
     * }
     */
    public static FunctionDescriptor git_message_trailers$descriptor() {
        return git_message_trailers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_message_trailers(git_message_trailer_array *arr, const char *message)
     * }
     */
    public static MethodHandle git_message_trailers$handle() {
        return git_message_trailers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_message_trailers(git_message_trailer_array *arr, const char *message)
     * }
     */
    public static MemorySegment git_message_trailers$address() {
        return git_message_trailers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_message_trailers(git_message_trailer_array *arr, const char *message)
     * }
     */
    public static int git_message_trailers(MemorySegment arr, MemorySegment message) {
        var mh$ = git_message_trailers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_message_trailers", arr, message);
            }
            return (int)mh$.invokeExact(arr, message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_message_trailer_array_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_message_trailer_array_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_message_trailer_array_free(git_message_trailer_array *arr)
     * }
     */
    public static FunctionDescriptor git_message_trailer_array_free$descriptor() {
        return git_message_trailer_array_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_message_trailer_array_free(git_message_trailer_array *arr)
     * }
     */
    public static MethodHandle git_message_trailer_array_free$handle() {
        return git_message_trailer_array_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_message_trailer_array_free(git_message_trailer_array *arr)
     * }
     */
    public static MemorySegment git_message_trailer_array_free$address() {
        return git_message_trailer_array_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_message_trailer_array_free(git_message_trailer_array *arr)
     * }
     */
    public static void git_message_trailer_array_free(MemorySegment arr) {
        var mh$ = git_message_trailer_array_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_message_trailer_array_free", arr);
            }
            mh$.invokeExact(arr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_iterator_new(git_note_iterator **out, git_repository *repo, const char *notes_ref)
     * }
     */
    public static FunctionDescriptor git_note_iterator_new$descriptor() {
        return git_note_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_iterator_new(git_note_iterator **out, git_repository *repo, const char *notes_ref)
     * }
     */
    public static MethodHandle git_note_iterator_new$handle() {
        return git_note_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_iterator_new(git_note_iterator **out, git_repository *repo, const char *notes_ref)
     * }
     */
    public static MemorySegment git_note_iterator_new$address() {
        return git_note_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_iterator_new(git_note_iterator **out, git_repository *repo, const char *notes_ref)
     * }
     */
    public static int git_note_iterator_new(MemorySegment out, MemorySegment repo, MemorySegment notes_ref) {
        var mh$ = git_note_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_iterator_new", out, repo, notes_ref);
            }
            return (int)mh$.invokeExact(out, repo, notes_ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_commit_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_commit_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_commit_iterator_new(git_note_iterator **out, git_commit *notes_commit)
     * }
     */
    public static FunctionDescriptor git_note_commit_iterator_new$descriptor() {
        return git_note_commit_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_commit_iterator_new(git_note_iterator **out, git_commit *notes_commit)
     * }
     */
    public static MethodHandle git_note_commit_iterator_new$handle() {
        return git_note_commit_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_commit_iterator_new(git_note_iterator **out, git_commit *notes_commit)
     * }
     */
    public static MemorySegment git_note_commit_iterator_new$address() {
        return git_note_commit_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_commit_iterator_new(git_note_iterator **out, git_commit *notes_commit)
     * }
     */
    public static int git_note_commit_iterator_new(MemorySegment out, MemorySegment notes_commit) {
        var mh$ = git_note_commit_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_commit_iterator_new", out, notes_commit);
            }
            return (int)mh$.invokeExact(out, notes_commit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_iterator_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_iterator_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_note_iterator_free(git_note_iterator *it)
     * }
     */
    public static FunctionDescriptor git_note_iterator_free$descriptor() {
        return git_note_iterator_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_note_iterator_free(git_note_iterator *it)
     * }
     */
    public static MethodHandle git_note_iterator_free$handle() {
        return git_note_iterator_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_note_iterator_free(git_note_iterator *it)
     * }
     */
    public static MemorySegment git_note_iterator_free$address() {
        return git_note_iterator_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_note_iterator_free(git_note_iterator *it)
     * }
     */
    public static void git_note_iterator_free(MemorySegment it) {
        var mh$ = git_note_iterator_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_iterator_free", it);
            }
            mh$.invokeExact(it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_next(git_oid *note_id, git_oid *annotated_id, git_note_iterator *it)
     * }
     */
    public static FunctionDescriptor git_note_next$descriptor() {
        return git_note_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_next(git_oid *note_id, git_oid *annotated_id, git_note_iterator *it)
     * }
     */
    public static MethodHandle git_note_next$handle() {
        return git_note_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_next(git_oid *note_id, git_oid *annotated_id, git_note_iterator *it)
     * }
     */
    public static MemorySegment git_note_next$address() {
        return git_note_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_next(git_oid *note_id, git_oid *annotated_id, git_note_iterator *it)
     * }
     */
    public static int git_note_next(MemorySegment note_id, MemorySegment annotated_id, MemorySegment it) {
        var mh$ = git_note_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_next", note_id, annotated_id, it);
            }
            return (int)mh$.invokeExact(note_id, annotated_id, it);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_read(git_note **out, git_repository *repo, const char *notes_ref, const git_oid *oid)
     * }
     */
    public static FunctionDescriptor git_note_read$descriptor() {
        return git_note_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_read(git_note **out, git_repository *repo, const char *notes_ref, const git_oid *oid)
     * }
     */
    public static MethodHandle git_note_read$handle() {
        return git_note_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_read(git_note **out, git_repository *repo, const char *notes_ref, const git_oid *oid)
     * }
     */
    public static MemorySegment git_note_read$address() {
        return git_note_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_read(git_note **out, git_repository *repo, const char *notes_ref, const git_oid *oid)
     * }
     */
    public static int git_note_read(MemorySegment out, MemorySegment repo, MemorySegment notes_ref, MemorySegment oid) {
        var mh$ = git_note_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_read", out, repo, notes_ref, oid);
            }
            return (int)mh$.invokeExact(out, repo, notes_ref, oid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_commit_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_commit_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_commit_read(git_note **out, git_repository *repo, git_commit *notes_commit, const git_oid *oid)
     * }
     */
    public static FunctionDescriptor git_note_commit_read$descriptor() {
        return git_note_commit_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_commit_read(git_note **out, git_repository *repo, git_commit *notes_commit, const git_oid *oid)
     * }
     */
    public static MethodHandle git_note_commit_read$handle() {
        return git_note_commit_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_commit_read(git_note **out, git_repository *repo, git_commit *notes_commit, const git_oid *oid)
     * }
     */
    public static MemorySegment git_note_commit_read$address() {
        return git_note_commit_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_commit_read(git_note **out, git_repository *repo, git_commit *notes_commit, const git_oid *oid)
     * }
     */
    public static int git_note_commit_read(MemorySegment out, MemorySegment repo, MemorySegment notes_commit, MemorySegment oid) {
        var mh$ = git_note_commit_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_commit_read", out, repo, notes_commit, oid);
            }
            return (int)mh$.invokeExact(out, repo, notes_commit, oid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_author {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_author");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_signature *git_note_author(const git_note *note)
     * }
     */
    public static FunctionDescriptor git_note_author$descriptor() {
        return git_note_author.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_signature *git_note_author(const git_note *note)
     * }
     */
    public static MethodHandle git_note_author$handle() {
        return git_note_author.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_signature *git_note_author(const git_note *note)
     * }
     */
    public static MemorySegment git_note_author$address() {
        return git_note_author.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_signature *git_note_author(const git_note *note)
     * }
     */
    public static MemorySegment git_note_author(MemorySegment note) {
        var mh$ = git_note_author.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_author", note);
            }
            return (MemorySegment)mh$.invokeExact(note);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_committer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_committer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_signature *git_note_committer(const git_note *note)
     * }
     */
    public static FunctionDescriptor git_note_committer$descriptor() {
        return git_note_committer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_signature *git_note_committer(const git_note *note)
     * }
     */
    public static MethodHandle git_note_committer$handle() {
        return git_note_committer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_signature *git_note_committer(const git_note *note)
     * }
     */
    public static MemorySegment git_note_committer$address() {
        return git_note_committer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_signature *git_note_committer(const git_note *note)
     * }
     */
    public static MemorySegment git_note_committer(MemorySegment note) {
        var mh$ = git_note_committer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_committer", note);
            }
            return (MemorySegment)mh$.invokeExact(note);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_note_message(const git_note *note)
     * }
     */
    public static FunctionDescriptor git_note_message$descriptor() {
        return git_note_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_note_message(const git_note *note)
     * }
     */
    public static MethodHandle git_note_message$handle() {
        return git_note_message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_note_message(const git_note *note)
     * }
     */
    public static MemorySegment git_note_message$address() {
        return git_note_message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_note_message(const git_note *note)
     * }
     */
    public static MemorySegment git_note_message(MemorySegment note) {
        var mh$ = git_note_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_message", note);
            }
            return (MemorySegment)mh$.invokeExact(note);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_note_id(const git_note *note)
     * }
     */
    public static FunctionDescriptor git_note_id$descriptor() {
        return git_note_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_note_id(const git_note *note)
     * }
     */
    public static MethodHandle git_note_id$handle() {
        return git_note_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_note_id(const git_note *note)
     * }
     */
    public static MemorySegment git_note_id$address() {
        return git_note_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_note_id(const git_note *note)
     * }
     */
    public static MemorySegment git_note_id(MemorySegment note) {
        var mh$ = git_note_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_id", note);
            }
            return (MemorySegment)mh$.invokeExact(note);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_create(git_oid *out, git_repository *repo, const char *notes_ref, const git_signature *author, const git_signature *committer, const git_oid *oid, const char *note, int force)
     * }
     */
    public static FunctionDescriptor git_note_create$descriptor() {
        return git_note_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_create(git_oid *out, git_repository *repo, const char *notes_ref, const git_signature *author, const git_signature *committer, const git_oid *oid, const char *note, int force)
     * }
     */
    public static MethodHandle git_note_create$handle() {
        return git_note_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_create(git_oid *out, git_repository *repo, const char *notes_ref, const git_signature *author, const git_signature *committer, const git_oid *oid, const char *note, int force)
     * }
     */
    public static MemorySegment git_note_create$address() {
        return git_note_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_create(git_oid *out, git_repository *repo, const char *notes_ref, const git_signature *author, const git_signature *committer, const git_oid *oid, const char *note, int force)
     * }
     */
    public static int git_note_create(MemorySegment out, MemorySegment repo, MemorySegment notes_ref, MemorySegment author, MemorySegment committer, MemorySegment oid, MemorySegment note, int force) {
        var mh$ = git_note_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_create", out, repo, notes_ref, author, committer, oid, note, force);
            }
            return (int)mh$.invokeExact(out, repo, notes_ref, author, committer, oid, note, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_commit_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_commit_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_commit_create(git_oid *notes_commit_out, git_oid *notes_blob_out, git_repository *repo, git_commit *parent, const git_signature *author, const git_signature *committer, const git_oid *oid, const char *note, int allow_note_overwrite)
     * }
     */
    public static FunctionDescriptor git_note_commit_create$descriptor() {
        return git_note_commit_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_commit_create(git_oid *notes_commit_out, git_oid *notes_blob_out, git_repository *repo, git_commit *parent, const git_signature *author, const git_signature *committer, const git_oid *oid, const char *note, int allow_note_overwrite)
     * }
     */
    public static MethodHandle git_note_commit_create$handle() {
        return git_note_commit_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_commit_create(git_oid *notes_commit_out, git_oid *notes_blob_out, git_repository *repo, git_commit *parent, const git_signature *author, const git_signature *committer, const git_oid *oid, const char *note, int allow_note_overwrite)
     * }
     */
    public static MemorySegment git_note_commit_create$address() {
        return git_note_commit_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_commit_create(git_oid *notes_commit_out, git_oid *notes_blob_out, git_repository *repo, git_commit *parent, const git_signature *author, const git_signature *committer, const git_oid *oid, const char *note, int allow_note_overwrite)
     * }
     */
    public static int git_note_commit_create(MemorySegment notes_commit_out, MemorySegment notes_blob_out, MemorySegment repo, MemorySegment parent, MemorySegment author, MemorySegment committer, MemorySegment oid, MemorySegment note, int allow_note_overwrite) {
        var mh$ = git_note_commit_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_commit_create", notes_commit_out, notes_blob_out, repo, parent, author, committer, oid, note, allow_note_overwrite);
            }
            return (int)mh$.invokeExact(notes_commit_out, notes_blob_out, repo, parent, author, committer, oid, note, allow_note_overwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_remove(git_repository *repo, const char *notes_ref, const git_signature *author, const git_signature *committer, const git_oid *oid)
     * }
     */
    public static FunctionDescriptor git_note_remove$descriptor() {
        return git_note_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_remove(git_repository *repo, const char *notes_ref, const git_signature *author, const git_signature *committer, const git_oid *oid)
     * }
     */
    public static MethodHandle git_note_remove$handle() {
        return git_note_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_remove(git_repository *repo, const char *notes_ref, const git_signature *author, const git_signature *committer, const git_oid *oid)
     * }
     */
    public static MemorySegment git_note_remove$address() {
        return git_note_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_remove(git_repository *repo, const char *notes_ref, const git_signature *author, const git_signature *committer, const git_oid *oid)
     * }
     */
    public static int git_note_remove(MemorySegment repo, MemorySegment notes_ref, MemorySegment author, MemorySegment committer, MemorySegment oid) {
        var mh$ = git_note_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_remove", repo, notes_ref, author, committer, oid);
            }
            return (int)mh$.invokeExact(repo, notes_ref, author, committer, oid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_commit_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_commit_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_commit_remove(git_oid *notes_commit_out, git_repository *repo, git_commit *notes_commit, const git_signature *author, const git_signature *committer, const git_oid *oid)
     * }
     */
    public static FunctionDescriptor git_note_commit_remove$descriptor() {
        return git_note_commit_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_commit_remove(git_oid *notes_commit_out, git_repository *repo, git_commit *notes_commit, const git_signature *author, const git_signature *committer, const git_oid *oid)
     * }
     */
    public static MethodHandle git_note_commit_remove$handle() {
        return git_note_commit_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_commit_remove(git_oid *notes_commit_out, git_repository *repo, git_commit *notes_commit, const git_signature *author, const git_signature *committer, const git_oid *oid)
     * }
     */
    public static MemorySegment git_note_commit_remove$address() {
        return git_note_commit_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_commit_remove(git_oid *notes_commit_out, git_repository *repo, git_commit *notes_commit, const git_signature *author, const git_signature *committer, const git_oid *oid)
     * }
     */
    public static int git_note_commit_remove(MemorySegment notes_commit_out, MemorySegment repo, MemorySegment notes_commit, MemorySegment author, MemorySegment committer, MemorySegment oid) {
        var mh$ = git_note_commit_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_commit_remove", notes_commit_out, repo, notes_commit, author, committer, oid);
            }
            return (int)mh$.invokeExact(notes_commit_out, repo, notes_commit, author, committer, oid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_note_free(git_note *note)
     * }
     */
    public static FunctionDescriptor git_note_free$descriptor() {
        return git_note_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_note_free(git_note *note)
     * }
     */
    public static MethodHandle git_note_free$handle() {
        return git_note_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_note_free(git_note *note)
     * }
     */
    public static MemorySegment git_note_free$address() {
        return git_note_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_note_free(git_note *note)
     * }
     */
    public static void git_note_free(MemorySegment note) {
        var mh$ = git_note_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_free", note);
            }
            mh$.invokeExact(note);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_default_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_default_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_default_ref(git_buf *out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_note_default_ref$descriptor() {
        return git_note_default_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_default_ref(git_buf *out, git_repository *repo)
     * }
     */
    public static MethodHandle git_note_default_ref$handle() {
        return git_note_default_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_default_ref(git_buf *out, git_repository *repo)
     * }
     */
    public static MemorySegment git_note_default_ref$address() {
        return git_note_default_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_default_ref(git_buf *out, git_repository *repo)
     * }
     */
    public static int git_note_default_ref(MemorySegment out, MemorySegment repo) {
        var mh$ = git_note_default_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_default_ref", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_note_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_note_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_note_foreach(git_repository *repo, const char *notes_ref, git_note_foreach_cb note_cb, void *payload)
     * }
     */
    public static FunctionDescriptor git_note_foreach$descriptor() {
        return git_note_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_note_foreach(git_repository *repo, const char *notes_ref, git_note_foreach_cb note_cb, void *payload)
     * }
     */
    public static MethodHandle git_note_foreach$handle() {
        return git_note_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_note_foreach(git_repository *repo, const char *notes_ref, git_note_foreach_cb note_cb, void *payload)
     * }
     */
    public static MemorySegment git_note_foreach$address() {
        return git_note_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_note_foreach(git_repository *repo, const char *notes_ref, git_note_foreach_cb note_cb, void *payload)
     * }
     */
    public static int git_note_foreach(MemorySegment repo, MemorySegment notes_ref, MemorySegment note_cb, MemorySegment payload) {
        var mh$ = git_note_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_note_foreach", repo, notes_ref, note_cb, payload);
            }
            return (int)mh$.invokeExact(repo, notes_ref, note_cb, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_ODB_BACKEND_LOOSE_FSYNC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_ODB_BACKEND_LOOSE_FSYNC = 1
     * }
     */
    public static int GIT_ODB_BACKEND_LOOSE_FSYNC() {
        return GIT_ODB_BACKEND_LOOSE_FSYNC;
    }

    private static class git_odb_backend_pack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_backend_pack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_backend_pack(git_odb_backend **out, const char *objects_dir)
     * }
     */
    public static FunctionDescriptor git_odb_backend_pack$descriptor() {
        return git_odb_backend_pack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_backend_pack(git_odb_backend **out, const char *objects_dir)
     * }
     */
    public static MethodHandle git_odb_backend_pack$handle() {
        return git_odb_backend_pack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_backend_pack(git_odb_backend **out, const char *objects_dir)
     * }
     */
    public static MemorySegment git_odb_backend_pack$address() {
        return git_odb_backend_pack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_backend_pack(git_odb_backend **out, const char *objects_dir)
     * }
     */
    public static int git_odb_backend_pack(MemorySegment out, MemorySegment objects_dir) {
        var mh$ = git_odb_backend_pack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_backend_pack", out, objects_dir);
            }
            return (int)mh$.invokeExact(out, objects_dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_backend_one_pack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_backend_one_pack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_backend_one_pack(git_odb_backend **out, const char *index_file)
     * }
     */
    public static FunctionDescriptor git_odb_backend_one_pack$descriptor() {
        return git_odb_backend_one_pack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_backend_one_pack(git_odb_backend **out, const char *index_file)
     * }
     */
    public static MethodHandle git_odb_backend_one_pack$handle() {
        return git_odb_backend_one_pack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_backend_one_pack(git_odb_backend **out, const char *index_file)
     * }
     */
    public static MemorySegment git_odb_backend_one_pack$address() {
        return git_odb_backend_one_pack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_backend_one_pack(git_odb_backend **out, const char *index_file)
     * }
     */
    public static int git_odb_backend_one_pack(MemorySegment out, MemorySegment index_file) {
        var mh$ = git_odb_backend_one_pack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_backend_one_pack", out, index_file);
            }
            return (int)mh$.invokeExact(out, index_file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_odb_backend_loose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_INT,
            git2.C_INT,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_odb_backend_loose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_odb_backend_loose(git_odb_backend **out, const char *objects_dir, int compression_level, int do_fsync, unsigned int dir_mode, unsigned int file_mode)
     * }
     */
    public static FunctionDescriptor git_odb_backend_loose$descriptor() {
        return git_odb_backend_loose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_odb_backend_loose(git_odb_backend **out, const char *objects_dir, int compression_level, int do_fsync, unsigned int dir_mode, unsigned int file_mode)
     * }
     */
    public static MethodHandle git_odb_backend_loose$handle() {
        return git_odb_backend_loose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_odb_backend_loose(git_odb_backend **out, const char *objects_dir, int compression_level, int do_fsync, unsigned int dir_mode, unsigned int file_mode)
     * }
     */
    public static MemorySegment git_odb_backend_loose$address() {
        return git_odb_backend_loose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_odb_backend_loose(git_odb_backend **out, const char *objects_dir, int compression_level, int do_fsync, unsigned int dir_mode, unsigned int file_mode)
     * }
     */
    public static int git_odb_backend_loose(MemorySegment out, MemorySegment objects_dir, int compression_level, int do_fsync, int dir_mode, int file_mode) {
        var mh$ = git_odb_backend_loose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_odb_backend_loose", out, objects_dir, compression_level, do_fsync, dir_mode, file_mode);
            }
            return (int)mh$.invokeExact(out, objects_dir, compression_level, do_fsync, dir_mode, file_mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_STREAM_RDONLY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STREAM_RDONLY = 2
     * }
     */
    public static int GIT_STREAM_RDONLY() {
        return GIT_STREAM_RDONLY;
    }
    private static final int GIT_STREAM_WRONLY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STREAM_WRONLY = 4
     * }
     */
    public static int GIT_STREAM_WRONLY() {
        return GIT_STREAM_WRONLY;
    }
    private static final int GIT_STREAM_RW = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_STREAM_RW = 6
     * }
     */
    public static int GIT_STREAM_RW() {
        return GIT_STREAM_RW;
    }

    private static class git_patch_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_patch_owner(const git_patch *patch)
     * }
     */
    public static FunctionDescriptor git_patch_owner$descriptor() {
        return git_patch_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_patch_owner(const git_patch *patch)
     * }
     */
    public static MethodHandle git_patch_owner$handle() {
        return git_patch_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_patch_owner(const git_patch *patch)
     * }
     */
    public static MemorySegment git_patch_owner$address() {
        return git_patch_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_patch_owner(const git_patch *patch)
     * }
     */
    public static MemorySegment git_patch_owner(MemorySegment patch) {
        var mh$ = git_patch_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_owner", patch);
            }
            return (MemorySegment)mh$.invokeExact(patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_from_diff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_from_diff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_patch_from_diff(git_patch **out, git_diff *diff, size_t idx)
     * }
     */
    public static FunctionDescriptor git_patch_from_diff$descriptor() {
        return git_patch_from_diff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_patch_from_diff(git_patch **out, git_diff *diff, size_t idx)
     * }
     */
    public static MethodHandle git_patch_from_diff$handle() {
        return git_patch_from_diff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_patch_from_diff(git_patch **out, git_diff *diff, size_t idx)
     * }
     */
    public static MemorySegment git_patch_from_diff$address() {
        return git_patch_from_diff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_patch_from_diff(git_patch **out, git_diff *diff, size_t idx)
     * }
     */
    public static int git_patch_from_diff(MemorySegment out, MemorySegment diff, long idx) {
        var mh$ = git_patch_from_diff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_from_diff", out, diff, idx);
            }
            return (int)mh$.invokeExact(out, diff, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_from_blobs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_from_blobs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_patch_from_blobs(git_patch **out, const git_blob *old_blob, const char *old_as_path, const git_blob *new_blob, const char *new_as_path, const git_diff_options *opts)
     * }
     */
    public static FunctionDescriptor git_patch_from_blobs$descriptor() {
        return git_patch_from_blobs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_patch_from_blobs(git_patch **out, const git_blob *old_blob, const char *old_as_path, const git_blob *new_blob, const char *new_as_path, const git_diff_options *opts)
     * }
     */
    public static MethodHandle git_patch_from_blobs$handle() {
        return git_patch_from_blobs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_patch_from_blobs(git_patch **out, const git_blob *old_blob, const char *old_as_path, const git_blob *new_blob, const char *new_as_path, const git_diff_options *opts)
     * }
     */
    public static MemorySegment git_patch_from_blobs$address() {
        return git_patch_from_blobs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_patch_from_blobs(git_patch **out, const git_blob *old_blob, const char *old_as_path, const git_blob *new_blob, const char *new_as_path, const git_diff_options *opts)
     * }
     */
    public static int git_patch_from_blobs(MemorySegment out, MemorySegment old_blob, MemorySegment old_as_path, MemorySegment new_blob, MemorySegment new_as_path, MemorySegment opts) {
        var mh$ = git_patch_from_blobs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_from_blobs", out, old_blob, old_as_path, new_blob, new_as_path, opts);
            }
            return (int)mh$.invokeExact(out, old_blob, old_as_path, new_blob, new_as_path, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_from_blob_and_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_from_blob_and_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_patch_from_blob_and_buffer(git_patch **out, const git_blob *old_blob, const char *old_as_path, const void *buffer, size_t buffer_len, const char *buffer_as_path, const git_diff_options *opts)
     * }
     */
    public static FunctionDescriptor git_patch_from_blob_and_buffer$descriptor() {
        return git_patch_from_blob_and_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_patch_from_blob_and_buffer(git_patch **out, const git_blob *old_blob, const char *old_as_path, const void *buffer, size_t buffer_len, const char *buffer_as_path, const git_diff_options *opts)
     * }
     */
    public static MethodHandle git_patch_from_blob_and_buffer$handle() {
        return git_patch_from_blob_and_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_patch_from_blob_and_buffer(git_patch **out, const git_blob *old_blob, const char *old_as_path, const void *buffer, size_t buffer_len, const char *buffer_as_path, const git_diff_options *opts)
     * }
     */
    public static MemorySegment git_patch_from_blob_and_buffer$address() {
        return git_patch_from_blob_and_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_patch_from_blob_and_buffer(git_patch **out, const git_blob *old_blob, const char *old_as_path, const void *buffer, size_t buffer_len, const char *buffer_as_path, const git_diff_options *opts)
     * }
     */
    public static int git_patch_from_blob_and_buffer(MemorySegment out, MemorySegment old_blob, MemorySegment old_as_path, MemorySegment buffer, long buffer_len, MemorySegment buffer_as_path, MemorySegment opts) {
        var mh$ = git_patch_from_blob_and_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_from_blob_and_buffer", out, old_blob, old_as_path, buffer, buffer_len, buffer_as_path, opts);
            }
            return (int)mh$.invokeExact(out, old_blob, old_as_path, buffer, buffer_len, buffer_as_path, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_from_buffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_from_buffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_patch_from_buffers(git_patch **out, const void *old_buffer, size_t old_len, const char *old_as_path, const void *new_buffer, size_t new_len, const char *new_as_path, const git_diff_options *opts)
     * }
     */
    public static FunctionDescriptor git_patch_from_buffers$descriptor() {
        return git_patch_from_buffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_patch_from_buffers(git_patch **out, const void *old_buffer, size_t old_len, const char *old_as_path, const void *new_buffer, size_t new_len, const char *new_as_path, const git_diff_options *opts)
     * }
     */
    public static MethodHandle git_patch_from_buffers$handle() {
        return git_patch_from_buffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_patch_from_buffers(git_patch **out, const void *old_buffer, size_t old_len, const char *old_as_path, const void *new_buffer, size_t new_len, const char *new_as_path, const git_diff_options *opts)
     * }
     */
    public static MemorySegment git_patch_from_buffers$address() {
        return git_patch_from_buffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_patch_from_buffers(git_patch **out, const void *old_buffer, size_t old_len, const char *old_as_path, const void *new_buffer, size_t new_len, const char *new_as_path, const git_diff_options *opts)
     * }
     */
    public static int git_patch_from_buffers(MemorySegment out, MemorySegment old_buffer, long old_len, MemorySegment old_as_path, MemorySegment new_buffer, long new_len, MemorySegment new_as_path, MemorySegment opts) {
        var mh$ = git_patch_from_buffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_from_buffers", out, old_buffer, old_len, old_as_path, new_buffer, new_len, new_as_path, opts);
            }
            return (int)mh$.invokeExact(out, old_buffer, old_len, old_as_path, new_buffer, new_len, new_as_path, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_patch_free(git_patch *patch)
     * }
     */
    public static FunctionDescriptor git_patch_free$descriptor() {
        return git_patch_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_patch_free(git_patch *patch)
     * }
     */
    public static MethodHandle git_patch_free$handle() {
        return git_patch_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_patch_free(git_patch *patch)
     * }
     */
    public static MemorySegment git_patch_free$address() {
        return git_patch_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_patch_free(git_patch *patch)
     * }
     */
    public static void git_patch_free(MemorySegment patch) {
        var mh$ = git_patch_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_free", patch);
            }
            mh$.invokeExact(patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_get_delta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_get_delta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_diff_delta *git_patch_get_delta(const git_patch *patch)
     * }
     */
    public static FunctionDescriptor git_patch_get_delta$descriptor() {
        return git_patch_get_delta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_diff_delta *git_patch_get_delta(const git_patch *patch)
     * }
     */
    public static MethodHandle git_patch_get_delta$handle() {
        return git_patch_get_delta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_diff_delta *git_patch_get_delta(const git_patch *patch)
     * }
     */
    public static MemorySegment git_patch_get_delta$address() {
        return git_patch_get_delta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_diff_delta *git_patch_get_delta(const git_patch *patch)
     * }
     */
    public static MemorySegment git_patch_get_delta(MemorySegment patch) {
        var mh$ = git_patch_get_delta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_get_delta", patch);
            }
            return (MemorySegment)mh$.invokeExact(patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_num_hunks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_num_hunks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_patch_num_hunks(const git_patch *patch)
     * }
     */
    public static FunctionDescriptor git_patch_num_hunks$descriptor() {
        return git_patch_num_hunks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_patch_num_hunks(const git_patch *patch)
     * }
     */
    public static MethodHandle git_patch_num_hunks$handle() {
        return git_patch_num_hunks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_patch_num_hunks(const git_patch *patch)
     * }
     */
    public static MemorySegment git_patch_num_hunks$address() {
        return git_patch_num_hunks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_patch_num_hunks(const git_patch *patch)
     * }
     */
    public static long git_patch_num_hunks(MemorySegment patch) {
        var mh$ = git_patch_num_hunks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_num_hunks", patch);
            }
            return (long)mh$.invokeExact(patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_line_stats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_line_stats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_patch_line_stats(size_t *total_context, size_t *total_additions, size_t *total_deletions, const git_patch *patch)
     * }
     */
    public static FunctionDescriptor git_patch_line_stats$descriptor() {
        return git_patch_line_stats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_patch_line_stats(size_t *total_context, size_t *total_additions, size_t *total_deletions, const git_patch *patch)
     * }
     */
    public static MethodHandle git_patch_line_stats$handle() {
        return git_patch_line_stats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_patch_line_stats(size_t *total_context, size_t *total_additions, size_t *total_deletions, const git_patch *patch)
     * }
     */
    public static MemorySegment git_patch_line_stats$address() {
        return git_patch_line_stats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_patch_line_stats(size_t *total_context, size_t *total_additions, size_t *total_deletions, const git_patch *patch)
     * }
     */
    public static int git_patch_line_stats(MemorySegment total_context, MemorySegment total_additions, MemorySegment total_deletions, MemorySegment patch) {
        var mh$ = git_patch_line_stats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_line_stats", total_context, total_additions, total_deletions, patch);
            }
            return (int)mh$.invokeExact(total_context, total_additions, total_deletions, patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_get_hunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_get_hunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_patch_get_hunk(const git_diff_hunk **out, size_t *lines_in_hunk, git_patch *patch, size_t hunk_idx)
     * }
     */
    public static FunctionDescriptor git_patch_get_hunk$descriptor() {
        return git_patch_get_hunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_patch_get_hunk(const git_diff_hunk **out, size_t *lines_in_hunk, git_patch *patch, size_t hunk_idx)
     * }
     */
    public static MethodHandle git_patch_get_hunk$handle() {
        return git_patch_get_hunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_patch_get_hunk(const git_diff_hunk **out, size_t *lines_in_hunk, git_patch *patch, size_t hunk_idx)
     * }
     */
    public static MemorySegment git_patch_get_hunk$address() {
        return git_patch_get_hunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_patch_get_hunk(const git_diff_hunk **out, size_t *lines_in_hunk, git_patch *patch, size_t hunk_idx)
     * }
     */
    public static int git_patch_get_hunk(MemorySegment out, MemorySegment lines_in_hunk, MemorySegment patch, long hunk_idx) {
        var mh$ = git_patch_get_hunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_get_hunk", out, lines_in_hunk, patch, hunk_idx);
            }
            return (int)mh$.invokeExact(out, lines_in_hunk, patch, hunk_idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_num_lines_in_hunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_num_lines_in_hunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_patch_num_lines_in_hunk(const git_patch *patch, size_t hunk_idx)
     * }
     */
    public static FunctionDescriptor git_patch_num_lines_in_hunk$descriptor() {
        return git_patch_num_lines_in_hunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_patch_num_lines_in_hunk(const git_patch *patch, size_t hunk_idx)
     * }
     */
    public static MethodHandle git_patch_num_lines_in_hunk$handle() {
        return git_patch_num_lines_in_hunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_patch_num_lines_in_hunk(const git_patch *patch, size_t hunk_idx)
     * }
     */
    public static MemorySegment git_patch_num_lines_in_hunk$address() {
        return git_patch_num_lines_in_hunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_patch_num_lines_in_hunk(const git_patch *patch, size_t hunk_idx)
     * }
     */
    public static int git_patch_num_lines_in_hunk(MemorySegment patch, long hunk_idx) {
        var mh$ = git_patch_num_lines_in_hunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_num_lines_in_hunk", patch, hunk_idx);
            }
            return (int)mh$.invokeExact(patch, hunk_idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_get_line_in_hunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_get_line_in_hunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_patch_get_line_in_hunk(const git_diff_line **out, git_patch *patch, size_t hunk_idx, size_t line_of_hunk)
     * }
     */
    public static FunctionDescriptor git_patch_get_line_in_hunk$descriptor() {
        return git_patch_get_line_in_hunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_patch_get_line_in_hunk(const git_diff_line **out, git_patch *patch, size_t hunk_idx, size_t line_of_hunk)
     * }
     */
    public static MethodHandle git_patch_get_line_in_hunk$handle() {
        return git_patch_get_line_in_hunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_patch_get_line_in_hunk(const git_diff_line **out, git_patch *patch, size_t hunk_idx, size_t line_of_hunk)
     * }
     */
    public static MemorySegment git_patch_get_line_in_hunk$address() {
        return git_patch_get_line_in_hunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_patch_get_line_in_hunk(const git_diff_line **out, git_patch *patch, size_t hunk_idx, size_t line_of_hunk)
     * }
     */
    public static int git_patch_get_line_in_hunk(MemorySegment out, MemorySegment patch, long hunk_idx, long line_of_hunk) {
        var mh$ = git_patch_get_line_in_hunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_get_line_in_hunk", out, patch, hunk_idx, line_of_hunk);
            }
            return (int)mh$.invokeExact(out, patch, hunk_idx, line_of_hunk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_INT,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_patch_size(git_patch *patch, int include_context, int include_hunk_headers, int include_file_headers)
     * }
     */
    public static FunctionDescriptor git_patch_size$descriptor() {
        return git_patch_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_patch_size(git_patch *patch, int include_context, int include_hunk_headers, int include_file_headers)
     * }
     */
    public static MethodHandle git_patch_size$handle() {
        return git_patch_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_patch_size(git_patch *patch, int include_context, int include_hunk_headers, int include_file_headers)
     * }
     */
    public static MemorySegment git_patch_size$address() {
        return git_patch_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_patch_size(git_patch *patch, int include_context, int include_hunk_headers, int include_file_headers)
     * }
     */
    public static long git_patch_size(MemorySegment patch, int include_context, int include_hunk_headers, int include_file_headers) {
        var mh$ = git_patch_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_size", patch, include_context, include_hunk_headers, include_file_headers);
            }
            return (long)mh$.invokeExact(patch, include_context, include_hunk_headers, include_file_headers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_patch_print(git_patch *patch, git_diff_line_cb print_cb, void *payload)
     * }
     */
    public static FunctionDescriptor git_patch_print$descriptor() {
        return git_patch_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_patch_print(git_patch *patch, git_diff_line_cb print_cb, void *payload)
     * }
     */
    public static MethodHandle git_patch_print$handle() {
        return git_patch_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_patch_print(git_patch *patch, git_diff_line_cb print_cb, void *payload)
     * }
     */
    public static MemorySegment git_patch_print$address() {
        return git_patch_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_patch_print(git_patch *patch, git_diff_line_cb print_cb, void *payload)
     * }
     */
    public static int git_patch_print(MemorySegment patch, MemorySegment print_cb, MemorySegment payload) {
        var mh$ = git_patch_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_print", patch, print_cb, payload);
            }
            return (int)mh$.invokeExact(patch, print_cb, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_patch_to_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_patch_to_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_patch_to_buf(git_buf *out, git_patch *patch)
     * }
     */
    public static FunctionDescriptor git_patch_to_buf$descriptor() {
        return git_patch_to_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_patch_to_buf(git_buf *out, git_patch *patch)
     * }
     */
    public static MethodHandle git_patch_to_buf$handle() {
        return git_patch_to_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_patch_to_buf(git_buf *out, git_patch *patch)
     * }
     */
    public static MemorySegment git_patch_to_buf$address() {
        return git_patch_to_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_patch_to_buf(git_buf *out, git_patch *patch)
     * }
     */
    public static int git_patch_to_buf(MemorySegment out, MemorySegment patch) {
        var mh$ = git_patch_to_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_patch_to_buf", out, patch);
            }
            return (int)mh$.invokeExact(out, patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_PATHSPEC_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PATHSPEC_DEFAULT = 0
     * }
     */
    public static int GIT_PATHSPEC_DEFAULT() {
        return GIT_PATHSPEC_DEFAULT;
    }
    private static final int GIT_PATHSPEC_IGNORE_CASE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PATHSPEC_IGNORE_CASE = 1
     * }
     */
    public static int GIT_PATHSPEC_IGNORE_CASE() {
        return GIT_PATHSPEC_IGNORE_CASE;
    }
    private static final int GIT_PATHSPEC_USE_CASE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PATHSPEC_USE_CASE = 2
     * }
     */
    public static int GIT_PATHSPEC_USE_CASE() {
        return GIT_PATHSPEC_USE_CASE;
    }
    private static final int GIT_PATHSPEC_NO_GLOB = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PATHSPEC_NO_GLOB = 4
     * }
     */
    public static int GIT_PATHSPEC_NO_GLOB() {
        return GIT_PATHSPEC_NO_GLOB;
    }
    private static final int GIT_PATHSPEC_NO_MATCH_ERROR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PATHSPEC_NO_MATCH_ERROR = 8
     * }
     */
    public static int GIT_PATHSPEC_NO_MATCH_ERROR() {
        return GIT_PATHSPEC_NO_MATCH_ERROR;
    }
    private static final int GIT_PATHSPEC_FIND_FAILURES = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PATHSPEC_FIND_FAILURES = 16
     * }
     */
    public static int GIT_PATHSPEC_FIND_FAILURES() {
        return GIT_PATHSPEC_FIND_FAILURES;
    }
    private static final int GIT_PATHSPEC_FAILURES_ONLY = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_PATHSPEC_FAILURES_ONLY = 32
     * }
     */
    public static int GIT_PATHSPEC_FAILURES_ONLY() {
        return GIT_PATHSPEC_FAILURES_ONLY;
    }

    private static class git_pathspec_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_pathspec_new(git_pathspec **out, const git_strarray *pathspec)
     * }
     */
    public static FunctionDescriptor git_pathspec_new$descriptor() {
        return git_pathspec_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_pathspec_new(git_pathspec **out, const git_strarray *pathspec)
     * }
     */
    public static MethodHandle git_pathspec_new$handle() {
        return git_pathspec_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_pathspec_new(git_pathspec **out, const git_strarray *pathspec)
     * }
     */
    public static MemorySegment git_pathspec_new$address() {
        return git_pathspec_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_pathspec_new(git_pathspec **out, const git_strarray *pathspec)
     * }
     */
    public static int git_pathspec_new(MemorySegment out, MemorySegment pathspec) {
        var mh$ = git_pathspec_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_new", out, pathspec);
            }
            return (int)mh$.invokeExact(out, pathspec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_pathspec_free(git_pathspec *ps)
     * }
     */
    public static FunctionDescriptor git_pathspec_free$descriptor() {
        return git_pathspec_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_pathspec_free(git_pathspec *ps)
     * }
     */
    public static MethodHandle git_pathspec_free$handle() {
        return git_pathspec_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_pathspec_free(git_pathspec *ps)
     * }
     */
    public static MemorySegment git_pathspec_free$address() {
        return git_pathspec_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_pathspec_free(git_pathspec *ps)
     * }
     */
    public static void git_pathspec_free(MemorySegment ps) {
        var mh$ = git_pathspec_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_free", ps);
            }
            mh$.invokeExact(ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_matches_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_matches_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_pathspec_matches_path(const git_pathspec *ps, uint32_t flags, const char *path)
     * }
     */
    public static FunctionDescriptor git_pathspec_matches_path$descriptor() {
        return git_pathspec_matches_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_pathspec_matches_path(const git_pathspec *ps, uint32_t flags, const char *path)
     * }
     */
    public static MethodHandle git_pathspec_matches_path$handle() {
        return git_pathspec_matches_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_pathspec_matches_path(const git_pathspec *ps, uint32_t flags, const char *path)
     * }
     */
    public static MemorySegment git_pathspec_matches_path$address() {
        return git_pathspec_matches_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_pathspec_matches_path(const git_pathspec *ps, uint32_t flags, const char *path)
     * }
     */
    public static int git_pathspec_matches_path(MemorySegment ps, int flags, MemorySegment path) {
        var mh$ = git_pathspec_matches_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_matches_path", ps, flags, path);
            }
            return (int)mh$.invokeExact(ps, flags, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_match_workdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_match_workdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_workdir(git_pathspec_match_list **out, git_repository *repo, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static FunctionDescriptor git_pathspec_match_workdir$descriptor() {
        return git_pathspec_match_workdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_workdir(git_pathspec_match_list **out, git_repository *repo, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static MethodHandle git_pathspec_match_workdir$handle() {
        return git_pathspec_match_workdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_workdir(git_pathspec_match_list **out, git_repository *repo, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static MemorySegment git_pathspec_match_workdir$address() {
        return git_pathspec_match_workdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_pathspec_match_workdir(git_pathspec_match_list **out, git_repository *repo, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static int git_pathspec_match_workdir(MemorySegment out, MemorySegment repo, int flags, MemorySegment ps) {
        var mh$ = git_pathspec_match_workdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_match_workdir", out, repo, flags, ps);
            }
            return (int)mh$.invokeExact(out, repo, flags, ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_match_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_match_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_index(git_pathspec_match_list **out, git_index *index, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static FunctionDescriptor git_pathspec_match_index$descriptor() {
        return git_pathspec_match_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_index(git_pathspec_match_list **out, git_index *index, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static MethodHandle git_pathspec_match_index$handle() {
        return git_pathspec_match_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_index(git_pathspec_match_list **out, git_index *index, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static MemorySegment git_pathspec_match_index$address() {
        return git_pathspec_match_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_pathspec_match_index(git_pathspec_match_list **out, git_index *index, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static int git_pathspec_match_index(MemorySegment out, MemorySegment index, int flags, MemorySegment ps) {
        var mh$ = git_pathspec_match_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_match_index", out, index, flags, ps);
            }
            return (int)mh$.invokeExact(out, index, flags, ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_match_tree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_match_tree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_tree(git_pathspec_match_list **out, git_tree *tree, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static FunctionDescriptor git_pathspec_match_tree$descriptor() {
        return git_pathspec_match_tree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_tree(git_pathspec_match_list **out, git_tree *tree, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static MethodHandle git_pathspec_match_tree$handle() {
        return git_pathspec_match_tree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_tree(git_pathspec_match_list **out, git_tree *tree, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static MemorySegment git_pathspec_match_tree$address() {
        return git_pathspec_match_tree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_pathspec_match_tree(git_pathspec_match_list **out, git_tree *tree, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static int git_pathspec_match_tree(MemorySegment out, MemorySegment tree, int flags, MemorySegment ps) {
        var mh$ = git_pathspec_match_tree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_match_tree", out, tree, flags, ps);
            }
            return (int)mh$.invokeExact(out, tree, flags, ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_match_diff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_match_diff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_diff(git_pathspec_match_list **out, git_diff *diff, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static FunctionDescriptor git_pathspec_match_diff$descriptor() {
        return git_pathspec_match_diff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_diff(git_pathspec_match_list **out, git_diff *diff, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static MethodHandle git_pathspec_match_diff$handle() {
        return git_pathspec_match_diff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_pathspec_match_diff(git_pathspec_match_list **out, git_diff *diff, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static MemorySegment git_pathspec_match_diff$address() {
        return git_pathspec_match_diff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_pathspec_match_diff(git_pathspec_match_list **out, git_diff *diff, uint32_t flags, git_pathspec *ps)
     * }
     */
    public static int git_pathspec_match_diff(MemorySegment out, MemorySegment diff, int flags, MemorySegment ps) {
        var mh$ = git_pathspec_match_diff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_match_diff", out, diff, flags, ps);
            }
            return (int)mh$.invokeExact(out, diff, flags, ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_match_list_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_match_list_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_pathspec_match_list_free(git_pathspec_match_list *m)
     * }
     */
    public static FunctionDescriptor git_pathspec_match_list_free$descriptor() {
        return git_pathspec_match_list_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_pathspec_match_list_free(git_pathspec_match_list *m)
     * }
     */
    public static MethodHandle git_pathspec_match_list_free$handle() {
        return git_pathspec_match_list_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_pathspec_match_list_free(git_pathspec_match_list *m)
     * }
     */
    public static MemorySegment git_pathspec_match_list_free$address() {
        return git_pathspec_match_list_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_pathspec_match_list_free(git_pathspec_match_list *m)
     * }
     */
    public static void git_pathspec_match_list_free(MemorySegment m) {
        var mh$ = git_pathspec_match_list_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_match_list_free", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_match_list_entrycount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_match_list_entrycount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_pathspec_match_list_entrycount(const git_pathspec_match_list *m)
     * }
     */
    public static FunctionDescriptor git_pathspec_match_list_entrycount$descriptor() {
        return git_pathspec_match_list_entrycount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_pathspec_match_list_entrycount(const git_pathspec_match_list *m)
     * }
     */
    public static MethodHandle git_pathspec_match_list_entrycount$handle() {
        return git_pathspec_match_list_entrycount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_pathspec_match_list_entrycount(const git_pathspec_match_list *m)
     * }
     */
    public static MemorySegment git_pathspec_match_list_entrycount$address() {
        return git_pathspec_match_list_entrycount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_pathspec_match_list_entrycount(const git_pathspec_match_list *m)
     * }
     */
    public static long git_pathspec_match_list_entrycount(MemorySegment m) {
        var mh$ = git_pathspec_match_list_entrycount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_match_list_entrycount", m);
            }
            return (long)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_match_list_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_match_list_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_pathspec_match_list_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static FunctionDescriptor git_pathspec_match_list_entry$descriptor() {
        return git_pathspec_match_list_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_pathspec_match_list_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static MethodHandle git_pathspec_match_list_entry$handle() {
        return git_pathspec_match_list_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_pathspec_match_list_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static MemorySegment git_pathspec_match_list_entry$address() {
        return git_pathspec_match_list_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_pathspec_match_list_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static MemorySegment git_pathspec_match_list_entry(MemorySegment m, long pos) {
        var mh$ = git_pathspec_match_list_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_match_list_entry", m, pos);
            }
            return (MemorySegment)mh$.invokeExact(m, pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_match_list_diff_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_match_list_diff_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_diff_delta *git_pathspec_match_list_diff_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static FunctionDescriptor git_pathspec_match_list_diff_entry$descriptor() {
        return git_pathspec_match_list_diff_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_diff_delta *git_pathspec_match_list_diff_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static MethodHandle git_pathspec_match_list_diff_entry$handle() {
        return git_pathspec_match_list_diff_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_diff_delta *git_pathspec_match_list_diff_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static MemorySegment git_pathspec_match_list_diff_entry$address() {
        return git_pathspec_match_list_diff_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_diff_delta *git_pathspec_match_list_diff_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static MemorySegment git_pathspec_match_list_diff_entry(MemorySegment m, long pos) {
        var mh$ = git_pathspec_match_list_diff_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_match_list_diff_entry", m, pos);
            }
            return (MemorySegment)mh$.invokeExact(m, pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_match_list_failed_entrycount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_match_list_failed_entrycount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_pathspec_match_list_failed_entrycount(const git_pathspec_match_list *m)
     * }
     */
    public static FunctionDescriptor git_pathspec_match_list_failed_entrycount$descriptor() {
        return git_pathspec_match_list_failed_entrycount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_pathspec_match_list_failed_entrycount(const git_pathspec_match_list *m)
     * }
     */
    public static MethodHandle git_pathspec_match_list_failed_entrycount$handle() {
        return git_pathspec_match_list_failed_entrycount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_pathspec_match_list_failed_entrycount(const git_pathspec_match_list *m)
     * }
     */
    public static MemorySegment git_pathspec_match_list_failed_entrycount$address() {
        return git_pathspec_match_list_failed_entrycount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_pathspec_match_list_failed_entrycount(const git_pathspec_match_list *m)
     * }
     */
    public static long git_pathspec_match_list_failed_entrycount(MemorySegment m) {
        var mh$ = git_pathspec_match_list_failed_entrycount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_match_list_failed_entrycount", m);
            }
            return (long)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_pathspec_match_list_failed_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_pathspec_match_list_failed_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_pathspec_match_list_failed_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static FunctionDescriptor git_pathspec_match_list_failed_entry$descriptor() {
        return git_pathspec_match_list_failed_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_pathspec_match_list_failed_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static MethodHandle git_pathspec_match_list_failed_entry$handle() {
        return git_pathspec_match_list_failed_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_pathspec_match_list_failed_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static MemorySegment git_pathspec_match_list_failed_entry$address() {
        return git_pathspec_match_list_failed_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_pathspec_match_list_failed_entry(const git_pathspec_match_list *m, size_t pos)
     * }
     */
    public static MemorySegment git_pathspec_match_list_failed_entry(MemorySegment m, long pos) {
        var mh$ = git_pathspec_match_list_failed_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_pathspec_match_list_failed_entry", m, pos);
            }
            return (MemorySegment)mh$.invokeExact(m, pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refdb_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refdb_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_refdb_new(git_refdb **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_refdb_new$descriptor() {
        return git_refdb_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_refdb_new(git_refdb **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_refdb_new$handle() {
        return git_refdb_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_refdb_new(git_refdb **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_refdb_new$address() {
        return git_refdb_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_refdb_new(git_refdb **out, git_repository *repo)
     * }
     */
    public static int git_refdb_new(MemorySegment out, MemorySegment repo) {
        var mh$ = git_refdb_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refdb_new", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refdb_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refdb_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_refdb_open(git_refdb **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_refdb_open$descriptor() {
        return git_refdb_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_refdb_open(git_refdb **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_refdb_open$handle() {
        return git_refdb_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_refdb_open(git_refdb **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_refdb_open$address() {
        return git_refdb_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_refdb_open(git_refdb **out, git_repository *repo)
     * }
     */
    public static int git_refdb_open(MemorySegment out, MemorySegment repo) {
        var mh$ = git_refdb_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refdb_open", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refdb_compress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refdb_compress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_refdb_compress(git_refdb *refdb)
     * }
     */
    public static FunctionDescriptor git_refdb_compress$descriptor() {
        return git_refdb_compress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_refdb_compress(git_refdb *refdb)
     * }
     */
    public static MethodHandle git_refdb_compress$handle() {
        return git_refdb_compress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_refdb_compress(git_refdb *refdb)
     * }
     */
    public static MemorySegment git_refdb_compress$address() {
        return git_refdb_compress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_refdb_compress(git_refdb *refdb)
     * }
     */
    public static int git_refdb_compress(MemorySegment refdb) {
        var mh$ = git_refdb_compress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refdb_compress", refdb);
            }
            return (int)mh$.invokeExact(refdb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_refdb_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_refdb_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_refdb_free(git_refdb *refdb)
     * }
     */
    public static FunctionDescriptor git_refdb_free$descriptor() {
        return git_refdb_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_refdb_free(git_refdb *refdb)
     * }
     */
    public static MethodHandle git_refdb_free$handle() {
        return git_refdb_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_refdb_free(git_refdb *refdb)
     * }
     */
    public static MemorySegment git_refdb_free$address() {
        return git_refdb_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_refdb_free(git_refdb *refdb)
     * }
     */
    public static void git_refdb_free(MemorySegment refdb) {
        var mh$ = git_refdb_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_refdb_free", refdb);
            }
            mh$.invokeExact(refdb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reflog_read(git_reflog **out, git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_reflog_read$descriptor() {
        return git_reflog_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reflog_read(git_reflog **out, git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_reflog_read$handle() {
        return git_reflog_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reflog_read(git_reflog **out, git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_reflog_read$address() {
        return git_reflog_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reflog_read(git_reflog **out, git_repository *repo, const char *name)
     * }
     */
    public static int git_reflog_read(MemorySegment out, MemorySegment repo, MemorySegment name) {
        var mh$ = git_reflog_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_read", out, repo, name);
            }
            return (int)mh$.invokeExact(out, repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reflog_write(git_reflog *reflog)
     * }
     */
    public static FunctionDescriptor git_reflog_write$descriptor() {
        return git_reflog_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reflog_write(git_reflog *reflog)
     * }
     */
    public static MethodHandle git_reflog_write$handle() {
        return git_reflog_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reflog_write(git_reflog *reflog)
     * }
     */
    public static MemorySegment git_reflog_write$address() {
        return git_reflog_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reflog_write(git_reflog *reflog)
     * }
     */
    public static int git_reflog_write(MemorySegment reflog) {
        var mh$ = git_reflog_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_write", reflog);
            }
            return (int)mh$.invokeExact(reflog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reflog_append(git_reflog *reflog, const git_oid *id, const git_signature *committer, const char *msg)
     * }
     */
    public static FunctionDescriptor git_reflog_append$descriptor() {
        return git_reflog_append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reflog_append(git_reflog *reflog, const git_oid *id, const git_signature *committer, const char *msg)
     * }
     */
    public static MethodHandle git_reflog_append$handle() {
        return git_reflog_append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reflog_append(git_reflog *reflog, const git_oid *id, const git_signature *committer, const char *msg)
     * }
     */
    public static MemorySegment git_reflog_append$address() {
        return git_reflog_append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reflog_append(git_reflog *reflog, const git_oid *id, const git_signature *committer, const char *msg)
     * }
     */
    public static int git_reflog_append(MemorySegment reflog, MemorySegment id, MemorySegment committer, MemorySegment msg) {
        var mh$ = git_reflog_append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_append", reflog, id, committer, msg);
            }
            return (int)mh$.invokeExact(reflog, id, committer, msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reflog_rename(git_repository *repo, const char *old_name, const char *name)
     * }
     */
    public static FunctionDescriptor git_reflog_rename$descriptor() {
        return git_reflog_rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reflog_rename(git_repository *repo, const char *old_name, const char *name)
     * }
     */
    public static MethodHandle git_reflog_rename$handle() {
        return git_reflog_rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reflog_rename(git_repository *repo, const char *old_name, const char *name)
     * }
     */
    public static MemorySegment git_reflog_rename$address() {
        return git_reflog_rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reflog_rename(git_repository *repo, const char *old_name, const char *name)
     * }
     */
    public static int git_reflog_rename(MemorySegment repo, MemorySegment old_name, MemorySegment name) {
        var mh$ = git_reflog_rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_rename", repo, old_name, name);
            }
            return (int)mh$.invokeExact(repo, old_name, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reflog_delete(git_repository *repo, const char *name)
     * }
     */
    public static FunctionDescriptor git_reflog_delete$descriptor() {
        return git_reflog_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reflog_delete(git_repository *repo, const char *name)
     * }
     */
    public static MethodHandle git_reflog_delete$handle() {
        return git_reflog_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reflog_delete(git_repository *repo, const char *name)
     * }
     */
    public static MemorySegment git_reflog_delete$address() {
        return git_reflog_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reflog_delete(git_repository *repo, const char *name)
     * }
     */
    public static int git_reflog_delete(MemorySegment repo, MemorySegment name) {
        var mh$ = git_reflog_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_delete", repo, name);
            }
            return (int)mh$.invokeExact(repo, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_entrycount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_LONG,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_entrycount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t git_reflog_entrycount(git_reflog *reflog)
     * }
     */
    public static FunctionDescriptor git_reflog_entrycount$descriptor() {
        return git_reflog_entrycount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t git_reflog_entrycount(git_reflog *reflog)
     * }
     */
    public static MethodHandle git_reflog_entrycount$handle() {
        return git_reflog_entrycount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t git_reflog_entrycount(git_reflog *reflog)
     * }
     */
    public static MemorySegment git_reflog_entrycount$address() {
        return git_reflog_entrycount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t git_reflog_entrycount(git_reflog *reflog)
     * }
     */
    public static long git_reflog_entrycount(MemorySegment reflog) {
        var mh$ = git_reflog_entrycount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_entrycount", reflog);
            }
            return (long)mh$.invokeExact(reflog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_entry_byindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_entry_byindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_reflog_entry *git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)
     * }
     */
    public static FunctionDescriptor git_reflog_entry_byindex$descriptor() {
        return git_reflog_entry_byindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_reflog_entry *git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)
     * }
     */
    public static MethodHandle git_reflog_entry_byindex$handle() {
        return git_reflog_entry_byindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_reflog_entry *git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)
     * }
     */
    public static MemorySegment git_reflog_entry_byindex$address() {
        return git_reflog_entry_byindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_reflog_entry *git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)
     * }
     */
    public static MemorySegment git_reflog_entry_byindex(MemorySegment reflog, long idx) {
        var mh$ = git_reflog_entry_byindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_entry_byindex", reflog, idx);
            }
            return (MemorySegment)mh$.invokeExact(reflog, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_drop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_drop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reflog_drop(git_reflog *reflog, size_t idx, int rewrite_previous_entry)
     * }
     */
    public static FunctionDescriptor git_reflog_drop$descriptor() {
        return git_reflog_drop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reflog_drop(git_reflog *reflog, size_t idx, int rewrite_previous_entry)
     * }
     */
    public static MethodHandle git_reflog_drop$handle() {
        return git_reflog_drop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reflog_drop(git_reflog *reflog, size_t idx, int rewrite_previous_entry)
     * }
     */
    public static MemorySegment git_reflog_drop$address() {
        return git_reflog_drop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reflog_drop(git_reflog *reflog, size_t idx, int rewrite_previous_entry)
     * }
     */
    public static int git_reflog_drop(MemorySegment reflog, long idx, int rewrite_previous_entry) {
        var mh$ = git_reflog_drop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_drop", reflog, idx, rewrite_previous_entry);
            }
            return (int)mh$.invokeExact(reflog, idx, rewrite_previous_entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_entry_id_old {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_entry_id_old");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_reflog_entry_id_old(const git_reflog_entry *entry)
     * }
     */
    public static FunctionDescriptor git_reflog_entry_id_old$descriptor() {
        return git_reflog_entry_id_old.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_reflog_entry_id_old(const git_reflog_entry *entry)
     * }
     */
    public static MethodHandle git_reflog_entry_id_old$handle() {
        return git_reflog_entry_id_old.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_reflog_entry_id_old(const git_reflog_entry *entry)
     * }
     */
    public static MemorySegment git_reflog_entry_id_old$address() {
        return git_reflog_entry_id_old.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_reflog_entry_id_old(const git_reflog_entry *entry)
     * }
     */
    public static MemorySegment git_reflog_entry_id_old(MemorySegment entry) {
        var mh$ = git_reflog_entry_id_old.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_entry_id_old", entry);
            }
            return (MemorySegment)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_entry_id_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_entry_id_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_reflog_entry_id_new(const git_reflog_entry *entry)
     * }
     */
    public static FunctionDescriptor git_reflog_entry_id_new$descriptor() {
        return git_reflog_entry_id_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_reflog_entry_id_new(const git_reflog_entry *entry)
     * }
     */
    public static MethodHandle git_reflog_entry_id_new$handle() {
        return git_reflog_entry_id_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_reflog_entry_id_new(const git_reflog_entry *entry)
     * }
     */
    public static MemorySegment git_reflog_entry_id_new$address() {
        return git_reflog_entry_id_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_reflog_entry_id_new(const git_reflog_entry *entry)
     * }
     */
    public static MemorySegment git_reflog_entry_id_new(MemorySegment entry) {
        var mh$ = git_reflog_entry_id_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_entry_id_new", entry);
            }
            return (MemorySegment)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_entry_committer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_entry_committer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_signature *git_reflog_entry_committer(const git_reflog_entry *entry)
     * }
     */
    public static FunctionDescriptor git_reflog_entry_committer$descriptor() {
        return git_reflog_entry_committer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_signature *git_reflog_entry_committer(const git_reflog_entry *entry)
     * }
     */
    public static MethodHandle git_reflog_entry_committer$handle() {
        return git_reflog_entry_committer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_signature *git_reflog_entry_committer(const git_reflog_entry *entry)
     * }
     */
    public static MemorySegment git_reflog_entry_committer$address() {
        return git_reflog_entry_committer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_signature *git_reflog_entry_committer(const git_reflog_entry *entry)
     * }
     */
    public static MemorySegment git_reflog_entry_committer(MemorySegment entry) {
        var mh$ = git_reflog_entry_committer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_entry_committer", entry);
            }
            return (MemorySegment)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_entry_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_entry_message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_reflog_entry_message(const git_reflog_entry *entry)
     * }
     */
    public static FunctionDescriptor git_reflog_entry_message$descriptor() {
        return git_reflog_entry_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_reflog_entry_message(const git_reflog_entry *entry)
     * }
     */
    public static MethodHandle git_reflog_entry_message$handle() {
        return git_reflog_entry_message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_reflog_entry_message(const git_reflog_entry *entry)
     * }
     */
    public static MemorySegment git_reflog_entry_message$address() {
        return git_reflog_entry_message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_reflog_entry_message(const git_reflog_entry *entry)
     * }
     */
    public static MemorySegment git_reflog_entry_message(MemorySegment entry) {
        var mh$ = git_reflog_entry_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_entry_message", entry);
            }
            return (MemorySegment)mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reflog_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reflog_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_reflog_free(git_reflog *reflog)
     * }
     */
    public static FunctionDescriptor git_reflog_free$descriptor() {
        return git_reflog_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_reflog_free(git_reflog *reflog)
     * }
     */
    public static MethodHandle git_reflog_free$handle() {
        return git_reflog_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_reflog_free(git_reflog *reflog)
     * }
     */
    public static MemorySegment git_reflog_free$address() {
        return git_reflog_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_reflog_free(git_reflog *reflog)
     * }
     */
    public static void git_reflog_free(MemorySegment reflog) {
        var mh$ = git_reflog_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reflog_free", reflog);
            }
            mh$.invokeExact(reflog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_RESET_SOFT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_RESET_SOFT = 1
     * }
     */
    public static int GIT_RESET_SOFT() {
        return GIT_RESET_SOFT;
    }
    private static final int GIT_RESET_MIXED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_RESET_MIXED = 2
     * }
     */
    public static int GIT_RESET_MIXED() {
        return GIT_RESET_MIXED;
    }
    private static final int GIT_RESET_HARD = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_RESET_HARD = 3
     * }
     */
    public static int GIT_RESET_HARD() {
        return GIT_RESET_HARD;
    }

    private static class git_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reset(git_repository *repo, const git_object *target, git_reset_t reset_type, const git_checkout_options *checkout_opts)
     * }
     */
    public static FunctionDescriptor git_reset$descriptor() {
        return git_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reset(git_repository *repo, const git_object *target, git_reset_t reset_type, const git_checkout_options *checkout_opts)
     * }
     */
    public static MethodHandle git_reset$handle() {
        return git_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reset(git_repository *repo, const git_object *target, git_reset_t reset_type, const git_checkout_options *checkout_opts)
     * }
     */
    public static MemorySegment git_reset$address() {
        return git_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reset(git_repository *repo, const git_object *target, git_reset_t reset_type, const git_checkout_options *checkout_opts)
     * }
     */
    public static int git_reset(MemorySegment repo, MemorySegment target, int reset_type, MemorySegment checkout_opts) {
        var mh$ = git_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reset", repo, target, reset_type, checkout_opts);
            }
            return (int)mh$.invokeExact(repo, target, reset_type, checkout_opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reset_from_annotated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reset_from_annotated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reset_from_annotated(git_repository *repo, const git_annotated_commit *target, git_reset_t reset_type, const git_checkout_options *checkout_opts)
     * }
     */
    public static FunctionDescriptor git_reset_from_annotated$descriptor() {
        return git_reset_from_annotated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reset_from_annotated(git_repository *repo, const git_annotated_commit *target, git_reset_t reset_type, const git_checkout_options *checkout_opts)
     * }
     */
    public static MethodHandle git_reset_from_annotated$handle() {
        return git_reset_from_annotated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reset_from_annotated(git_repository *repo, const git_annotated_commit *target, git_reset_t reset_type, const git_checkout_options *checkout_opts)
     * }
     */
    public static MemorySegment git_reset_from_annotated$address() {
        return git_reset_from_annotated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reset_from_annotated(git_repository *repo, const git_annotated_commit *target, git_reset_t reset_type, const git_checkout_options *checkout_opts)
     * }
     */
    public static int git_reset_from_annotated(MemorySegment repo, MemorySegment target, int reset_type, MemorySegment checkout_opts) {
        var mh$ = git_reset_from_annotated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reset_from_annotated", repo, target, reset_type, checkout_opts);
            }
            return (int)mh$.invokeExact(repo, target, reset_type, checkout_opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_reset_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_reset_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_reset_default(git_repository *repo, const git_object *target, const git_strarray *pathspecs)
     * }
     */
    public static FunctionDescriptor git_reset_default$descriptor() {
        return git_reset_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_reset_default(git_repository *repo, const git_object *target, const git_strarray *pathspecs)
     * }
     */
    public static MethodHandle git_reset_default$handle() {
        return git_reset_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_reset_default(git_repository *repo, const git_object *target, const git_strarray *pathspecs)
     * }
     */
    public static MemorySegment git_reset_default$address() {
        return git_reset_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_reset_default(git_repository *repo, const git_object *target, const git_strarray *pathspecs)
     * }
     */
    public static int git_reset_default(MemorySegment repo, MemorySegment target, MemorySegment pathspecs) {
        var mh$ = git_reset_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_reset_default", repo, target, pathspecs);
            }
            return (int)mh$.invokeExact(repo, target, pathspecs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GIT_SORT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SORT_NONE = 0
     * }
     */
    public static int GIT_SORT_NONE() {
        return GIT_SORT_NONE;
    }
    private static final int GIT_SORT_TOPOLOGICAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SORT_TOPOLOGICAL = 1
     * }
     */
    public static int GIT_SORT_TOPOLOGICAL() {
        return GIT_SORT_TOPOLOGICAL;
    }
    private static final int GIT_SORT_TIME = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SORT_TIME = 2
     * }
     */
    public static int GIT_SORT_TIME() {
        return GIT_SORT_TIME;
    }
    private static final int GIT_SORT_REVERSE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GIT_SORT_REVERSE = 4
     * }
     */
    public static int GIT_SORT_REVERSE() {
        return GIT_SORT_REVERSE;
    }

    private static class git_revwalk_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_new(git_revwalk **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_revwalk_new$descriptor() {
        return git_revwalk_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_new(git_revwalk **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_revwalk_new$handle() {
        return git_revwalk_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_new(git_revwalk **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_revwalk_new$address() {
        return git_revwalk_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_new(git_revwalk **out, git_repository *repo)
     * }
     */
    public static int git_revwalk_new(MemorySegment out, MemorySegment repo) {
        var mh$ = git_revwalk_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_new", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_reset(git_revwalk *walker)
     * }
     */
    public static FunctionDescriptor git_revwalk_reset$descriptor() {
        return git_revwalk_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_reset(git_revwalk *walker)
     * }
     */
    public static MethodHandle git_revwalk_reset$handle() {
        return git_revwalk_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_reset(git_revwalk *walker)
     * }
     */
    public static MemorySegment git_revwalk_reset$address() {
        return git_revwalk_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_reset(git_revwalk *walker)
     * }
     */
    public static int git_revwalk_reset(MemorySegment walker) {
        var mh$ = git_revwalk_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_reset", walker);
            }
            return (int)mh$.invokeExact(walker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_push {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_push");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_push(git_revwalk *walk, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_revwalk_push$descriptor() {
        return git_revwalk_push.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_push(git_revwalk *walk, const git_oid *id)
     * }
     */
    public static MethodHandle git_revwalk_push$handle() {
        return git_revwalk_push.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_push(git_revwalk *walk, const git_oid *id)
     * }
     */
    public static MemorySegment git_revwalk_push$address() {
        return git_revwalk_push.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_push(git_revwalk *walk, const git_oid *id)
     * }
     */
    public static int git_revwalk_push(MemorySegment walk, MemorySegment id) {
        var mh$ = git_revwalk_push.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_push", walk, id);
            }
            return (int)mh$.invokeExact(walk, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_push_glob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_push_glob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_glob(git_revwalk *walk, const char *glob)
     * }
     */
    public static FunctionDescriptor git_revwalk_push_glob$descriptor() {
        return git_revwalk_push_glob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_glob(git_revwalk *walk, const char *glob)
     * }
     */
    public static MethodHandle git_revwalk_push_glob$handle() {
        return git_revwalk_push_glob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_glob(git_revwalk *walk, const char *glob)
     * }
     */
    public static MemorySegment git_revwalk_push_glob$address() {
        return git_revwalk_push_glob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_push_glob(git_revwalk *walk, const char *glob)
     * }
     */
    public static int git_revwalk_push_glob(MemorySegment walk, MemorySegment glob) {
        var mh$ = git_revwalk_push_glob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_push_glob", walk, glob);
            }
            return (int)mh$.invokeExact(walk, glob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_push_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_push_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_head(git_revwalk *walk)
     * }
     */
    public static FunctionDescriptor git_revwalk_push_head$descriptor() {
        return git_revwalk_push_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_head(git_revwalk *walk)
     * }
     */
    public static MethodHandle git_revwalk_push_head$handle() {
        return git_revwalk_push_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_head(git_revwalk *walk)
     * }
     */
    public static MemorySegment git_revwalk_push_head$address() {
        return git_revwalk_push_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_push_head(git_revwalk *walk)
     * }
     */
    public static int git_revwalk_push_head(MemorySegment walk) {
        var mh$ = git_revwalk_push_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_push_head", walk);
            }
            return (int)mh$.invokeExact(walk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_hide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_hide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide(git_revwalk *walk, const git_oid *commit_id)
     * }
     */
    public static FunctionDescriptor git_revwalk_hide$descriptor() {
        return git_revwalk_hide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide(git_revwalk *walk, const git_oid *commit_id)
     * }
     */
    public static MethodHandle git_revwalk_hide$handle() {
        return git_revwalk_hide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide(git_revwalk *walk, const git_oid *commit_id)
     * }
     */
    public static MemorySegment git_revwalk_hide$address() {
        return git_revwalk_hide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_hide(git_revwalk *walk, const git_oid *commit_id)
     * }
     */
    public static int git_revwalk_hide(MemorySegment walk, MemorySegment commit_id) {
        var mh$ = git_revwalk_hide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_hide", walk, commit_id);
            }
            return (int)mh$.invokeExact(walk, commit_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_hide_glob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_hide_glob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide_glob(git_revwalk *walk, const char *glob)
     * }
     */
    public static FunctionDescriptor git_revwalk_hide_glob$descriptor() {
        return git_revwalk_hide_glob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide_glob(git_revwalk *walk, const char *glob)
     * }
     */
    public static MethodHandle git_revwalk_hide_glob$handle() {
        return git_revwalk_hide_glob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide_glob(git_revwalk *walk, const char *glob)
     * }
     */
    public static MemorySegment git_revwalk_hide_glob$address() {
        return git_revwalk_hide_glob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_hide_glob(git_revwalk *walk, const char *glob)
     * }
     */
    public static int git_revwalk_hide_glob(MemorySegment walk, MemorySegment glob) {
        var mh$ = git_revwalk_hide_glob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_hide_glob", walk, glob);
            }
            return (int)mh$.invokeExact(walk, glob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_hide_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_hide_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide_head(git_revwalk *walk)
     * }
     */
    public static FunctionDescriptor git_revwalk_hide_head$descriptor() {
        return git_revwalk_hide_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide_head(git_revwalk *walk)
     * }
     */
    public static MethodHandle git_revwalk_hide_head$handle() {
        return git_revwalk_hide_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide_head(git_revwalk *walk)
     * }
     */
    public static MemorySegment git_revwalk_hide_head$address() {
        return git_revwalk_hide_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_hide_head(git_revwalk *walk)
     * }
     */
    public static int git_revwalk_hide_head(MemorySegment walk) {
        var mh$ = git_revwalk_hide_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_hide_head", walk);
            }
            return (int)mh$.invokeExact(walk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_push_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_push_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_ref(git_revwalk *walk, const char *refname)
     * }
     */
    public static FunctionDescriptor git_revwalk_push_ref$descriptor() {
        return git_revwalk_push_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_ref(git_revwalk *walk, const char *refname)
     * }
     */
    public static MethodHandle git_revwalk_push_ref$handle() {
        return git_revwalk_push_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_ref(git_revwalk *walk, const char *refname)
     * }
     */
    public static MemorySegment git_revwalk_push_ref$address() {
        return git_revwalk_push_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_push_ref(git_revwalk *walk, const char *refname)
     * }
     */
    public static int git_revwalk_push_ref(MemorySegment walk, MemorySegment refname) {
        var mh$ = git_revwalk_push_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_push_ref", walk, refname);
            }
            return (int)mh$.invokeExact(walk, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_hide_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_hide_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide_ref(git_revwalk *walk, const char *refname)
     * }
     */
    public static FunctionDescriptor git_revwalk_hide_ref$descriptor() {
        return git_revwalk_hide_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide_ref(git_revwalk *walk, const char *refname)
     * }
     */
    public static MethodHandle git_revwalk_hide_ref$handle() {
        return git_revwalk_hide_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_hide_ref(git_revwalk *walk, const char *refname)
     * }
     */
    public static MemorySegment git_revwalk_hide_ref$address() {
        return git_revwalk_hide_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_hide_ref(git_revwalk *walk, const char *refname)
     * }
     */
    public static int git_revwalk_hide_ref(MemorySegment walk, MemorySegment refname) {
        var mh$ = git_revwalk_hide_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_hide_ref", walk, refname);
            }
            return (int)mh$.invokeExact(walk, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_next(git_oid *out, git_revwalk *walk)
     * }
     */
    public static FunctionDescriptor git_revwalk_next$descriptor() {
        return git_revwalk_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_next(git_oid *out, git_revwalk *walk)
     * }
     */
    public static MethodHandle git_revwalk_next$handle() {
        return git_revwalk_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_next(git_oid *out, git_revwalk *walk)
     * }
     */
    public static MemorySegment git_revwalk_next$address() {
        return git_revwalk_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_next(git_oid *out, git_revwalk *walk)
     * }
     */
    public static int git_revwalk_next(MemorySegment out, MemorySegment walk) {
        var mh$ = git_revwalk_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_next", out, walk);
            }
            return (int)mh$.invokeExact(out, walk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_sorting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_sorting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)
     * }
     */
    public static FunctionDescriptor git_revwalk_sorting$descriptor() {
        return git_revwalk_sorting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)
     * }
     */
    public static MethodHandle git_revwalk_sorting$handle() {
        return git_revwalk_sorting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)
     * }
     */
    public static MemorySegment git_revwalk_sorting$address() {
        return git_revwalk_sorting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)
     * }
     */
    public static int git_revwalk_sorting(MemorySegment walk, int sort_mode) {
        var mh$ = git_revwalk_sorting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_sorting", walk, sort_mode);
            }
            return (int)mh$.invokeExact(walk, sort_mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_push_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_push_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_range(git_revwalk *walk, const char *range)
     * }
     */
    public static FunctionDescriptor git_revwalk_push_range$descriptor() {
        return git_revwalk_push_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_range(git_revwalk *walk, const char *range)
     * }
     */
    public static MethodHandle git_revwalk_push_range$handle() {
        return git_revwalk_push_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_push_range(git_revwalk *walk, const char *range)
     * }
     */
    public static MemorySegment git_revwalk_push_range$address() {
        return git_revwalk_push_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_push_range(git_revwalk *walk, const char *range)
     * }
     */
    public static int git_revwalk_push_range(MemorySegment walk, MemorySegment range) {
        var mh$ = git_revwalk_push_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_push_range", walk, range);
            }
            return (int)mh$.invokeExact(walk, range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_simplify_first_parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_simplify_first_parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_simplify_first_parent(git_revwalk *walk)
     * }
     */
    public static FunctionDescriptor git_revwalk_simplify_first_parent$descriptor() {
        return git_revwalk_simplify_first_parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_simplify_first_parent(git_revwalk *walk)
     * }
     */
    public static MethodHandle git_revwalk_simplify_first_parent$handle() {
        return git_revwalk_simplify_first_parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_simplify_first_parent(git_revwalk *walk)
     * }
     */
    public static MemorySegment git_revwalk_simplify_first_parent$address() {
        return git_revwalk_simplify_first_parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_simplify_first_parent(git_revwalk *walk)
     * }
     */
    public static int git_revwalk_simplify_first_parent(MemorySegment walk) {
        var mh$ = git_revwalk_simplify_first_parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_simplify_first_parent", walk);
            }
            return (int)mh$.invokeExact(walk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_revwalk_free(git_revwalk *walk)
     * }
     */
    public static FunctionDescriptor git_revwalk_free$descriptor() {
        return git_revwalk_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_revwalk_free(git_revwalk *walk)
     * }
     */
    public static MethodHandle git_revwalk_free$handle() {
        return git_revwalk_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_revwalk_free(git_revwalk *walk)
     * }
     */
    public static MemorySegment git_revwalk_free$address() {
        return git_revwalk_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_revwalk_free(git_revwalk *walk)
     * }
     */
    public static void git_revwalk_free(MemorySegment walk) {
        var mh$ = git_revwalk_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_free", walk);
            }
            mh$.invokeExact(walk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_repository {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_repository");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_revwalk_repository(git_revwalk *walk)
     * }
     */
    public static FunctionDescriptor git_revwalk_repository$descriptor() {
        return git_revwalk_repository.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_revwalk_repository(git_revwalk *walk)
     * }
     */
    public static MethodHandle git_revwalk_repository$handle() {
        return git_revwalk_repository.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_revwalk_repository(git_revwalk *walk)
     * }
     */
    public static MemorySegment git_revwalk_repository$address() {
        return git_revwalk_repository.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_revwalk_repository(git_revwalk *walk)
     * }
     */
    public static MemorySegment git_revwalk_repository(MemorySegment walk) {
        var mh$ = git_revwalk_repository.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_repository", walk);
            }
            return (MemorySegment)mh$.invokeExact(walk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_revwalk_add_hide_cb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_revwalk_add_hide_cb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_revwalk_add_hide_cb(git_revwalk *walk, git_revwalk_hide_cb hide_cb, void *payload)
     * }
     */
    public static FunctionDescriptor git_revwalk_add_hide_cb$descriptor() {
        return git_revwalk_add_hide_cb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_revwalk_add_hide_cb(git_revwalk *walk, git_revwalk_hide_cb hide_cb, void *payload)
     * }
     */
    public static MethodHandle git_revwalk_add_hide_cb$handle() {
        return git_revwalk_add_hide_cb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_revwalk_add_hide_cb(git_revwalk *walk, git_revwalk_hide_cb hide_cb, void *payload)
     * }
     */
    public static MemorySegment git_revwalk_add_hide_cb$address() {
        return git_revwalk_add_hide_cb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_revwalk_add_hide_cb(git_revwalk *walk, git_revwalk_hide_cb hide_cb, void *payload)
     * }
     */
    public static int git_revwalk_add_hide_cb(MemorySegment walk, MemorySegment hide_cb, MemorySegment payload) {
        var mh$ = git_revwalk_add_hide_cb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_revwalk_add_hide_cb", walk, hide_cb, payload);
            }
            return (int)mh$.invokeExact(walk, hide_cb, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_signature_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_signature_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_signature_new(git_signature **out, const char *name, const char *email, git_time_t time, int offset)
     * }
     */
    public static FunctionDescriptor git_signature_new$descriptor() {
        return git_signature_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_signature_new(git_signature **out, const char *name, const char *email, git_time_t time, int offset)
     * }
     */
    public static MethodHandle git_signature_new$handle() {
        return git_signature_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_signature_new(git_signature **out, const char *name, const char *email, git_time_t time, int offset)
     * }
     */
    public static MemorySegment git_signature_new$address() {
        return git_signature_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_signature_new(git_signature **out, const char *name, const char *email, git_time_t time, int offset)
     * }
     */
    public static int git_signature_new(MemorySegment out, MemorySegment name, MemorySegment email, long time, int offset) {
        var mh$ = git_signature_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_signature_new", out, name, email, time, offset);
            }
            return (int)mh$.invokeExact(out, name, email, time, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_signature_now {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_signature_now");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_signature_now(git_signature **out, const char *name, const char *email)
     * }
     */
    public static FunctionDescriptor git_signature_now$descriptor() {
        return git_signature_now.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_signature_now(git_signature **out, const char *name, const char *email)
     * }
     */
    public static MethodHandle git_signature_now$handle() {
        return git_signature_now.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_signature_now(git_signature **out, const char *name, const char *email)
     * }
     */
    public static MemorySegment git_signature_now$address() {
        return git_signature_now.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_signature_now(git_signature **out, const char *name, const char *email)
     * }
     */
    public static int git_signature_now(MemorySegment out, MemorySegment name, MemorySegment email) {
        var mh$ = git_signature_now.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_signature_now", out, name, email);
            }
            return (int)mh$.invokeExact(out, name, email);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_signature_default_from_env {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_signature_default_from_env");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_signature_default_from_env(git_signature **author_out, git_signature **committer_out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_signature_default_from_env$descriptor() {
        return git_signature_default_from_env.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_signature_default_from_env(git_signature **author_out, git_signature **committer_out, git_repository *repo)
     * }
     */
    public static MethodHandle git_signature_default_from_env$handle() {
        return git_signature_default_from_env.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_signature_default_from_env(git_signature **author_out, git_signature **committer_out, git_repository *repo)
     * }
     */
    public static MemorySegment git_signature_default_from_env$address() {
        return git_signature_default_from_env.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_signature_default_from_env(git_signature **author_out, git_signature **committer_out, git_repository *repo)
     * }
     */
    public static int git_signature_default_from_env(MemorySegment author_out, MemorySegment committer_out, MemorySegment repo) {
        var mh$ = git_signature_default_from_env.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_signature_default_from_env", author_out, committer_out, repo);
            }
            return (int)mh$.invokeExact(author_out, committer_out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_signature_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_signature_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_signature_default(git_signature **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_signature_default$descriptor() {
        return git_signature_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_signature_default(git_signature **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_signature_default$handle() {
        return git_signature_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_signature_default(git_signature **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_signature_default$address() {
        return git_signature_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_signature_default(git_signature **out, git_repository *repo)
     * }
     */
    public static int git_signature_default(MemorySegment out, MemorySegment repo) {
        var mh$ = git_signature_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_signature_default", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_signature_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_signature_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_signature_from_buffer(git_signature **out, const char *buf)
     * }
     */
    public static FunctionDescriptor git_signature_from_buffer$descriptor() {
        return git_signature_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_signature_from_buffer(git_signature **out, const char *buf)
     * }
     */
    public static MethodHandle git_signature_from_buffer$handle() {
        return git_signature_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_signature_from_buffer(git_signature **out, const char *buf)
     * }
     */
    public static MemorySegment git_signature_from_buffer$address() {
        return git_signature_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_signature_from_buffer(git_signature **out, const char *buf)
     * }
     */
    public static int git_signature_from_buffer(MemorySegment out, MemorySegment buf) {
        var mh$ = git_signature_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_signature_from_buffer", out, buf);
            }
            return (int)mh$.invokeExact(out, buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_signature_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_signature_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_signature_dup(git_signature **dest, const git_signature *sig)
     * }
     */
    public static FunctionDescriptor git_signature_dup$descriptor() {
        return git_signature_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_signature_dup(git_signature **dest, const git_signature *sig)
     * }
     */
    public static MethodHandle git_signature_dup$handle() {
        return git_signature_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_signature_dup(git_signature **dest, const git_signature *sig)
     * }
     */
    public static MemorySegment git_signature_dup$address() {
        return git_signature_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_signature_dup(git_signature **dest, const git_signature *sig)
     * }
     */
    public static int git_signature_dup(MemorySegment dest, MemorySegment sig) {
        var mh$ = git_signature_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_signature_dup", dest, sig);
            }
            return (int)mh$.invokeExact(dest, sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_signature_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_signature_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_signature_free(git_signature *sig)
     * }
     */
    public static FunctionDescriptor git_signature_free$descriptor() {
        return git_signature_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_signature_free(git_signature *sig)
     * }
     */
    public static MethodHandle git_signature_free$handle() {
        return git_signature_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_signature_free(git_signature *sig)
     * }
     */
    public static MemorySegment git_signature_free$address() {
        return git_signature_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_signature_free(git_signature *sig)
     * }
     */
    public static void git_signature_free(MemorySegment sig) {
        var mh$ = git_signature_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_signature_free", sig);
            }
            mh$.invokeExact(sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_lookup(git_tag **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static FunctionDescriptor git_tag_lookup$descriptor() {
        return git_tag_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_lookup(git_tag **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static MethodHandle git_tag_lookup$handle() {
        return git_tag_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_lookup(git_tag **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static MemorySegment git_tag_lookup$address() {
        return git_tag_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_lookup(git_tag **out, git_repository *repo, const git_oid *id)
     * }
     */
    public static int git_tag_lookup(MemorySegment out, MemorySegment repo, MemorySegment id) {
        var mh$ = git_tag_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_lookup", out, repo, id);
            }
            return (int)mh$.invokeExact(out, repo, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_lookup_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_LONG
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_lookup_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_lookup_prefix(git_tag **out, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static FunctionDescriptor git_tag_lookup_prefix$descriptor() {
        return git_tag_lookup_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_lookup_prefix(git_tag **out, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static MethodHandle git_tag_lookup_prefix$handle() {
        return git_tag_lookup_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_lookup_prefix(git_tag **out, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static MemorySegment git_tag_lookup_prefix$address() {
        return git_tag_lookup_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_lookup_prefix(git_tag **out, git_repository *repo, const git_oid *id, size_t len)
     * }
     */
    public static int git_tag_lookup_prefix(MemorySegment out, MemorySegment repo, MemorySegment id, long len) {
        var mh$ = git_tag_lookup_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_lookup_prefix", out, repo, id, len);
            }
            return (int)mh$.invokeExact(out, repo, id, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_tag_free(git_tag *tag)
     * }
     */
    public static FunctionDescriptor git_tag_free$descriptor() {
        return git_tag_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_tag_free(git_tag *tag)
     * }
     */
    public static MethodHandle git_tag_free$handle() {
        return git_tag_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_tag_free(git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_free$address() {
        return git_tag_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_tag_free(git_tag *tag)
     * }
     */
    public static void git_tag_free(MemorySegment tag) {
        var mh$ = git_tag_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_free", tag);
            }
            mh$.invokeExact(tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_tag_id(const git_tag *tag)
     * }
     */
    public static FunctionDescriptor git_tag_id$descriptor() {
        return git_tag_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_tag_id(const git_tag *tag)
     * }
     */
    public static MethodHandle git_tag_id$handle() {
        return git_tag_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_tag_id(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_id$address() {
        return git_tag_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_tag_id(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_id(MemorySegment tag) {
        var mh$ = git_tag_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_id", tag);
            }
            return (MemorySegment)mh$.invokeExact(tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_owner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_owner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_repository *git_tag_owner(const git_tag *tag)
     * }
     */
    public static FunctionDescriptor git_tag_owner$descriptor() {
        return git_tag_owner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_repository *git_tag_owner(const git_tag *tag)
     * }
     */
    public static MethodHandle git_tag_owner$handle() {
        return git_tag_owner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_repository *git_tag_owner(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_owner$address() {
        return git_tag_owner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_repository *git_tag_owner(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_owner(MemorySegment tag) {
        var mh$ = git_tag_owner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_owner", tag);
            }
            return (MemorySegment)mh$.invokeExact(tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_target(git_object **target_out, const git_tag *tag)
     * }
     */
    public static FunctionDescriptor git_tag_target$descriptor() {
        return git_tag_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_target(git_object **target_out, const git_tag *tag)
     * }
     */
    public static MethodHandle git_tag_target$handle() {
        return git_tag_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_target(git_object **target_out, const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_target$address() {
        return git_tag_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_target(git_object **target_out, const git_tag *tag)
     * }
     */
    public static int git_tag_target(MemorySegment target_out, MemorySegment tag) {
        var mh$ = git_tag_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_target", target_out, tag);
            }
            return (int)mh$.invokeExact(target_out, tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_target_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_target_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_oid *git_tag_target_id(const git_tag *tag)
     * }
     */
    public static FunctionDescriptor git_tag_target_id$descriptor() {
        return git_tag_target_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_oid *git_tag_target_id(const git_tag *tag)
     * }
     */
    public static MethodHandle git_tag_target_id$handle() {
        return git_tag_target_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_oid *git_tag_target_id(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_target_id$address() {
        return git_tag_target_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_oid *git_tag_target_id(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_target_id(MemorySegment tag) {
        var mh$ = git_tag_target_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_target_id", tag);
            }
            return (MemorySegment)mh$.invokeExact(tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_target_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_target_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern git_object_t git_tag_target_type(const git_tag *tag)
     * }
     */
    public static FunctionDescriptor git_tag_target_type$descriptor() {
        return git_tag_target_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern git_object_t git_tag_target_type(const git_tag *tag)
     * }
     */
    public static MethodHandle git_tag_target_type$handle() {
        return git_tag_target_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern git_object_t git_tag_target_type(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_target_type$address() {
        return git_tag_target_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern git_object_t git_tag_target_type(const git_tag *tag)
     * }
     */
    public static int git_tag_target_type(MemorySegment tag) {
        var mh$ = git_tag_target_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_target_type", tag);
            }
            return (int)mh$.invokeExact(tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_tag_name(const git_tag *tag)
     * }
     */
    public static FunctionDescriptor git_tag_name$descriptor() {
        return git_tag_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_tag_name(const git_tag *tag)
     * }
     */
    public static MethodHandle git_tag_name$handle() {
        return git_tag_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_tag_name(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_name$address() {
        return git_tag_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_tag_name(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_name(MemorySegment tag) {
        var mh$ = git_tag_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_name", tag);
            }
            return (MemorySegment)mh$.invokeExact(tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_tagger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_tagger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const git_signature *git_tag_tagger(const git_tag *tag)
     * }
     */
    public static FunctionDescriptor git_tag_tagger$descriptor() {
        return git_tag_tagger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const git_signature *git_tag_tagger(const git_tag *tag)
     * }
     */
    public static MethodHandle git_tag_tagger$handle() {
        return git_tag_tagger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const git_signature *git_tag_tagger(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_tagger$address() {
        return git_tag_tagger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const git_signature *git_tag_tagger(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_tagger(MemorySegment tag) {
        var mh$ = git_tag_tagger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_tagger", tag);
            }
            return (MemorySegment)mh$.invokeExact(tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_message");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *git_tag_message(const git_tag *tag)
     * }
     */
    public static FunctionDescriptor git_tag_message$descriptor() {
        return git_tag_message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *git_tag_message(const git_tag *tag)
     * }
     */
    public static MethodHandle git_tag_message$handle() {
        return git_tag_message.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *git_tag_message(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_message$address() {
        return git_tag_message.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *git_tag_message(const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_message(MemorySegment tag) {
        var mh$ = git_tag_message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_message", tag);
            }
            return (MemorySegment)mh$.invokeExact(tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_create(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, const git_signature *tagger, const char *message, int force)
     * }
     */
    public static FunctionDescriptor git_tag_create$descriptor() {
        return git_tag_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_create(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, const git_signature *tagger, const char *message, int force)
     * }
     */
    public static MethodHandle git_tag_create$handle() {
        return git_tag_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_create(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, const git_signature *tagger, const char *message, int force)
     * }
     */
    public static MemorySegment git_tag_create$address() {
        return git_tag_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_create(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, const git_signature *tagger, const char *message, int force)
     * }
     */
    public static int git_tag_create(MemorySegment oid, MemorySegment repo, MemorySegment tag_name, MemorySegment target, MemorySegment tagger, MemorySegment message, int force) {
        var mh$ = git_tag_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_create", oid, repo, tag_name, target, tagger, message, force);
            }
            return (int)mh$.invokeExact(oid, repo, tag_name, target, tagger, message, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_annotation_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_annotation_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_annotation_create(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, const git_signature *tagger, const char *message)
     * }
     */
    public static FunctionDescriptor git_tag_annotation_create$descriptor() {
        return git_tag_annotation_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_annotation_create(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, const git_signature *tagger, const char *message)
     * }
     */
    public static MethodHandle git_tag_annotation_create$handle() {
        return git_tag_annotation_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_annotation_create(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, const git_signature *tagger, const char *message)
     * }
     */
    public static MemorySegment git_tag_annotation_create$address() {
        return git_tag_annotation_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_annotation_create(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, const git_signature *tagger, const char *message)
     * }
     */
    public static int git_tag_annotation_create(MemorySegment oid, MemorySegment repo, MemorySegment tag_name, MemorySegment target, MemorySegment tagger, MemorySegment message) {
        var mh$ = git_tag_annotation_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_annotation_create", oid, repo, tag_name, target, tagger, message);
            }
            return (int)mh$.invokeExact(oid, repo, tag_name, target, tagger, message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_create_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_create_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_create_from_buffer(git_oid *oid, git_repository *repo, const char *buffer, int force)
     * }
     */
    public static FunctionDescriptor git_tag_create_from_buffer$descriptor() {
        return git_tag_create_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_create_from_buffer(git_oid *oid, git_repository *repo, const char *buffer, int force)
     * }
     */
    public static MethodHandle git_tag_create_from_buffer$handle() {
        return git_tag_create_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_create_from_buffer(git_oid *oid, git_repository *repo, const char *buffer, int force)
     * }
     */
    public static MemorySegment git_tag_create_from_buffer$address() {
        return git_tag_create_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_create_from_buffer(git_oid *oid, git_repository *repo, const char *buffer, int force)
     * }
     */
    public static int git_tag_create_from_buffer(MemorySegment oid, MemorySegment repo, MemorySegment buffer, int force) {
        var mh$ = git_tag_create_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_create_from_buffer", oid, repo, buffer, force);
            }
            return (int)mh$.invokeExact(oid, repo, buffer, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_create_lightweight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_INT
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_create_lightweight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_create_lightweight(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, int force)
     * }
     */
    public static FunctionDescriptor git_tag_create_lightweight$descriptor() {
        return git_tag_create_lightweight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_create_lightweight(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, int force)
     * }
     */
    public static MethodHandle git_tag_create_lightweight$handle() {
        return git_tag_create_lightweight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_create_lightweight(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, int force)
     * }
     */
    public static MemorySegment git_tag_create_lightweight$address() {
        return git_tag_create_lightweight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_create_lightweight(git_oid *oid, git_repository *repo, const char *tag_name, const git_object *target, int force)
     * }
     */
    public static int git_tag_create_lightweight(MemorySegment oid, MemorySegment repo, MemorySegment tag_name, MemorySegment target, int force) {
        var mh$ = git_tag_create_lightweight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_create_lightweight", oid, repo, tag_name, target, force);
            }
            return (int)mh$.invokeExact(oid, repo, tag_name, target, force);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_delete(git_repository *repo, const char *tag_name)
     * }
     */
    public static FunctionDescriptor git_tag_delete$descriptor() {
        return git_tag_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_delete(git_repository *repo, const char *tag_name)
     * }
     */
    public static MethodHandle git_tag_delete$handle() {
        return git_tag_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_delete(git_repository *repo, const char *tag_name)
     * }
     */
    public static MemorySegment git_tag_delete$address() {
        return git_tag_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_delete(git_repository *repo, const char *tag_name)
     * }
     */
    public static int git_tag_delete(MemorySegment repo, MemorySegment tag_name) {
        var mh$ = git_tag_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_delete", repo, tag_name);
            }
            return (int)mh$.invokeExact(repo, tag_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_list(git_strarray *tag_names, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_tag_list$descriptor() {
        return git_tag_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_list(git_strarray *tag_names, git_repository *repo)
     * }
     */
    public static MethodHandle git_tag_list$handle() {
        return git_tag_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_list(git_strarray *tag_names, git_repository *repo)
     * }
     */
    public static MemorySegment git_tag_list$address() {
        return git_tag_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_list(git_strarray *tag_names, git_repository *repo)
     * }
     */
    public static int git_tag_list(MemorySegment tag_names, MemorySegment repo) {
        var mh$ = git_tag_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_list", tag_names, repo);
            }
            return (int)mh$.invokeExact(tag_names, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_list_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_list_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_list_match(git_strarray *tag_names, const char *pattern, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_tag_list_match$descriptor() {
        return git_tag_list_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_list_match(git_strarray *tag_names, const char *pattern, git_repository *repo)
     * }
     */
    public static MethodHandle git_tag_list_match$handle() {
        return git_tag_list_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_list_match(git_strarray *tag_names, const char *pattern, git_repository *repo)
     * }
     */
    public static MemorySegment git_tag_list_match$address() {
        return git_tag_list_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_list_match(git_strarray *tag_names, const char *pattern, git_repository *repo)
     * }
     */
    public static int git_tag_list_match(MemorySegment tag_names, MemorySegment pattern, MemorySegment repo) {
        var mh$ = git_tag_list_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_list_match", tag_names, pattern, repo);
            }
            return (int)mh$.invokeExact(tag_names, pattern, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_foreach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_foreach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_foreach(git_repository *repo, git_tag_foreach_cb callback, void *payload)
     * }
     */
    public static FunctionDescriptor git_tag_foreach$descriptor() {
        return git_tag_foreach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_foreach(git_repository *repo, git_tag_foreach_cb callback, void *payload)
     * }
     */
    public static MethodHandle git_tag_foreach$handle() {
        return git_tag_foreach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_foreach(git_repository *repo, git_tag_foreach_cb callback, void *payload)
     * }
     */
    public static MemorySegment git_tag_foreach$address() {
        return git_tag_foreach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_foreach(git_repository *repo, git_tag_foreach_cb callback, void *payload)
     * }
     */
    public static int git_tag_foreach(MemorySegment repo, MemorySegment callback, MemorySegment payload) {
        var mh$ = git_tag_foreach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_foreach", repo, callback, payload);
            }
            return (int)mh$.invokeExact(repo, callback, payload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_peel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_peel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_peel(git_object **tag_target_out, const git_tag *tag)
     * }
     */
    public static FunctionDescriptor git_tag_peel$descriptor() {
        return git_tag_peel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_peel(git_object **tag_target_out, const git_tag *tag)
     * }
     */
    public static MethodHandle git_tag_peel$handle() {
        return git_tag_peel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_peel(git_object **tag_target_out, const git_tag *tag)
     * }
     */
    public static MemorySegment git_tag_peel$address() {
        return git_tag_peel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_peel(git_object **tag_target_out, const git_tag *tag)
     * }
     */
    public static int git_tag_peel(MemorySegment tag_target_out, MemorySegment tag) {
        var mh$ = git_tag_peel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_peel", tag_target_out, tag);
            }
            return (int)mh$.invokeExact(tag_target_out, tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_dup(git_tag **out, git_tag *source)
     * }
     */
    public static FunctionDescriptor git_tag_dup$descriptor() {
        return git_tag_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_dup(git_tag **out, git_tag *source)
     * }
     */
    public static MethodHandle git_tag_dup$handle() {
        return git_tag_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_dup(git_tag **out, git_tag *source)
     * }
     */
    public static MemorySegment git_tag_dup$address() {
        return git_tag_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_dup(git_tag **out, git_tag *source)
     * }
     */
    public static int git_tag_dup(MemorySegment out, MemorySegment source) {
        var mh$ = git_tag_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_dup", out, source);
            }
            return (int)mh$.invokeExact(out, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_tag_name_is_valid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_tag_name_is_valid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_tag_name_is_valid(int *valid, const char *name)
     * }
     */
    public static FunctionDescriptor git_tag_name_is_valid$descriptor() {
        return git_tag_name_is_valid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_tag_name_is_valid(int *valid, const char *name)
     * }
     */
    public static MethodHandle git_tag_name_is_valid$handle() {
        return git_tag_name_is_valid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_tag_name_is_valid(int *valid, const char *name)
     * }
     */
    public static MemorySegment git_tag_name_is_valid$address() {
        return git_tag_name_is_valid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_tag_name_is_valid(int *valid, const char *name)
     * }
     */
    public static int git_tag_name_is_valid(MemorySegment valid, MemorySegment name) {
        var mh$ = git_tag_name_is_valid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_tag_name_is_valid", valid, name);
            }
            return (int)mh$.invokeExact(valid, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_transaction_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_transaction_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_transaction_new(git_transaction **out, git_repository *repo)
     * }
     */
    public static FunctionDescriptor git_transaction_new$descriptor() {
        return git_transaction_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_transaction_new(git_transaction **out, git_repository *repo)
     * }
     */
    public static MethodHandle git_transaction_new$handle() {
        return git_transaction_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_transaction_new(git_transaction **out, git_repository *repo)
     * }
     */
    public static MemorySegment git_transaction_new$address() {
        return git_transaction_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_transaction_new(git_transaction **out, git_repository *repo)
     * }
     */
    public static int git_transaction_new(MemorySegment out, MemorySegment repo) {
        var mh$ = git_transaction_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_transaction_new", out, repo);
            }
            return (int)mh$.invokeExact(out, repo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_transaction_lock_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_transaction_lock_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_transaction_lock_ref(git_transaction *tx, const char *refname)
     * }
     */
    public static FunctionDescriptor git_transaction_lock_ref$descriptor() {
        return git_transaction_lock_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_transaction_lock_ref(git_transaction *tx, const char *refname)
     * }
     */
    public static MethodHandle git_transaction_lock_ref$handle() {
        return git_transaction_lock_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_transaction_lock_ref(git_transaction *tx, const char *refname)
     * }
     */
    public static MemorySegment git_transaction_lock_ref$address() {
        return git_transaction_lock_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_transaction_lock_ref(git_transaction *tx, const char *refname)
     * }
     */
    public static int git_transaction_lock_ref(MemorySegment tx, MemorySegment refname) {
        var mh$ = git_transaction_lock_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_transaction_lock_ref", tx, refname);
            }
            return (int)mh$.invokeExact(tx, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_transaction_set_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_transaction_set_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_transaction_set_target(git_transaction *tx, const char *refname, const git_oid *target, const git_signature *sig, const char *msg)
     * }
     */
    public static FunctionDescriptor git_transaction_set_target$descriptor() {
        return git_transaction_set_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_transaction_set_target(git_transaction *tx, const char *refname, const git_oid *target, const git_signature *sig, const char *msg)
     * }
     */
    public static MethodHandle git_transaction_set_target$handle() {
        return git_transaction_set_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_transaction_set_target(git_transaction *tx, const char *refname, const git_oid *target, const git_signature *sig, const char *msg)
     * }
     */
    public static MemorySegment git_transaction_set_target$address() {
        return git_transaction_set_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_transaction_set_target(git_transaction *tx, const char *refname, const git_oid *target, const git_signature *sig, const char *msg)
     * }
     */
    public static int git_transaction_set_target(MemorySegment tx, MemorySegment refname, MemorySegment target, MemorySegment sig, MemorySegment msg) {
        var mh$ = git_transaction_set_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_transaction_set_target", tx, refname, target, sig, msg);
            }
            return (int)mh$.invokeExact(tx, refname, target, sig, msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_transaction_set_symbolic_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_transaction_set_symbolic_target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_transaction_set_symbolic_target(git_transaction *tx, const char *refname, const char *target, const git_signature *sig, const char *msg)
     * }
     */
    public static FunctionDescriptor git_transaction_set_symbolic_target$descriptor() {
        return git_transaction_set_symbolic_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_transaction_set_symbolic_target(git_transaction *tx, const char *refname, const char *target, const git_signature *sig, const char *msg)
     * }
     */
    public static MethodHandle git_transaction_set_symbolic_target$handle() {
        return git_transaction_set_symbolic_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_transaction_set_symbolic_target(git_transaction *tx, const char *refname, const char *target, const git_signature *sig, const char *msg)
     * }
     */
    public static MemorySegment git_transaction_set_symbolic_target$address() {
        return git_transaction_set_symbolic_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_transaction_set_symbolic_target(git_transaction *tx, const char *refname, const char *target, const git_signature *sig, const char *msg)
     * }
     */
    public static int git_transaction_set_symbolic_target(MemorySegment tx, MemorySegment refname, MemorySegment target, MemorySegment sig, MemorySegment msg) {
        var mh$ = git_transaction_set_symbolic_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_transaction_set_symbolic_target", tx, refname, target, sig, msg);
            }
            return (int)mh$.invokeExact(tx, refname, target, sig, msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_transaction_set_reflog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_transaction_set_reflog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_transaction_set_reflog(git_transaction *tx, const char *refname, const git_reflog *reflog)
     * }
     */
    public static FunctionDescriptor git_transaction_set_reflog$descriptor() {
        return git_transaction_set_reflog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_transaction_set_reflog(git_transaction *tx, const char *refname, const git_reflog *reflog)
     * }
     */
    public static MethodHandle git_transaction_set_reflog$handle() {
        return git_transaction_set_reflog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_transaction_set_reflog(git_transaction *tx, const char *refname, const git_reflog *reflog)
     * }
     */
    public static MemorySegment git_transaction_set_reflog$address() {
        return git_transaction_set_reflog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_transaction_set_reflog(git_transaction *tx, const char *refname, const git_reflog *reflog)
     * }
     */
    public static int git_transaction_set_reflog(MemorySegment tx, MemorySegment refname, MemorySegment reflog) {
        var mh$ = git_transaction_set_reflog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_transaction_set_reflog", tx, refname, reflog);
            }
            return (int)mh$.invokeExact(tx, refname, reflog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_transaction_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_transaction_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_transaction_remove(git_transaction *tx, const char *refname)
     * }
     */
    public static FunctionDescriptor git_transaction_remove$descriptor() {
        return git_transaction_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_transaction_remove(git_transaction *tx, const char *refname)
     * }
     */
    public static MethodHandle git_transaction_remove$handle() {
        return git_transaction_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_transaction_remove(git_transaction *tx, const char *refname)
     * }
     */
    public static MemorySegment git_transaction_remove$address() {
        return git_transaction_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_transaction_remove(git_transaction *tx, const char *refname)
     * }
     */
    public static int git_transaction_remove(MemorySegment tx, MemorySegment refname) {
        var mh$ = git_transaction_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_transaction_remove", tx, refname);
            }
            return (int)mh$.invokeExact(tx, refname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_transaction_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            git2.C_INT,
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_transaction_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int git_transaction_commit(git_transaction *tx)
     * }
     */
    public static FunctionDescriptor git_transaction_commit$descriptor() {
        return git_transaction_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int git_transaction_commit(git_transaction *tx)
     * }
     */
    public static MethodHandle git_transaction_commit$handle() {
        return git_transaction_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int git_transaction_commit(git_transaction *tx)
     * }
     */
    public static MemorySegment git_transaction_commit$address() {
        return git_transaction_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int git_transaction_commit(git_transaction *tx)
     * }
     */
    public static int git_transaction_commit(MemorySegment tx) {
        var mh$ = git_transaction_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_transaction_commit", tx);
            }
            return (int)mh$.invokeExact(tx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class git_transaction_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            git2.C_POINTER
        );

        public static final MemorySegment ADDR = git2.findOrThrow("git_transaction_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void git_transaction_free(git_transaction *tx)
     * }
     */
    public static FunctionDescriptor git_transaction_free$descriptor() {
        return git_transaction_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void git_transaction_free(git_transaction *tx)
     * }
     */
    public static MethodHandle git_transaction_free$handle() {
        return git_transaction_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void git_transaction_free(git_transaction *tx)
     * }
     */
    public static MemorySegment git_transaction_free$address() {
        return git_transaction_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void git_transaction_free(git_transaction *tx)
     * }
     */
    public static void git_transaction_free(MemorySegment tx) {
        var mh$ = git_transaction_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("git_transaction_free", tx);
            }
            mh$.invokeExact(tx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final long CLOCKS_PER_SEC = 1000000L;
    /**
     * {@snippet lang=c :
     * #define CLOCKS_PER_SEC 1000000
     * }
     */
    public static long CLOCKS_PER_SEC() {
        return CLOCKS_PER_SEC;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final int __WCLONE = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCLONE 2147483648
     * }
     */
    public static int __WCLONE() {
        return __WCLONE;
    }
    private static final int __HAVE_DISTINCT_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT16 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT16() {
        return __HAVE_DISTINCT_FLOAT16;
    }
    private static final int __HAVE_DISTINCT_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128X() {
        return __HAVE_DISTINCT_FLOAT128X;
    }
    private static final int __HAVE_FLOAT128_UNLIKE_LDBL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128_UNLIKE_LDBL 0
     * }
     */
    public static int __HAVE_FLOAT128_UNLIKE_LDBL() {
        return __HAVE_FLOAT128_UNLIKE_LDBL;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final long _SIGSET_NWORDS = 16L;
    /**
     * {@snippet lang=c :
     * #define _SIGSET_NWORDS 16
     * }
     */
    public static long _SIGSET_NWORDS() {
        return _SIGSET_NWORDS;
    }
    private static final int __NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __NFDBITS 64
     * }
     */
    public static int __NFDBITS() {
        return __NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
    private static final int NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 64
     * }
     */
    public static int NFDBITS() {
        return NFDBITS;
    }
    private static final int __PTHREAD_RWLOCK_ELISION_EXTRA = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_ELISION_EXTRA 0
     * }
     */
    public static int __PTHREAD_RWLOCK_ELISION_EXTRA() {
        return __PTHREAD_RWLOCK_ELISION_EXTRA;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI64_PREFIX "l"
     * }
     */
    public static MemorySegment __PRI64_PREFIX() {
        class Holder {
            static final MemorySegment __PRI64_PREFIX
                = git2.LIBRARY_ARENA.allocateFrom("l");
        }
        return Holder.__PRI64_PREFIX;
    }
    /**
     * {@snippet lang=c :
     * #define __PRIPTR_PREFIX "l"
     * }
     */
    public static MemorySegment __PRIPTR_PREFIX() {
        class Holder {
            static final MemorySegment __PRIPTR_PREFIX
                = git2.LIBRARY_ARENA.allocateFrom("l");
        }
        return Holder.__PRIPTR_PREFIX;
    }
    /**
     * {@snippet lang=c :
     * #define PRId8 "d"
     * }
     */
    public static MemorySegment PRId8() {
        class Holder {
            static final MemorySegment PRId8
                = git2.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId8;
    }
    /**
     * {@snippet lang=c :
     * #define PRId16 "d"
     * }
     */
    public static MemorySegment PRId16() {
        class Holder {
            static final MemorySegment PRId16
                = git2.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId16;
    }
    /**
     * {@snippet lang=c :
     * #define PRId32 "d"
     * }
     */
    public static MemorySegment PRId32() {
        class Holder {
            static final MemorySegment PRId32
                = git2.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId32;
    }
    /**
     * {@snippet lang=c :
     * #define PRId64 "ld"
     * }
     */
    public static MemorySegment PRId64() {
        class Holder {
            static final MemorySegment PRId64
                = git2.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRId64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST8 "d"
     * }
     */
    public static MemorySegment PRIdLEAST8() {
        class Holder {
            static final MemorySegment PRIdLEAST8
                = git2.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST16 "d"
     * }
     */
    public static MemorySegment PRIdLEAST16() {
        class Holder {
            static final MemorySegment PRIdLEAST16
                = git2.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST32 "d"
     * }
     */
    public static MemorySegment PRIdLEAST32() {
        class Holder {
            static final MemorySegment PRIdLEAST32
                = git2.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST64 "ld"
     * }
     */
    public static MemorySegment PRIdLEAST64() {
        class Holder {
            static final MemorySegment PRIdLEAST64
                = git2.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST8 "d"
     * }
     */
    public static MemorySegment PRIdFAST8() {
        class Holder {
            static final MemorySegment PRIdFAST8
                = git2.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST16 "ld"
     * }
     */
    public static MemorySegment PRIdFAST16() {
        class Holder {
            static final MemorySegment PRIdFAST16
                = git2.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST32 "ld"
     * }
     */
    public static MemorySegment PRIdFAST32() {
        class Holder {
            static final MemorySegment PRIdFAST32
                = git2.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST64 "ld"
     * }
     */
    public static MemorySegment PRIdFAST64() {
        class Holder {
            static final MemorySegment PRIdFAST64
                = git2.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi8 "i"
     * }
     */
    public static MemorySegment PRIi8() {
        class Holder {
            static final MemorySegment PRIi8
                = git2.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi16 "i"
     * }
     */
    public static MemorySegment PRIi16() {
        class Holder {
            static final MemorySegment PRIi16
                = git2.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi16;
    }
}

